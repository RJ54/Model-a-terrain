
VIDEO_DEMO_CODE.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000040  00800200  00002810  000028a4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002810  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000042  00800240  00800240  000028e4  2**0
                  ALLOC
  3 .stab         000031bc  00000000  00000000  000028e4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000009c3  00000000  00000000  00005aa0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000100  00000000  00000000  00006468  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000024d1  00000000  00000000  00006568  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000006e1  00000000  00000000  00008a39  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000e47  00000000  00000000  0000911a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000095c  00000000  00000000  00009f64  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000920  00000000  00000000  0000a8c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000023fa  00000000  00000000  0000b1e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000c8  00000000  00000000  0000d5da  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 89 00 	jmp	0x112	; 0x112 <__ctors_end>
       4:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
       8:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
       c:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      10:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      14:	0c 94 3e 07 	jmp	0xe7c	; 0xe7c <__vector_5>
      18:	0c 94 63 07 	jmp	0xec6	; 0xec6 <__vector_6>
      1c:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      20:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      24:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      28:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      2c:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      30:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      34:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      38:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      3c:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      40:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      44:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      48:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      4c:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      50:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      54:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      58:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      5c:	0c 94 34 06 	jmp	0xc68	; 0xc68 <__vector_23>
      60:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      64:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      68:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      6c:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      70:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      74:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      78:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      7c:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      80:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      84:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      88:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      8c:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      90:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      94:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      98:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      9c:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      a0:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      a4:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      a8:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      ac:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      b0:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      b4:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      b8:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      bc:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      c0:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      c4:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      c8:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      cc:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      d0:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      d4:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      d8:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      dc:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      e0:	0c 94 aa 00 	jmp	0x154	; 0x154 <__bad_interrupt>
      e4:	08 4a       	sbci	r16, 0xA8	; 168
      e6:	d7 3b       	cpi	r29, 0xB7	; 183
      e8:	3b ce       	rjmp	.-906    	; 0xfffffd60 <__eeprom_end+0xff7efd60>
      ea:	01 6e       	ori	r16, 0xE1	; 225
      ec:	84 bc       	out	0x24, r8	; 36
      ee:	bf fd       	.word	0xfdbf	; ????
      f0:	c1 2f       	mov	r28, r17
      f2:	3d 6c       	ori	r19, 0xCD	; 205
      f4:	74 31       	cpi	r23, 0x14	; 20
      f6:	9a bd       	out	0x2a, r25	; 42
      f8:	56 83       	std	Z+6, r21	; 0x06
      fa:	3d da       	rcall	.-2950   	; 0xfffff576 <__eeprom_end+0xff7ef576>
      fc:	3d 00       	.word	0x003d	; ????
      fe:	c7 7f       	andi	r28, 0xF7	; 247
     100:	11 be       	out	0x31, r1	; 49
     102:	d9 e4       	ldi	r29, 0x49	; 73
     104:	bb 4c       	sbci	r27, 0xCB	; 203
     106:	3e 91       	ld	r19, -X
     108:	6b aa       	sts	0x9b, r22
     10a:	aa be       	out	0x3a, r10	; 58
     10c:	00 00       	nop
     10e:	00 80       	ld	r0, Z
     110:	3f 00       	.word	0x003f	; ????

00000112 <__ctors_end>:
     112:	11 24       	eor	r1, r1
     114:	1f be       	out	0x3f, r1	; 63
     116:	cf ef       	ldi	r28, 0xFF	; 255
     118:	d1 e2       	ldi	r29, 0x21	; 33
     11a:	de bf       	out	0x3e, r29	; 62
     11c:	cd bf       	out	0x3d, r28	; 61
     11e:	00 e0       	ldi	r16, 0x00	; 0
     120:	0c bf       	out	0x3c, r16	; 60

00000122 <__do_copy_data>:
     122:	12 e0       	ldi	r17, 0x02	; 2
     124:	a0 e0       	ldi	r26, 0x00	; 0
     126:	b2 e0       	ldi	r27, 0x02	; 2
     128:	e0 e1       	ldi	r30, 0x10	; 16
     12a:	f8 e2       	ldi	r31, 0x28	; 40
     12c:	00 e0       	ldi	r16, 0x00	; 0
     12e:	0b bf       	out	0x3b, r16	; 59
     130:	02 c0       	rjmp	.+4      	; 0x136 <__do_copy_data+0x14>
     132:	07 90       	elpm	r0, Z+
     134:	0d 92       	st	X+, r0
     136:	a0 34       	cpi	r26, 0x40	; 64
     138:	b1 07       	cpc	r27, r17
     13a:	d9 f7       	brne	.-10     	; 0x132 <__do_copy_data+0x10>

0000013c <__do_clear_bss>:
     13c:	12 e0       	ldi	r17, 0x02	; 2
     13e:	a0 e4       	ldi	r26, 0x40	; 64
     140:	b2 e0       	ldi	r27, 0x02	; 2
     142:	01 c0       	rjmp	.+2      	; 0x146 <.do_clear_bss_start>

00000144 <.do_clear_bss_loop>:
     144:	1d 92       	st	X+, r1

00000146 <.do_clear_bss_start>:
     146:	a2 38       	cpi	r26, 0x82	; 130
     148:	b1 07       	cpc	r27, r17
     14a:	e1 f7       	brne	.-8      	; 0x144 <.do_clear_bss_loop>
     14c:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <main>
     150:	0c 94 06 14 	jmp	0x280c	; 0x280c <_exit>

00000154 <__bad_interrupt>:
     154:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000158 <buzzer_pin_config>:
}


void buzzer_pin_config (void)
{
	DDRC = DDRC | 0x08;		//Setting PORTC 3 as output
     158:	3b 9a       	sbi	0x07, 3	; 7
	PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
     15a:	43 98       	cbi	0x08, 3	; 8
}
     15c:	08 95       	ret

0000015e <lcd_wr_command>:
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
	lcd_port &= 0x0F;
     15e:	98 b1       	in	r25, 0x08	; 8
     160:	9f 70       	andi	r25, 0x0F	; 15
     162:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     164:	98 b1       	in	r25, 0x08	; 8
//Function to Write Command on LCD
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
     166:	28 2f       	mov	r18, r24
     168:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     16a:	92 2b       	or	r25, r18
     16c:	98 b9       	out	0x08, r25	; 8
	cbit(lcd_port,RS);
     16e:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     170:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     172:	42 9a       	sbi	0x08, 2	; 8
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     174:	ef ef       	ldi	r30, 0xFF	; 255
     176:	f7 e4       	ldi	r31, 0x47	; 71
     178:	31 97       	sbiw	r30, 0x01	; 1
     17a:	f1 f7       	brne	.-4      	; 0x178 <lcd_wr_command+0x1a>
     17c:	00 c0       	rjmp	.+0      	; 0x17e <lcd_wr_command+0x20>
     17e:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     180:	42 98       	cbi	0x08, 2	; 8
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
	lcd_port &= 0x0F;
     182:	98 b1       	in	r25, 0x08	; 8
     184:	9f 70       	andi	r25, 0x0F	; 15
     186:	98 b9       	out	0x08, r25	; 8
	lcd_port |= cmd;
     188:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
     18a:	82 95       	swap	r24
     18c:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= cmd;
     18e:	89 2b       	or	r24, r25
     190:	88 b9       	out	0x08, r24	; 8
	cbit(lcd_port,RS);
     192:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     194:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     196:	42 9a       	sbi	0x08, 2	; 8
     198:	8f ef       	ldi	r24, 0xFF	; 255
     19a:	97 e4       	ldi	r25, 0x47	; 71
     19c:	01 97       	sbiw	r24, 0x01	; 1
     19e:	f1 f7       	brne	.-4      	; 0x19c <lcd_wr_command+0x3e>
     1a0:	00 c0       	rjmp	.+0      	; 0x1a2 <lcd_wr_command+0x44>
     1a2:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     1a4:	42 98       	cbi	0x08, 2	; 8
}
     1a6:	08 95       	ret

000001a8 <lcd_port_config>:
unsigned int million;

//Function to configure LCD port
void lcd_port_config (void)
{
	DDRC = DDRC | 0xF7; //all the LCD pin's direction set as output
     1a8:	87 b1       	in	r24, 0x07	; 7
     1aa:	87 6f       	ori	r24, 0xF7	; 247
     1ac:	87 b9       	out	0x07, r24	; 7
	PORTC = PORTC & 0x80; // all the LCD pins are set to logic 0 except PORTC 7
     1ae:	88 b1       	in	r24, 0x08	; 8
     1b0:	80 78       	andi	r24, 0x80	; 128
     1b2:	88 b9       	out	0x08, r24	; 8
}
     1b4:	08 95       	ret

000001b6 <lcd_set_4bit>:
     1b6:	86 e6       	ldi	r24, 0x66	; 102
     1b8:	9e e0       	ldi	r25, 0x0E	; 14
     1ba:	01 97       	sbiw	r24, 0x01	; 1
     1bc:	f1 f7       	brne	.-4      	; 0x1ba <lcd_set_4bit+0x4>
     1be:	00 00       	nop
//Function to Reset LCD
void lcd_set_4bit()
{
	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     1c0:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     1c2:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     1c4:	80 e3       	ldi	r24, 0x30	; 48
     1c6:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     1c8:	42 9a       	sbi	0x08, 2	; 8
     1ca:	ef ef       	ldi	r30, 0xFF	; 255
     1cc:	f7 e4       	ldi	r31, 0x47	; 71
     1ce:	31 97       	sbiw	r30, 0x01	; 1
     1d0:	f1 f7       	brne	.-4      	; 0x1ce <lcd_set_4bit+0x18>
     1d2:	00 c0       	rjmp	.+0      	; 0x1d4 <lcd_set_4bit+0x1e>
     1d4:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     1d6:	42 98       	cbi	0x08, 2	; 8
     1d8:	e6 e6       	ldi	r30, 0x66	; 102
     1da:	fe e0       	ldi	r31, 0x0E	; 14
     1dc:	31 97       	sbiw	r30, 0x01	; 1
     1de:	f1 f7       	brne	.-4      	; 0x1dc <lcd_set_4bit+0x26>
     1e0:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     1e2:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     1e4:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     1e6:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     1e8:	42 9a       	sbi	0x08, 2	; 8
     1ea:	ef ef       	ldi	r30, 0xFF	; 255
     1ec:	f7 e4       	ldi	r31, 0x47	; 71
     1ee:	31 97       	sbiw	r30, 0x01	; 1
     1f0:	f1 f7       	brne	.-4      	; 0x1ee <lcd_set_4bit+0x38>
     1f2:	00 c0       	rjmp	.+0      	; 0x1f4 <lcd_set_4bit+0x3e>
     1f4:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     1f6:	42 98       	cbi	0x08, 2	; 8
     1f8:	e6 e6       	ldi	r30, 0x66	; 102
     1fa:	fe e0       	ldi	r31, 0x0E	; 14
     1fc:	31 97       	sbiw	r30, 0x01	; 1
     1fe:	f1 f7       	brne	.-4      	; 0x1fc <lcd_set_4bit+0x46>
     200:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     202:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     204:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     206:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     208:	42 9a       	sbi	0x08, 2	; 8
     20a:	8f ef       	ldi	r24, 0xFF	; 255
     20c:	97 e4       	ldi	r25, 0x47	; 71
     20e:	01 97       	sbiw	r24, 0x01	; 1
     210:	f1 f7       	brne	.-4      	; 0x20e <lcd_set_4bit+0x58>
     212:	00 c0       	rjmp	.+0      	; 0x214 <lcd_set_4bit+0x5e>
     214:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     216:	42 98       	cbi	0x08, 2	; 8
     218:	e6 e6       	ldi	r30, 0x66	; 102
     21a:	fe e0       	ldi	r31, 0x0E	; 14
     21c:	31 97       	sbiw	r30, 0x01	; 1
     21e:	f1 f7       	brne	.-4      	; 0x21c <lcd_set_4bit+0x66>
     220:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     222:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     224:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x20;				//Sending 2 to initialise LCD 4-bit mode
     226:	80 e2       	ldi	r24, 0x20	; 32
     228:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     22a:	42 9a       	sbi	0x08, 2	; 8
     22c:	86 e6       	ldi	r24, 0x66	; 102
     22e:	9e e0       	ldi	r25, 0x0E	; 14
     230:	01 97       	sbiw	r24, 0x01	; 1
     232:	f1 f7       	brne	.-4      	; 0x230 <lcd_set_4bit+0x7a>
     234:	00 00       	nop
	_delay_ms(1);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     236:	42 98       	cbi	0x08, 2	; 8

	
}
     238:	08 95       	ret

0000023a <lcd_init>:

//Function to Initialize LCD
void lcd_init()
{
     23a:	cf 93       	push	r28
     23c:	df 93       	push	r29
     23e:	86 e6       	ldi	r24, 0x66	; 102
     240:	9e e0       	ldi	r25, 0x0E	; 14
     242:	01 97       	sbiw	r24, 0x01	; 1
     244:	f1 f7       	brne	.-4      	; 0x242 <lcd_init+0x8>
     246:	00 00       	nop
	_delay_ms(1);
	lcd_port_config ();
     248:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <lcd_port_config>
	lcd_set_4bit();
     24c:	0e 94 db 00 	call	0x1b6	; 0x1b6 <lcd_set_4bit>
	lcd_wr_command(0x28);			//LCD 4-bit mode and 2 lines.
     250:	cf ea       	ldi	r28, 0xAF	; 175
     252:	d0 e0       	ldi	r29, 0x00	; 0
     254:	88 e2       	ldi	r24, 0x28	; 40
     256:	90 e0       	ldi	r25, 0x00	; 0
     258:	fe 01       	movw	r30, r28
     25a:	19 95       	eicall
	lcd_wr_command(0x01);
     25c:	81 e0       	ldi	r24, 0x01	; 1
     25e:	90 e0       	ldi	r25, 0x00	; 0
     260:	fe 01       	movw	r30, r28
     262:	19 95       	eicall
	lcd_wr_command(0x06);
     264:	86 e0       	ldi	r24, 0x06	; 6
     266:	90 e0       	ldi	r25, 0x00	; 0
     268:	fe 01       	movw	r30, r28
     26a:	19 95       	eicall
	lcd_wr_command(0x0E);
     26c:	8e e0       	ldi	r24, 0x0E	; 14
     26e:	90 e0       	ldi	r25, 0x00	; 0
     270:	fe 01       	movw	r30, r28
     272:	19 95       	eicall
	lcd_wr_command(0x80);
     274:	80 e8       	ldi	r24, 0x80	; 128
     276:	90 e0       	ldi	r25, 0x00	; 0
     278:	fe 01       	movw	r30, r28
     27a:	19 95       	eicall
	
}
     27c:	df 91       	pop	r29
     27e:	cf 91       	pop	r28
     280:	08 95       	ret

00000282 <lcd_wr_char>:
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
	lcd_port &= 0x0F;
     282:	98 b1       	in	r25, 0x08	; 8
     284:	9f 70       	andi	r25, 0x0F	; 15
     286:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     288:	98 b1       	in	r25, 0x08	; 8
//Function to Write Data on LCD
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
     28a:	28 2f       	mov	r18, r24
     28c:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     28e:	92 2b       	or	r25, r18
     290:	98 b9       	out	0x08, r25	; 8
	sbit(lcd_port,RS);
     292:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     294:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     296:	42 9a       	sbi	0x08, 2	; 8
     298:	ef ef       	ldi	r30, 0xFF	; 255
     29a:	f7 e4       	ldi	r31, 0x47	; 71
     29c:	31 97       	sbiw	r30, 0x01	; 1
     29e:	f1 f7       	brne	.-4      	; 0x29c <lcd_wr_char+0x1a>
     2a0:	00 c0       	rjmp	.+0      	; 0x2a2 <lcd_wr_char+0x20>
     2a2:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     2a4:	42 98       	cbi	0x08, 2	; 8

	letter = letter & 0x0F;
	letter = letter<<4;
	lcd_port &= 0x0F;
     2a6:	98 b1       	in	r25, 0x08	; 8
     2a8:	9f 70       	andi	r25, 0x0F	; 15
     2aa:	98 b9       	out	0x08, r25	; 8
	lcd_port |= letter;
     2ac:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);

	letter = letter & 0x0F;
	letter = letter<<4;
     2ae:	82 95       	swap	r24
     2b0:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= letter;
     2b2:	89 2b       	or	r24, r25
     2b4:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,RS);
     2b6:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     2b8:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     2ba:	42 9a       	sbi	0x08, 2	; 8
     2bc:	8f ef       	ldi	r24, 0xFF	; 255
     2be:	97 e4       	ldi	r25, 0x47	; 71
     2c0:	01 97       	sbiw	r24, 0x01	; 1
     2c2:	f1 f7       	brne	.-4      	; 0x2c0 <lcd_wr_char+0x3e>
     2c4:	00 c0       	rjmp	.+0      	; 0x2c6 <lcd_wr_char+0x44>
     2c6:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     2c8:	42 98       	cbi	0x08, 2	; 8
}
     2ca:	08 95       	ret

000002cc <lcd_home>:


//Function to bring cursor at home position
void lcd_home()
{
	lcd_wr_command(0x80);
     2cc:	80 e8       	ldi	r24, 0x80	; 128
     2ce:	0e 94 af 00 	call	0x15e	; 0x15e <lcd_wr_command>
}
     2d2:	08 95       	ret

000002d4 <lcd_string>:


//Function to Print String on LCD
void lcd_string(char *str)
{
     2d4:	cf 93       	push	r28
     2d6:	df 93       	push	r29
     2d8:	ec 01       	movw	r28, r24
	while(*str != '\0')
     2da:	88 81       	ld	r24, Y
     2dc:	88 23       	and	r24, r24
     2de:	31 f0       	breq	.+12     	; 0x2ec <lcd_string+0x18>
	lcd_wr_command(0x80);
}


//Function to Print String on LCD
void lcd_string(char *str)
     2e0:	21 96       	adiw	r28, 0x01	; 1
{
	while(*str != '\0')
	{
		lcd_wr_char(*str);
     2e2:	0e 94 41 01 	call	0x282	; 0x282 <lcd_wr_char>


//Function to Print String on LCD
void lcd_string(char *str)
{
	while(*str != '\0')
     2e6:	89 91       	ld	r24, Y+
     2e8:	88 23       	and	r24, r24
     2ea:	d9 f7       	brne	.-10     	; 0x2e2 <lcd_string+0xe>
	{
		lcd_wr_char(*str);
		str++;
	}
}
     2ec:	df 91       	pop	r29
     2ee:	cf 91       	pop	r28
     2f0:	08 95       	ret

000002f2 <lcd_cursor>:

//Position the LCD cursor at "row", "column".

void lcd_cursor (char row, char column)
{
	switch (row) {
     2f2:	82 30       	cpi	r24, 0x02	; 2
     2f4:	79 f0       	breq	.+30     	; 0x314 <lcd_cursor+0x22>
     2f6:	83 30       	cpi	r24, 0x03	; 3
     2f8:	18 f4       	brcc	.+6      	; 0x300 <lcd_cursor+0xe>
     2fa:	81 30       	cpi	r24, 0x01	; 1
     2fc:	c9 f4       	brne	.+50     	; 0x330 <lcd_cursor+0x3e>
     2fe:	05 c0       	rjmp	.+10     	; 0x30a <lcd_cursor+0x18>
     300:	83 30       	cpi	r24, 0x03	; 3
     302:	69 f0       	breq	.+26     	; 0x31e <lcd_cursor+0x2c>
     304:	84 30       	cpi	r24, 0x04	; 4
     306:	a1 f4       	brne	.+40     	; 0x330 <lcd_cursor+0x3e>
     308:	0f c0       	rjmp	.+30     	; 0x328 <lcd_cursor+0x36>
		case 1: lcd_wr_command (0x80 + column - 1); break;
     30a:	86 2f       	mov	r24, r22
     30c:	81 58       	subi	r24, 0x81	; 129
     30e:	0e 94 af 00 	call	0x15e	; 0x15e <lcd_wr_command>
     312:	08 95       	ret
		case 2: lcd_wr_command (0xc0 + column - 1); break;
     314:	86 2f       	mov	r24, r22
     316:	81 54       	subi	r24, 0x41	; 65
     318:	0e 94 af 00 	call	0x15e	; 0x15e <lcd_wr_command>
     31c:	08 95       	ret
		case 3: lcd_wr_command (0x94 + column - 1); break;
     31e:	86 2f       	mov	r24, r22
     320:	8d 56       	subi	r24, 0x6D	; 109
     322:	0e 94 af 00 	call	0x15e	; 0x15e <lcd_wr_command>
     326:	08 95       	ret
		case 4: lcd_wr_command (0xd4 + column - 1); break;
     328:	86 2f       	mov	r24, r22
     32a:	8d 52       	subi	r24, 0x2D	; 45
     32c:	0e 94 af 00 	call	0x15e	; 0x15e <lcd_wr_command>
     330:	08 95       	ret

00000332 <lcd_print>:
	}
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
     332:	0f 93       	push	r16
     334:	1f 93       	push	r17
     336:	cf 93       	push	r28
     338:	df 93       	push	r29
     33a:	8a 01       	movw	r16, r20
     33c:	e9 01       	movw	r28, r18
	unsigned char flag=0;
	if(row==0||coloumn==0)
     33e:	88 23       	and	r24, r24
     340:	11 f0       	breq	.+4      	; 0x346 <lcd_print+0x14>
     342:	66 23       	and	r22, r22
     344:	19 f4       	brne	.+6      	; 0x34c <lcd_print+0x1a>
	{
		lcd_home();
     346:	0e 94 66 01 	call	0x2cc	; 0x2cc <lcd_home>
     34a:	02 c0       	rjmp	.+4      	; 0x350 <lcd_print+0x1e>
	}
	else
	{
		lcd_cursor(row,coloumn);
     34c:	0e 94 79 01 	call	0x2f2	; 0x2f2 <lcd_cursor>
	}
	if(digits==5 || flag==1)
     350:	c5 30       	cpi	r28, 0x05	; 5
     352:	d1 05       	cpc	r29, r1
     354:	71 f4       	brne	.+28     	; 0x372 <lcd_print+0x40>
	{
		million=value/10000+48;
     356:	c8 01       	movw	r24, r16
     358:	60 e1       	ldi	r22, 0x10	; 16
     35a:	77 e2       	ldi	r23, 0x27	; 39
     35c:	0e 94 0e 11 	call	0x221c	; 0x221c <__udivmodhi4>
     360:	cb 01       	movw	r24, r22
     362:	c0 96       	adiw	r24, 0x30	; 48
     364:	90 93 73 02 	sts	0x0273, r25
     368:	80 93 72 02 	sts	0x0272, r24
		lcd_wr_char(million);
     36c:	0e 94 41 01 	call	0x282	; 0x282 <lcd_wr_char>
     370:	03 c0       	rjmp	.+6      	; 0x378 <lcd_print+0x46>
		flag=1;
	}
	if(digits==4 || flag==1)
     372:	c4 30       	cpi	r28, 0x04	; 4
     374:	d1 05       	cpc	r29, r1
     376:	b9 f4       	brne	.+46     	; 0x3a6 <lcd_print+0x74>
	{
		temp = value/1000;
     378:	c8 01       	movw	r24, r16
     37a:	68 ee       	ldi	r22, 0xE8	; 232
     37c:	73 e0       	ldi	r23, 0x03	; 3
     37e:	0e 94 0e 11 	call	0x221c	; 0x221c <__udivmodhi4>
     382:	cb 01       	movw	r24, r22
     384:	70 93 75 02 	sts	0x0275, r23
     388:	60 93 74 02 	sts	0x0274, r22
		thousand = temp%10 + 48;
     38c:	6a e0       	ldi	r22, 0x0A	; 10
     38e:	70 e0       	ldi	r23, 0x00	; 0
     390:	0e 94 0e 11 	call	0x221c	; 0x221c <__udivmodhi4>
     394:	c0 96       	adiw	r24, 0x30	; 48
     396:	90 93 81 02 	sts	0x0281, r25
     39a:	80 93 80 02 	sts	0x0280, r24
		lcd_wr_char(thousand);
     39e:	0e 94 41 01 	call	0x282	; 0x282 <lcd_wr_char>
		flag=1;
     3a2:	81 e0       	ldi	r24, 0x01	; 1
     3a4:	01 c0       	rjmp	.+2      	; 0x3a8 <lcd_print+0x76>
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
	unsigned char flag=0;
     3a6:	80 e0       	ldi	r24, 0x00	; 0
		temp = value/1000;
		thousand = temp%10 + 48;
		lcd_wr_char(thousand);
		flag=1;
	}
	if(digits==3 || flag==1)
     3a8:	c3 30       	cpi	r28, 0x03	; 3
     3aa:	d1 05       	cpc	r29, r1
     3ac:	11 f0       	breq	.+4      	; 0x3b2 <lcd_print+0x80>
     3ae:	81 30       	cpi	r24, 0x01	; 1
     3b0:	b1 f4       	brne	.+44     	; 0x3de <lcd_print+0xac>
	{
		temp = value/100;
     3b2:	c8 01       	movw	r24, r16
     3b4:	64 e6       	ldi	r22, 0x64	; 100
     3b6:	70 e0       	ldi	r23, 0x00	; 0
     3b8:	0e 94 0e 11 	call	0x221c	; 0x221c <__udivmodhi4>
     3bc:	cb 01       	movw	r24, r22
     3be:	70 93 75 02 	sts	0x0275, r23
     3c2:	60 93 74 02 	sts	0x0274, r22
		hundred = temp%10 + 48;
     3c6:	6a e0       	ldi	r22, 0x0A	; 10
     3c8:	70 e0       	ldi	r23, 0x00	; 0
     3ca:	0e 94 0e 11 	call	0x221c	; 0x221c <__udivmodhi4>
     3ce:	c0 96       	adiw	r24, 0x30	; 48
     3d0:	90 93 7d 02 	sts	0x027D, r25
     3d4:	80 93 7c 02 	sts	0x027C, r24
		lcd_wr_char(hundred);
     3d8:	0e 94 41 01 	call	0x282	; 0x282 <lcd_wr_char>
		flag=1;
     3dc:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==2 || flag==1)
     3de:	c2 30       	cpi	r28, 0x02	; 2
     3e0:	d1 05       	cpc	r29, r1
     3e2:	11 f0       	breq	.+4      	; 0x3e8 <lcd_print+0xb6>
     3e4:	81 30       	cpi	r24, 0x01	; 1
     3e6:	b1 f4       	brne	.+44     	; 0x414 <lcd_print+0xe2>
	{
		temp = value/10;
     3e8:	2a e0       	ldi	r18, 0x0A	; 10
     3ea:	30 e0       	ldi	r19, 0x00	; 0
     3ec:	c8 01       	movw	r24, r16
     3ee:	b9 01       	movw	r22, r18
     3f0:	0e 94 0e 11 	call	0x221c	; 0x221c <__udivmodhi4>
     3f4:	cb 01       	movw	r24, r22
     3f6:	70 93 75 02 	sts	0x0275, r23
     3fa:	60 93 74 02 	sts	0x0274, r22
		tens = temp%10 + 48;
     3fe:	b9 01       	movw	r22, r18
     400:	0e 94 0e 11 	call	0x221c	; 0x221c <__udivmodhi4>
     404:	c0 96       	adiw	r24, 0x30	; 48
     406:	90 93 77 02 	sts	0x0277, r25
     40a:	80 93 76 02 	sts	0x0276, r24
		lcd_wr_char(tens);
     40e:	0e 94 41 01 	call	0x282	; 0x282 <lcd_wr_char>
		flag=1;
     412:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==1 || flag==1)
     414:	c1 30       	cpi	r28, 0x01	; 1
     416:	d1 05       	cpc	r29, r1
     418:	11 f0       	breq	.+4      	; 0x41e <lcd_print+0xec>
     41a:	81 30       	cpi	r24, 0x01	; 1
     41c:	61 f4       	brne	.+24     	; 0x436 <lcd_print+0x104>
	{
		unit = value%10 + 48;
     41e:	c8 01       	movw	r24, r16
     420:	6a e0       	ldi	r22, 0x0A	; 10
     422:	70 e0       	ldi	r23, 0x00	; 0
     424:	0e 94 0e 11 	call	0x221c	; 0x221c <__udivmodhi4>
     428:	c0 96       	adiw	r24, 0x30	; 48
     42a:	90 93 7f 02 	sts	0x027F, r25
     42e:	80 93 7e 02 	sts	0x027E, r24
		lcd_wr_char(unit);
     432:	0e 94 41 01 	call	0x282	; 0x282 <lcd_wr_char>
	}
	if(digits>5)
     436:	c6 30       	cpi	r28, 0x06	; 6
     438:	d1 05       	cpc	r29, r1
     43a:	1c f0       	brlt	.+6      	; 0x442 <lcd_print+0x110>
	{
		lcd_wr_char('E');
     43c:	85 e4       	ldi	r24, 0x45	; 69
     43e:	0e 94 41 01 	call	0x282	; 0x282 <lcd_wr_char>
	}
	
}
     442:	df 91       	pop	r29
     444:	cf 91       	pop	r28
     446:	1f 91       	pop	r17
     448:	0f 91       	pop	r16
     44a:	08 95       	ret

0000044c <uart0_init>:
//Call uart0_init() once in main() to use the "serial_comm_xbee.c" functions

void uart0_init(void)		//USART0 intitialisation
{
	cli();//clear global interrupts
     44c:	f8 94       	cli
	UCSR0B = 0x00; //disable while setting baud rate
     44e:	e1 ec       	ldi	r30, 0xC1	; 193
     450:	f0 e0       	ldi	r31, 0x00	; 0
     452:	10 82       	st	Z, r1
	UCSR0A = 0x00;
     454:	10 92 c0 00 	sts	0x00C0, r1
	UCSR0C = 0x06;//default value
     458:	86 e0       	ldi	r24, 0x06	; 6
     45a:	80 93 c2 00 	sts	0x00C2, r24
	UBRR0L = 0x5F; //set baud rate low
     45e:	8f e5       	ldi	r24, 0x5F	; 95
     460:	80 93 c4 00 	sts	0x00C4, r24
	UBRR0H = 0x00; //set baud rate high
     464:	10 92 c5 00 	sts	0x00C5, r1
	UCSR0B |=(1<<RXEN0)|(1<<TXEN0);//Enabling Receiver and transmitter  
     468:	80 81       	ld	r24, Z
     46a:	88 61       	ori	r24, 0x18	; 24
     46c:	80 83       	st	Z, r24
	sei();//Set global interrupt
     46e:	78 94       	sei
}
     470:	08 95       	ret

00000472 <USART_Transmit>:

void USART_Transmit( unsigned char data )		//Function to transmit a single byte
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)) );
     472:	e0 ec       	ldi	r30, 0xC0	; 192
     474:	f0 e0       	ldi	r31, 0x00	; 0
     476:	90 81       	ld	r25, Z
     478:	95 ff       	sbrs	r25, 5
     47a:	fd cf       	rjmp	.-6      	; 0x476 <USART_Transmit+0x4>
	/* Put data into buffer, sends the data */
	UDR0 = data;
     47c:	80 93 c6 00 	sts	0x00C6, r24
}
     480:	08 95       	ret

00000482 <USART_Receive>:

unsigned char USART_Receive( void )		//Function for receiving a single byte
{	
	 /* Wait for data to be received */
	 while ( !(UCSR0A & (1<<RXC0)) );
     482:	e0 ec       	ldi	r30, 0xC0	; 192
     484:	f0 e0       	ldi	r31, 0x00	; 0
     486:	80 81       	ld	r24, Z
     488:	88 23       	and	r24, r24
     48a:	ec f7       	brge	.-6      	; 0x486 <USART_Receive+0x4>
	 /* Get and return received data from buffer */
	 return UDR0;
     48c:	80 91 c6 00 	lds	r24, 0x00C6
}
     490:	08 95       	ret

00000492 <send_string>:

void send_string(char* mydata)		//Function for sending a string
{
     492:	ef 92       	push	r14
     494:	ff 92       	push	r15
     496:	0f 93       	push	r16
     498:	1f 93       	push	r17
     49a:	cf 93       	push	r28
     49c:	df 93       	push	r29
	int i;
	int n = strlen(mydata);
     49e:	e8 2f       	mov	r30, r24
     4a0:	f9 2f       	mov	r31, r25
     4a2:	ef 01       	movw	r28, r30
     4a4:	09 90       	ld	r0, Y+
     4a6:	00 20       	and	r0, r0
     4a8:	e9 f7       	brne	.-6      	; 0x4a4 <send_string+0x12>
     4aa:	21 97       	sbiw	r28, 0x01	; 1
     4ac:	ce 1b       	sub	r28, r30
     4ae:	df 0b       	sbc	r29, r31
	for(i=0;i<n;++i)
     4b0:	1c 16       	cp	r1, r28
     4b2:	1d 06       	cpc	r1, r29
     4b4:	74 f4       	brge	.+28     	; 0x4d2 <send_string+0x40>
     4b6:	e8 2e       	mov	r14, r24
     4b8:	f9 2e       	mov	r15, r25
     4ba:	00 e0       	ldi	r16, 0x00	; 0
     4bc:	10 e0       	ldi	r17, 0x00	; 0
	{
		USART_Transmit(mydata[i]);
     4be:	f7 01       	movw	r30, r14
     4c0:	81 91       	ld	r24, Z+
     4c2:	7f 01       	movw	r14, r30
     4c4:	0e 94 39 02 	call	0x472	; 0x472 <USART_Transmit>

void send_string(char* mydata)		//Function for sending a string
{
	int i;
	int n = strlen(mydata);
	for(i=0;i<n;++i)
     4c8:	0f 5f       	subi	r16, 0xFF	; 255
     4ca:	1f 4f       	sbci	r17, 0xFF	; 255
     4cc:	c0 17       	cp	r28, r16
     4ce:	d1 07       	cpc	r29, r17
     4d0:	b1 f7       	brne	.-20     	; 0x4be <send_string+0x2c>
	{
		USART_Transmit(mydata[i]);
	}
}
     4d2:	df 91       	pop	r29
     4d4:	cf 91       	pop	r28
     4d6:	1f 91       	pop	r17
     4d8:	0f 91       	pop	r16
     4da:	ff 90       	pop	r15
     4dc:	ef 90       	pop	r14
     4de:	08 95       	ret

000004e0 <i2c_init>:
arguments		:	none
return value	:	void
*********************************/
void i2c_init()
{
	TWSR = 0x00;
     4e0:	10 92 b9 00 	sts	0x00B9, r1
	TWCR = 0x00;
     4e4:	ec eb       	ldi	r30, 0xBC	; 188
     4e6:	f0 e0       	ldi	r31, 0x00	; 0
     4e8:	10 82       	st	Z, r1
	TWCR = i2cen | done | eack;		//enables i2c , ack bit and clears TWINT bit
     4ea:	84 ec       	ldi	r24, 0xC4	; 196
     4ec:	80 83       	st	Z, r24
	TWBR = 0X0A;					//400khz speed for TWI in 14745600 hz clock frequency
     4ee:	8a e0       	ldi	r24, 0x0A	; 10
     4f0:	80 93 b8 00 	sts	0x00B8, r24
}
     4f4:	08 95       	ret

000004f6 <i2c_start>:
arguments		:	none
return value	:	void
********************************/
void i2c_start()
{
	TWCR |= start | eack;			//starting transmission ie TWSTA bit is made high
     4f6:	ec eb       	ldi	r30, 0xBC	; 188
     4f8:	f0 e0       	ldi	r31, 0x00	; 0
     4fa:	80 81       	ld	r24, Z
     4fc:	80 66       	ori	r24, 0x60	; 96
     4fe:	80 83       	st	Z, r24
}
     500:	08 95       	ret

00000502 <clear_twint>:
arguments		:	none	
return value	:	void
********************************/
void clear_twint()
{
	TWCR |= done;					//clearing TWINT bit
     502:	ec eb       	ldi	r30, 0xBC	; 188
     504:	f0 e0       	ldi	r31, 0x00	; 0
     506:	80 81       	ld	r24, Z
     508:	80 68       	ori	r24, 0x80	; 128
     50a:	80 83       	st	Z, r24
}
     50c:	08 95       	ret

0000050e <wait>:
arguments		:	none
return value	:	void
*********************************/
void wait()
{
	while(!(TWCR & done));			//waiting for TWINT bit to be high ie to complete transmission
     50e:	ec eb       	ldi	r30, 0xBC	; 188
     510:	f0 e0       	ldi	r31, 0x00	; 0
     512:	80 81       	ld	r24, Z
     514:	88 23       	and	r24, r24
     516:	ec f7       	brge	.-6      	; 0x512 <wait+0x4>
}
     518:	08 95       	ret

0000051a <i2c_stop>:
arguments		:	none
return value	:	void
********************************/
void i2c_stop()
{
	TWCR |= stop;					//TWSTO bit is set high
     51a:	ec eb       	ldi	r30, 0xBC	; 188
     51c:	f0 e0       	ldi	r31, 0x00	; 0
     51e:	80 81       	ld	r24, Z
     520:	80 61       	ori	r24, 0x10	; 16
     522:	80 83       	st	Z, r24
}
     524:	08 95       	ret

00000526 <i2c_getstatus>:
return value	:	UINT8 (returns the status)
********************************/
UINT8 i2c_getstatus()
{
	UINT8 status;
	status = TWSR & 0xF8;			//5 bits of TWSR register gives the status
     526:	80 91 b9 00 	lds	r24, 0x00B9
	return status;
}
     52a:	88 7f       	andi	r24, 0xF8	; 248
     52c:	08 95       	ret

0000052e <i2c_write>:
arguments		:	UINT8 data(the byte which is to be written)
return value	:	void
*********************************/
void i2c_write(UINT8 data)
{
	TWDR = data;					//writing data or add to TWDR register
     52e:	80 93 bb 00 	sts	0x00BB, r24
}
     532:	08 95       	ret

00000534 <i2c_get>:
arguments		:	INT8 *data (points to the byte to which the data needs to be copied)
return value	:	void
*********************************/
void i2c_get(INT8 *data)
{
	*data = TWDR;					//copying data from TWDR register
     534:	20 91 bb 00 	lds	r18, 0x00BB
     538:	fc 01       	movw	r30, r24
     53a:	20 83       	st	Z, r18
}
     53c:	08 95       	ret

0000053e <i2c_sendbyte>:
					UINT8 int_add (address of the internal register of the slave),
					UINT8 data(byte of data which needs to be sent)
return value	:	enum (value which tells if the transmission was succesfull or not)
********************************/
STAT i2c_sendbyte(UINT8 dev_add, UINT8 int_add,UINT8 data)
{
     53e:	1f 93       	push	r17
     540:	cf 93       	push	r28
     542:	df 93       	push	r29
     544:	18 2f       	mov	r17, r24
     546:	c6 2f       	mov	r28, r22
     548:	d4 2f       	mov	r29, r20
	i2c_start();					//starting transmission
     54a:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <i2c_start>
	wait();							//then wait for succesfull transmission
     54e:	0e 94 87 02 	call	0x50e	; 0x50e <wait>
	if(i2c_getstatus() != 0x08)		//check status
     552:	0e 94 93 02 	call	0x526	; 0x526 <i2c_getstatus>
     556:	88 30       	cpi	r24, 0x08	; 8
     558:	51 f5       	brne	.+84     	; 0x5ae <i2c_sendbyte+0x70>
		return START_ERR;

	i2c_write(dev_add | write);		//writing slave + write to TWDR
     55a:	81 2f       	mov	r24, r17
     55c:	0e 94 97 02 	call	0x52e	; 0x52e <i2c_write>
	TWCR &= ~start;
     560:	ec eb       	ldi	r30, 0xBC	; 188
     562:	f0 e0       	ldi	r31, 0x00	; 0
     564:	80 81       	ld	r24, Z
     566:	8f 7d       	andi	r24, 0xDF	; 223
     568:	80 83       	st	Z, r24
	clear_twint();					//clear TWINT bit starts transmission
     56a:	0e 94 81 02 	call	0x502	; 0x502 <clear_twint>
	wait();
     56e:	0e 94 87 02 	call	0x50e	; 0x50e <wait>
	if(i2c_getstatus()!=0x18)
     572:	0e 94 93 02 	call	0x526	; 0x526 <i2c_getstatus>
     576:	88 31       	cpi	r24, 0x18	; 24
     578:	e1 f4       	brne	.+56     	; 0x5b2 <i2c_sendbyte+0x74>
		return SLAVEW_ERR;

	i2c_write(int_add);				//writing int_add to TWDR
     57a:	8c 2f       	mov	r24, r28
     57c:	0e 94 97 02 	call	0x52e	; 0x52e <i2c_write>
	clear_twint();
     580:	0e 94 81 02 	call	0x502	; 0x502 <clear_twint>
	wait();
     584:	0e 94 87 02 	call	0x50e	; 0x50e <wait>
	if(i2c_getstatus()!=0x28)
     588:	0e 94 93 02 	call	0x526	; 0x526 <i2c_getstatus>
     58c:	88 32       	cpi	r24, 0x28	; 40
     58e:	99 f4       	brne	.+38     	; 0x5b6 <i2c_sendbyte+0x78>
	{	return WRITE_ERR;	}

	i2c_write(data);				//writing one byte of data...to write multi byte | with 0x80
     590:	8d 2f       	mov	r24, r29
     592:	0e 94 97 02 	call	0x52e	; 0x52e <i2c_write>
	clear_twint();
     596:	0e 94 81 02 	call	0x502	; 0x502 <clear_twint>
	wait();
     59a:	0e 94 87 02 	call	0x50e	; 0x50e <wait>
	if(i2c_getstatus()!=0x28)
     59e:	0e 94 93 02 	call	0x526	; 0x526 <i2c_getstatus>
     5a2:	88 32       	cpi	r24, 0x28	; 40
     5a4:	51 f4       	brne	.+20     	; 0x5ba <i2c_sendbyte+0x7c>
		return WRITE_ERR;

	i2c_stop();
     5a6:	0e 94 8d 02 	call	0x51a	; 0x51a <i2c_stop>

	return OK;
     5aa:	80 e0       	ldi	r24, 0x00	; 0
     5ac:	07 c0       	rjmp	.+14     	; 0x5bc <i2c_sendbyte+0x7e>
STAT i2c_sendbyte(UINT8 dev_add, UINT8 int_add,UINT8 data)
{
	i2c_start();					//starting transmission
	wait();							//then wait for succesfull transmission
	if(i2c_getstatus() != 0x08)		//check status
		return START_ERR;
     5ae:	88 ef       	ldi	r24, 0xF8	; 248
     5b0:	05 c0       	rjmp	.+10     	; 0x5bc <i2c_sendbyte+0x7e>
	i2c_write(dev_add | write);		//writing slave + write to TWDR
	TWCR &= ~start;
	clear_twint();					//clear TWINT bit starts transmission
	wait();
	if(i2c_getstatus()!=0x18)
		return SLAVEW_ERR;
     5b2:	89 ef       	ldi	r24, 0xF9	; 249
     5b4:	03 c0       	rjmp	.+6      	; 0x5bc <i2c_sendbyte+0x7e>

	i2c_write(int_add);				//writing int_add to TWDR
	clear_twint();
	wait();
	if(i2c_getstatus()!=0x28)
	{	return WRITE_ERR;	}
     5b6:	8b ef       	ldi	r24, 0xFB	; 251
     5b8:	01 c0       	rjmp	.+2      	; 0x5bc <i2c_sendbyte+0x7e>

	i2c_write(data);				//writing one byte of data...to write multi byte | with 0x80
	clear_twint();
	wait();
	if(i2c_getstatus()!=0x28)
		return WRITE_ERR;
     5ba:	8b ef       	ldi	r24, 0xFB	; 251

	i2c_stop();

	return OK;
}
     5bc:	df 91       	pop	r29
     5be:	cf 91       	pop	r28
     5c0:	1f 91       	pop	r17
     5c2:	08 95       	ret

000005c4 <i2c_getbyte>:
					UINT8 int_add (address of the internal register of the slave),
					INT8 *data(points to the byte to which the data needs to be copied)					
return value	:	enum (value which tells if the transmission was succesfull or not)
********************************/
STAT i2c_getbyte(UINT8 dev_add,UINT8 int_add,INT8 *data)
{
     5c4:	0f 93       	push	r16
     5c6:	1f 93       	push	r17
     5c8:	cf 93       	push	r28
     5ca:	df 93       	push	r29
     5cc:	c8 2f       	mov	r28, r24
     5ce:	d6 2f       	mov	r29, r22
     5d0:	8a 01       	movw	r16, r20
	i2c_start();					//starting transmission
     5d2:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <i2c_start>
	wait();							//then wait for succesfull transmission
     5d6:	0e 94 87 02 	call	0x50e	; 0x50e <wait>
	if(i2c_getstatus() != 0x08)		//checking status
     5da:	0e 94 93 02 	call	0x526	; 0x526 <i2c_getstatus>
     5de:	88 30       	cpi	r24, 0x08	; 8
     5e0:	09 f0       	breq	.+2      	; 0x5e4 <i2c_getbyte+0x20>
     5e2:	48 c0       	rjmp	.+144    	; 0x674 <i2c_getbyte+0xb0>
		return START_ERR;

	i2c_write(dev_add | write);		//writing slave + write to TWDR
     5e4:	8c 2f       	mov	r24, r28
     5e6:	0e 94 97 02 	call	0x52e	; 0x52e <i2c_write>
	TWCR &= ~start;
     5ea:	ec eb       	ldi	r30, 0xBC	; 188
     5ec:	f0 e0       	ldi	r31, 0x00	; 0
     5ee:	80 81       	ld	r24, Z
     5f0:	8f 7d       	andi	r24, 0xDF	; 223
     5f2:	80 83       	st	Z, r24
	clear_twint();					//clear TWINT bit and starts transmission
     5f4:	0e 94 81 02 	call	0x502	; 0x502 <clear_twint>
	wait();
     5f8:	0e 94 87 02 	call	0x50e	; 0x50e <wait>
	if(i2c_getstatus()!=0x18)
     5fc:	0e 94 93 02 	call	0x526	; 0x526 <i2c_getstatus>
     600:	88 31       	cpi	r24, 0x18	; 24
     602:	d1 f5       	brne	.+116    	; 0x678 <i2c_getbyte+0xb4>
		return SLAVEW_ERR;	

	i2c_write(int_add);				//writing int_add to TWDR
     604:	8d 2f       	mov	r24, r29
     606:	0e 94 97 02 	call	0x52e	; 0x52e <i2c_write>
	clear_twint();
     60a:	0e 94 81 02 	call	0x502	; 0x502 <clear_twint>
	wait();
     60e:	0e 94 87 02 	call	0x50e	; 0x50e <wait>
	if(i2c_getstatus()!=0x28)
     612:	0e 94 93 02 	call	0x526	; 0x526 <i2c_getstatus>
     616:	88 32       	cpi	r24, 0x28	; 40
     618:	89 f5       	brne	.+98     	; 0x67c <i2c_getbyte+0xb8>
		return WRITE_ERR;

	i2c_start();					//repeated start
     61a:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <i2c_start>
	wait();
     61e:	0e 94 87 02 	call	0x50e	; 0x50e <wait>
	if(i2c_getstatus() != 0x10)
     622:	0e 94 93 02 	call	0x526	; 0x526 <i2c_getstatus>
     626:	80 31       	cpi	r24, 0x10	; 16
     628:	59 f5       	brne	.+86     	; 0x680 <i2c_getbyte+0xbc>
		return REPSTART_ERR;

	i2c_write(dev_add | read);		//writing slave + read to TWDR register
     62a:	8c 2f       	mov	r24, r28
     62c:	81 60       	ori	r24, 0x01	; 1
     62e:	0e 94 97 02 	call	0x52e	; 0x52e <i2c_write>
	TWCR &= ~start;
     632:	ec eb       	ldi	r30, 0xBC	; 188
     634:	f0 e0       	ldi	r31, 0x00	; 0
     636:	80 81       	ld	r24, Z
     638:	8f 7d       	andi	r24, 0xDF	; 223
     63a:	80 83       	st	Z, r24
	clear_twint();
     63c:	0e 94 81 02 	call	0x502	; 0x502 <clear_twint>
	wait();
     640:	0e 94 87 02 	call	0x50e	; 0x50e <wait>
	if(i2c_getstatus()!=0x40)
     644:	0e 94 93 02 	call	0x526	; 0x526 <i2c_getstatus>
     648:	80 34       	cpi	r24, 0x40	; 64
     64a:	e1 f4       	brne	.+56     	; 0x684 <i2c_getbyte+0xc0>
		return SLAVER_ERR;

	TWCR &= ~eack;
     64c:	ec eb       	ldi	r30, 0xBC	; 188
     64e:	f0 e0       	ldi	r31, 0x00	; 0
     650:	80 81       	ld	r24, Z
     652:	8f 7b       	andi	r24, 0xBF	; 191
     654:	80 83       	st	Z, r24
	clear_twint();
     656:	0e 94 81 02 	call	0x502	; 0x502 <clear_twint>
	wait();
     65a:	0e 94 87 02 	call	0x50e	; 0x50e <wait>
	if(i2c_getstatus()!=0x58)
     65e:	0e 94 93 02 	call	0x526	; 0x526 <i2c_getstatus>
     662:	88 35       	cpi	r24, 0x58	; 88
     664:	89 f4       	brne	.+34     	; 0x688 <i2c_getbyte+0xc4>
		return READ_ERR;

	i2c_get(data);					//getting data to the char pointer
     666:	c8 01       	movw	r24, r16
     668:	0e 94 9a 02 	call	0x534	; 0x534 <i2c_get>

	i2c_stop();						//stopping the transmission
     66c:	0e 94 8d 02 	call	0x51a	; 0x51a <i2c_stop>

	return OK;
     670:	80 e0       	ldi	r24, 0x00	; 0
     672:	0b c0       	rjmp	.+22     	; 0x68a <i2c_getbyte+0xc6>
STAT i2c_getbyte(UINT8 dev_add,UINT8 int_add,INT8 *data)
{
	i2c_start();					//starting transmission
	wait();							//then wait for succesfull transmission
	if(i2c_getstatus() != 0x08)		//checking status
		return START_ERR;
     674:	88 ef       	ldi	r24, 0xF8	; 248
     676:	09 c0       	rjmp	.+18     	; 0x68a <i2c_getbyte+0xc6>
	i2c_write(dev_add | write);		//writing slave + write to TWDR
	TWCR &= ~start;
	clear_twint();					//clear TWINT bit and starts transmission
	wait();
	if(i2c_getstatus()!=0x18)
		return SLAVEW_ERR;	
     678:	89 ef       	ldi	r24, 0xF9	; 249
     67a:	07 c0       	rjmp	.+14     	; 0x68a <i2c_getbyte+0xc6>

	i2c_write(int_add);				//writing int_add to TWDR
	clear_twint();
	wait();
	if(i2c_getstatus()!=0x28)
		return WRITE_ERR;
     67c:	8b ef       	ldi	r24, 0xFB	; 251
     67e:	05 c0       	rjmp	.+10     	; 0x68a <i2c_getbyte+0xc6>

	i2c_start();					//repeated start
	wait();
	if(i2c_getstatus() != 0x10)
		return REPSTART_ERR;
     680:	8d ef       	ldi	r24, 0xFD	; 253
     682:	03 c0       	rjmp	.+6      	; 0x68a <i2c_getbyte+0xc6>
	i2c_write(dev_add | read);		//writing slave + read to TWDR register
	TWCR &= ~start;
	clear_twint();
	wait();
	if(i2c_getstatus()!=0x40)
		return SLAVER_ERR;
     684:	8a ef       	ldi	r24, 0xFA	; 250
     686:	01 c0       	rjmp	.+2      	; 0x68a <i2c_getbyte+0xc6>

	TWCR &= ~eack;
	clear_twint();
	wait();
	if(i2c_getstatus()!=0x58)
		return READ_ERR;
     688:	8c ef       	ldi	r24, 0xFC	; 252
	i2c_get(data);					//getting data to the char pointer

	i2c_stop();						//stopping the transmission

	return OK;
}
     68a:	df 91       	pop	r29
     68c:	cf 91       	pop	r28
     68e:	1f 91       	pop	r17
     690:	0f 91       	pop	r16
     692:	08 95       	ret

00000694 <i2c_read_multi_byte>:
					UINT16 n(no of bytes which needs to be read)
					INT8 *data(points to the byte to which the data needs to be copied)	
return value	:	enum (value which tells if the transmission was succesfull or not)
*********************************/
STAT i2c_read_multi_byte(UINT8 dev_add,UINT8 int_add,UINT16 n,INT8 *data)
{
     694:	8f 92       	push	r8
     696:	9f 92       	push	r9
     698:	af 92       	push	r10
     69a:	bf 92       	push	r11
     69c:	cf 92       	push	r12
     69e:	df 92       	push	r13
     6a0:	ef 92       	push	r14
     6a2:	ff 92       	push	r15
     6a4:	0f 93       	push	r16
     6a6:	1f 93       	push	r17
     6a8:	cf 93       	push	r28
     6aa:	df 93       	push	r29
     6ac:	c8 2f       	mov	r28, r24
     6ae:	06 2f       	mov	r16, r22
     6b0:	5a 01       	movw	r10, r20
     6b2:	69 01       	movw	r12, r18
	UINT16 i;
	i2c_start();					//starting transmission
     6b4:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <i2c_start>
	wait();							//then wait for succesfull transmission
     6b8:	0e 94 87 02 	call	0x50e	; 0x50e <wait>
	if(i2c_getstatus() != 0x08)		//check status
     6bc:	0e 94 93 02 	call	0x526	; 0x526 <i2c_getstatus>
     6c0:	88 30       	cpi	r24, 0x08	; 8
     6c2:	09 f0       	breq	.+2      	; 0x6c6 <i2c_read_multi_byte+0x32>
     6c4:	73 c0       	rjmp	.+230    	; 0x7ac <i2c_read_multi_byte+0x118>
		return START_ERR;

	i2c_write(dev_add | write);		//writing slave + write to TWDR
     6c6:	8c 2f       	mov	r24, r28
     6c8:	0e 94 97 02 	call	0x52e	; 0x52e <i2c_write>
	TWCR &=~start;					//to avoid transmitting start bit again
     6cc:	ec eb       	ldi	r30, 0xBC	; 188
     6ce:	f0 e0       	ldi	r31, 0x00	; 0
     6d0:	80 81       	ld	r24, Z
     6d2:	8f 7d       	andi	r24, 0xDF	; 223
     6d4:	80 83       	st	Z, r24
	clear_twint();					//clear TWINT bit and starts transmission
     6d6:	0e 94 81 02 	call	0x502	; 0x502 <clear_twint>
	wait();
     6da:	0e 94 87 02 	call	0x50e	; 0x50e <wait>
	if(i2c_getstatus()!=0x18)
     6de:	0e 94 93 02 	call	0x526	; 0x526 <i2c_getstatus>
     6e2:	88 31       	cpi	r24, 0x18	; 24
     6e4:	09 f0       	breq	.+2      	; 0x6e8 <i2c_read_multi_byte+0x54>
     6e6:	64 c0       	rjmp	.+200    	; 0x7b0 <i2c_read_multi_byte+0x11c>
		return SLAVEW_ERR;

	i2c_write(int_add | 0x80);		//to read multi-byte logical or(|) the register with 0x80
     6e8:	80 2f       	mov	r24, r16
     6ea:	80 68       	ori	r24, 0x80	; 128
     6ec:	0e 94 97 02 	call	0x52e	; 0x52e <i2c_write>
	clear_twint();
     6f0:	0e 94 81 02 	call	0x502	; 0x502 <clear_twint>
	wait();
     6f4:	0e 94 87 02 	call	0x50e	; 0x50e <wait>
	if(i2c_getstatus()!=0x28)
     6f8:	0e 94 93 02 	call	0x526	; 0x526 <i2c_getstatus>
     6fc:	88 32       	cpi	r24, 0x28	; 40
     6fe:	09 f0       	breq	.+2      	; 0x702 <i2c_read_multi_byte+0x6e>
     700:	59 c0       	rjmp	.+178    	; 0x7b4 <i2c_read_multi_byte+0x120>
		return WRITE_ERR;

	i2c_start();					//repeated start
     702:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <i2c_start>
	wait();
     706:	0e 94 87 02 	call	0x50e	; 0x50e <wait>
	if(i2c_getstatus() != 0x10)
     70a:	0e 94 93 02 	call	0x526	; 0x526 <i2c_getstatus>
     70e:	80 31       	cpi	r24, 0x10	; 16
     710:	09 f0       	breq	.+2      	; 0x714 <i2c_read_multi_byte+0x80>
     712:	52 c0       	rjmp	.+164    	; 0x7b8 <i2c_read_multi_byte+0x124>
		return REPSTART_ERR;

	i2c_write(dev_add | read);		//writing slave + read to TWDR register
     714:	8c 2f       	mov	r24, r28
     716:	81 60       	ori	r24, 0x01	; 1
     718:	0e 94 97 02 	call	0x52e	; 0x52e <i2c_write>
	TWCR &= ~start;
     71c:	ec eb       	ldi	r30, 0xBC	; 188
     71e:	f0 e0       	ldi	r31, 0x00	; 0
     720:	80 81       	ld	r24, Z
     722:	8f 7d       	andi	r24, 0xDF	; 223
     724:	80 83       	st	Z, r24
	clear_twint();
     726:	0e 94 81 02 	call	0x502	; 0x502 <clear_twint>
	wait();
     72a:	0e 94 87 02 	call	0x50e	; 0x50e <wait>
	if(i2c_getstatus()!=0x40)
     72e:	0e 94 93 02 	call	0x526	; 0x526 <i2c_getstatus>
     732:	80 34       	cpi	r24, 0x40	; 64
     734:	09 f0       	breq	.+2      	; 0x738 <i2c_read_multi_byte+0xa4>
     736:	42 c0       	rjmp	.+132    	; 0x7bc <i2c_read_multi_byte+0x128>
		return SLAVER_ERR;

	for(i=0;i<n;i++)
     738:	a1 14       	cp	r10, r1
     73a:	b1 04       	cpc	r11, r1
     73c:	99 f1       	breq	.+102    	; 0x7a4 <i2c_read_multi_byte+0x110>
     73e:	c0 e0       	ldi	r28, 0x00	; 0
     740:	d0 e0       	ldi	r29, 0x00	; 0
	{
		if(i==(n-1))				//if last byte send nack
     742:	75 01       	movw	r14, r10
     744:	08 94       	sec
     746:	e1 08       	sbc	r14, r1
     748:	f1 08       	sbc	r15, r1
				return NACK_ERR;	
			i2c_get(&data[i]);		
		}
		else
		{
			TWCR |= eack;			//sending ACK
     74a:	0c eb       	ldi	r16, 0xBC	; 188
     74c:	10 e0       	ldi	r17, 0x00	; 0
			TWCR &= ~eack;			//sending NACK since it is the last bit
			clear_twint();
			wait();
			if(i2c_getstatus()!=0x58)
				return NACK_ERR;	
			i2c_get(&data[i]);		
     74e:	46 01       	movw	r8, r12
     750:	8e 0c       	add	r8, r14
     752:	9f 1c       	adc	r9, r15
	if(i2c_getstatus()!=0x40)
		return SLAVER_ERR;

	for(i=0;i<n;i++)
	{
		if(i==(n-1))				//if last byte send nack
     754:	ec 16       	cp	r14, r28
     756:	fd 06       	cpc	r15, r29
     758:	81 f4       	brne	.+32     	; 0x77a <i2c_read_multi_byte+0xe6>
		{
			TWCR &= ~eack;			//sending NACK since it is the last bit
     75a:	f8 01       	movw	r30, r16
     75c:	80 81       	ld	r24, Z
     75e:	8f 7b       	andi	r24, 0xBF	; 191
     760:	80 83       	st	Z, r24
			clear_twint();
     762:	0e 94 81 02 	call	0x502	; 0x502 <clear_twint>
			wait();
     766:	0e 94 87 02 	call	0x50e	; 0x50e <wait>
			if(i2c_getstatus()!=0x58)
     76a:	0e 94 93 02 	call	0x526	; 0x526 <i2c_getstatus>
     76e:	88 35       	cpi	r24, 0x58	; 88
     770:	39 f5       	brne	.+78     	; 0x7c0 <i2c_read_multi_byte+0x12c>
				return NACK_ERR;	
			i2c_get(&data[i]);		
     772:	c4 01       	movw	r24, r8
     774:	0e 94 9a 02 	call	0x534	; 0x534 <i2c_get>
     778:	11 c0       	rjmp	.+34     	; 0x79c <i2c_read_multi_byte+0x108>
		}
		else
		{
			TWCR |= eack;			//sending ACK
     77a:	f8 01       	movw	r30, r16
     77c:	80 81       	ld	r24, Z
     77e:	80 64       	ori	r24, 0x40	; 64
     780:	80 83       	st	Z, r24
			clear_twint();
     782:	0e 94 81 02 	call	0x502	; 0x502 <clear_twint>
			wait();
     786:	0e 94 87 02 	call	0x50e	; 0x50e <wait>
			if(i2c_getstatus()!=0x50)
     78a:	0e 94 93 02 	call	0x526	; 0x526 <i2c_getstatus>
     78e:	80 35       	cpi	r24, 0x50	; 80
     790:	c9 f4       	brne	.+50     	; 0x7c4 <i2c_read_multi_byte+0x130>
				return ACK_ERR;	

			i2c_get(&data[i]);		//getting required data
     792:	c6 01       	movw	r24, r12
     794:	8c 0f       	add	r24, r28
     796:	9d 1f       	adc	r25, r29
     798:	0e 94 9a 02 	call	0x534	; 0x534 <i2c_get>
	clear_twint();
	wait();
	if(i2c_getstatus()!=0x40)
		return SLAVER_ERR;

	for(i=0;i<n;i++)
     79c:	21 96       	adiw	r28, 0x01	; 1
     79e:	ca 15       	cp	r28, r10
     7a0:	db 05       	cpc	r29, r11
     7a2:	c1 f6       	brne	.-80     	; 0x754 <i2c_read_multi_byte+0xc0>

			i2c_get(&data[i]);		//getting required data
		}
	}

	i2c_stop();						//stopping the transmission
     7a4:	0e 94 8d 02 	call	0x51a	; 0x51a <i2c_stop>

	return OK;	
     7a8:	80 e0       	ldi	r24, 0x00	; 0
     7aa:	0d c0       	rjmp	.+26     	; 0x7c6 <i2c_read_multi_byte+0x132>
{
	UINT16 i;
	i2c_start();					//starting transmission
	wait();							//then wait for succesfull transmission
	if(i2c_getstatus() != 0x08)		//check status
		return START_ERR;
     7ac:	88 ef       	ldi	r24, 0xF8	; 248
     7ae:	0b c0       	rjmp	.+22     	; 0x7c6 <i2c_read_multi_byte+0x132>
	i2c_write(dev_add | write);		//writing slave + write to TWDR
	TWCR &=~start;					//to avoid transmitting start bit again
	clear_twint();					//clear TWINT bit and starts transmission
	wait();
	if(i2c_getstatus()!=0x18)
		return SLAVEW_ERR;
     7b0:	89 ef       	ldi	r24, 0xF9	; 249
     7b2:	09 c0       	rjmp	.+18     	; 0x7c6 <i2c_read_multi_byte+0x132>

	i2c_write(int_add | 0x80);		//to read multi-byte logical or(|) the register with 0x80
	clear_twint();
	wait();
	if(i2c_getstatus()!=0x28)
		return WRITE_ERR;
     7b4:	8b ef       	ldi	r24, 0xFB	; 251
     7b6:	07 c0       	rjmp	.+14     	; 0x7c6 <i2c_read_multi_byte+0x132>

	i2c_start();					//repeated start
	wait();
	if(i2c_getstatus() != 0x10)
		return REPSTART_ERR;
     7b8:	8d ef       	ldi	r24, 0xFD	; 253
     7ba:	05 c0       	rjmp	.+10     	; 0x7c6 <i2c_read_multi_byte+0x132>
	i2c_write(dev_add | read);		//writing slave + read to TWDR register
	TWCR &= ~start;
	clear_twint();
	wait();
	if(i2c_getstatus()!=0x40)
		return SLAVER_ERR;
     7bc:	8a ef       	ldi	r24, 0xFA	; 250
     7be:	03 c0       	rjmp	.+6      	; 0x7c6 <i2c_read_multi_byte+0x132>
		{
			TWCR &= ~eack;			//sending NACK since it is the last bit
			clear_twint();
			wait();
			if(i2c_getstatus()!=0x58)
				return NACK_ERR;	
     7c0:	8f ef       	ldi	r24, 0xFF	; 255
     7c2:	01 c0       	rjmp	.+2      	; 0x7c6 <i2c_read_multi_byte+0x132>
		{
			TWCR |= eack;			//sending ACK
			clear_twint();
			wait();
			if(i2c_getstatus()!=0x50)
				return ACK_ERR;	
     7c4:	8e ef       	ldi	r24, 0xFE	; 254
	}

	i2c_stop();						//stopping the transmission

	return OK;	
}
     7c6:	df 91       	pop	r29
     7c8:	cf 91       	pop	r28
     7ca:	1f 91       	pop	r17
     7cc:	0f 91       	pop	r16
     7ce:	ff 90       	pop	r15
     7d0:	ef 90       	pop	r14
     7d2:	df 90       	pop	r13
     7d4:	cf 90       	pop	r12
     7d6:	bf 90       	pop	r11
     7d8:	af 90       	pop	r10
     7da:	9f 90       	pop	r9
     7dc:	8f 90       	pop	r8
     7de:	08 95       	ret

000007e0 <GYRO_READ>:
		*ACY=acc_y;
		*ACZ=acc_z;
}

void GYRO_READ(int *GCX, int *GCY ,int *GCZ)				//Function to read 3-axis GYROSCOPE readings
{
     7e0:	cf 92       	push	r12
     7e2:	df 92       	push	r13
     7e4:	ef 92       	push	r14
     7e6:	ff 92       	push	r15
     7e8:	0f 93       	push	r16
     7ea:	1f 93       	push	r17
     7ec:	cf 93       	push	r28
     7ee:	df 93       	push	r29
     7f0:	00 d0       	rcall	.+0      	; 0x7f2 <GYRO_READ+0x12>
     7f2:	00 d0       	rcall	.+0      	; 0x7f4 <GYRO_READ+0x14>
     7f4:	cd b7       	in	r28, 0x3d	; 61
     7f6:	de b7       	in	r29, 0x3e	; 62
     7f8:	8c 01       	movw	r16, r24
     7fa:	7b 01       	movw	r14, r22
     7fc:	6a 01       	movw	r12, r20
	UINT8 GYRO_X[2];
	UINT8 GYRO_Y[2];
	UINT8 GYRO_Z[2];
	INT16 gyro_x =0 ,gyro_y=0,gyro_z=0;
	i2c_read_multi_byte(DEV_ID,GYRO_XOUT_H,2,GYRO_X);			//Getting 2 Bytes reading of GYROSCOPE-X
     7fe:	80 ed       	ldi	r24, 0xD0	; 208
     800:	63 e4       	ldi	r22, 0x43	; 67
     802:	42 e0       	ldi	r20, 0x02	; 2
     804:	50 e0       	ldi	r21, 0x00	; 0
     806:	9e 01       	movw	r18, r28
     808:	2f 5f       	subi	r18, 0xFF	; 255
     80a:	3f 4f       	sbci	r19, 0xFF	; 255
     80c:	0e 94 4a 03 	call	0x694	; 0x694 <i2c_read_multi_byte>
	i2c_read_multi_byte(DEV_ID,GYRO_YOUT_H,2,GYRO_Y);			//Getting 2 Bytes reading of GYROSCOPE-Y
     810:	80 ed       	ldi	r24, 0xD0	; 208
     812:	65 e4       	ldi	r22, 0x45	; 69
     814:	42 e0       	ldi	r20, 0x02	; 2
     816:	50 e0       	ldi	r21, 0x00	; 0
     818:	9e 01       	movw	r18, r28
     81a:	2d 5f       	subi	r18, 0xFD	; 253
     81c:	3f 4f       	sbci	r19, 0xFF	; 255
     81e:	0e 94 4a 03 	call	0x694	; 0x694 <i2c_read_multi_byte>
	i2c_read_multi_byte(DEV_ID,GYRO_ZOUT_H,2,GYRO_Z);			//Getting 2 Bytes reading of GYROSCOPE-Z
     822:	80 ed       	ldi	r24, 0xD0	; 208
     824:	67 e4       	ldi	r22, 0x47	; 71
     826:	42 e0       	ldi	r20, 0x02	; 2
     828:	50 e0       	ldi	r21, 0x00	; 0
     82a:	9e 01       	movw	r18, r28
     82c:	2b 5f       	subi	r18, 0xFB	; 251
     82e:	3f 4f       	sbci	r19, 0xFF	; 255
     830:	0e 94 4a 03 	call	0x694	; 0x694 <i2c_read_multi_byte>
	
/**************** Gyroscope readings calculation ****************/
	gyro_x = GYRO_X[0]<<8;
     834:	59 81       	ldd	r21, Y+1	; 0x01
     836:	40 e0       	ldi	r20, 0x00	; 0
	gyro_x = gyro_x | GYRO_X[1];
	gyro_y = GYRO_Y[0]<<8;
     838:	3b 81       	ldd	r19, Y+3	; 0x03
     83a:	20 e0       	ldi	r18, 0x00	; 0
	gyro_y = gyro_y | GYRO_Y[1];
     83c:	8c 81       	ldd	r24, Y+4	; 0x04
     83e:	90 e0       	ldi	r25, 0x00	; 0
     840:	b9 01       	movw	r22, r18
     842:	68 2b       	or	r22, r24
     844:	79 2b       	or	r23, r25
	gyro_z =GYRO_Z[0]<<8;
     846:	3d 81       	ldd	r19, Y+5	; 0x05
     848:	20 e0       	ldi	r18, 0x00	; 0
	gyro_z = gyro_z | GYRO_Z[1];
     84a:	8e 81       	ldd	r24, Y+6	; 0x06
     84c:	90 e0       	ldi	r25, 0x00	; 0
     84e:	28 2b       	or	r18, r24
     850:	39 2b       	or	r19, r25
	i2c_read_multi_byte(DEV_ID,GYRO_YOUT_H,2,GYRO_Y);			//Getting 2 Bytes reading of GYROSCOPE-Y
	i2c_read_multi_byte(DEV_ID,GYRO_ZOUT_H,2,GYRO_Z);			//Getting 2 Bytes reading of GYROSCOPE-Z
	
/**************** Gyroscope readings calculation ****************/
	gyro_x = GYRO_X[0]<<8;
	gyro_x = gyro_x | GYRO_X[1];
     852:	8a 81       	ldd	r24, Y+2	; 0x02
     854:	90 e0       	ldi	r25, 0x00	; 0
     856:	84 2b       	or	r24, r20
     858:	95 2b       	or	r25, r21
	gyro_y = GYRO_Y[0]<<8;
	gyro_y = gyro_y | GYRO_Y[1];
	gyro_z =GYRO_Z[0]<<8;
	gyro_z = gyro_z | GYRO_Z[1];
	
	*GCX =gyro_x;
     85a:	f8 01       	movw	r30, r16
     85c:	91 83       	std	Z+1, r25	; 0x01
     85e:	80 83       	st	Z, r24
	*GCY =gyro_y;
     860:	f7 01       	movw	r30, r14
     862:	71 83       	std	Z+1, r23	; 0x01
     864:	60 83       	st	Z, r22
	*GCZ =gyro_z;
     866:	f6 01       	movw	r30, r12
     868:	31 83       	std	Z+1, r19	; 0x01
     86a:	20 83       	st	Z, r18
}
     86c:	26 96       	adiw	r28, 0x06	; 6
     86e:	0f b6       	in	r0, 0x3f	; 63
     870:	f8 94       	cli
     872:	de bf       	out	0x3e, r29	; 62
     874:	0f be       	out	0x3f, r0	; 63
     876:	cd bf       	out	0x3d, r28	; 61
     878:	df 91       	pop	r29
     87a:	cf 91       	pop	r28
     87c:	1f 91       	pop	r17
     87e:	0f 91       	pop	r16
     880:	ff 90       	pop	r15
     882:	ef 90       	pop	r14
     884:	df 90       	pop	r13
     886:	cf 90       	pop	r12
     888:	08 95       	ret

0000088a <ACC_READ>:
	ACC_YOUT_OFFSET/=1000;
	ACC_ZOUT_OFFSET/=1000;
}

void ACC_READ(int *ACX ,int *ACY,int *ACZ)				//Function to read 3-axis ACCELEROMETER readings
{
     88a:	cf 92       	push	r12
     88c:	df 92       	push	r13
     88e:	ef 92       	push	r14
     890:	ff 92       	push	r15
     892:	0f 93       	push	r16
     894:	1f 93       	push	r17
     896:	cf 93       	push	r28
     898:	df 93       	push	r29
     89a:	00 d0       	rcall	.+0      	; 0x89c <ACC_READ+0x12>
     89c:	00 d0       	rcall	.+0      	; 0x89e <ACC_READ+0x14>
     89e:	cd b7       	in	r28, 0x3d	; 61
     8a0:	de b7       	in	r29, 0x3e	; 62
     8a2:	8c 01       	movw	r16, r24
     8a4:	7b 01       	movw	r14, r22
     8a6:	6a 01       	movw	r12, r20
	UINT8 ACC_X[2];
	UINT8 ACC_Y[2];
	UINT8 ACC_Z[2];
	INT16 acc_x =0 ,acc_y=0,acc_z=0;
	i2c_read_multi_byte(DEV_ID,ACCEL_XOUT_H,2,ACC_X);			//Getting 2 Bytes reading of ACCELEROMETER-X
     8a8:	80 ed       	ldi	r24, 0xD0	; 208
     8aa:	6b e3       	ldi	r22, 0x3B	; 59
     8ac:	42 e0       	ldi	r20, 0x02	; 2
     8ae:	50 e0       	ldi	r21, 0x00	; 0
     8b0:	9e 01       	movw	r18, r28
     8b2:	2f 5f       	subi	r18, 0xFF	; 255
     8b4:	3f 4f       	sbci	r19, 0xFF	; 255
     8b6:	0e 94 4a 03 	call	0x694	; 0x694 <i2c_read_multi_byte>
	i2c_read_multi_byte(DEV_ID,ACCEL_YOUT_H,2,ACC_Y);			//Getting 2 Bytes reading of ACCELEROMETER-Y
     8ba:	80 ed       	ldi	r24, 0xD0	; 208
     8bc:	6d e3       	ldi	r22, 0x3D	; 61
     8be:	42 e0       	ldi	r20, 0x02	; 2
     8c0:	50 e0       	ldi	r21, 0x00	; 0
     8c2:	9e 01       	movw	r18, r28
     8c4:	2d 5f       	subi	r18, 0xFD	; 253
     8c6:	3f 4f       	sbci	r19, 0xFF	; 255
     8c8:	0e 94 4a 03 	call	0x694	; 0x694 <i2c_read_multi_byte>
	i2c_read_multi_byte(DEV_ID,ACCEL_ZOUT_H,2,ACC_Z);			//Getting 2 Bytes reading of ACCELEROMETER-Z
     8cc:	80 ed       	ldi	r24, 0xD0	; 208
     8ce:	6f e3       	ldi	r22, 0x3F	; 63
     8d0:	42 e0       	ldi	r20, 0x02	; 2
     8d2:	50 e0       	ldi	r21, 0x00	; 0
     8d4:	9e 01       	movw	r18, r28
     8d6:	2b 5f       	subi	r18, 0xFB	; 251
     8d8:	3f 4f       	sbci	r19, 0xFF	; 255
     8da:	0e 94 4a 03 	call	0x694	; 0x694 <i2c_read_multi_byte>
	
/************** Accerometer readings calculations ************/
		acc_x = ACC_X[0]<<8;
     8de:	59 81       	ldd	r21, Y+1	; 0x01
     8e0:	40 e0       	ldi	r20, 0x00	; 0
		acc_x = acc_x | ACC_X[1];
		acc_y = ACC_Y[0]<<8;
     8e2:	3b 81       	ldd	r19, Y+3	; 0x03
     8e4:	20 e0       	ldi	r18, 0x00	; 0
		acc_y = acc_y | ACC_Y[1];
     8e6:	8c 81       	ldd	r24, Y+4	; 0x04
     8e8:	90 e0       	ldi	r25, 0x00	; 0
     8ea:	b9 01       	movw	r22, r18
     8ec:	68 2b       	or	r22, r24
     8ee:	79 2b       	or	r23, r25
		acc_z = ACC_Z[0]<<8;
     8f0:	3d 81       	ldd	r19, Y+5	; 0x05
     8f2:	20 e0       	ldi	r18, 0x00	; 0
		acc_z = acc_z | ACC_Z[1];
     8f4:	8e 81       	ldd	r24, Y+6	; 0x06
     8f6:	90 e0       	ldi	r25, 0x00	; 0
     8f8:	28 2b       	or	r18, r24
     8fa:	39 2b       	or	r19, r25
	i2c_read_multi_byte(DEV_ID,ACCEL_YOUT_H,2,ACC_Y);			//Getting 2 Bytes reading of ACCELEROMETER-Y
	i2c_read_multi_byte(DEV_ID,ACCEL_ZOUT_H,2,ACC_Z);			//Getting 2 Bytes reading of ACCELEROMETER-Z
	
/************** Accerometer readings calculations ************/
		acc_x = ACC_X[0]<<8;
		acc_x = acc_x | ACC_X[1];
     8fc:	8a 81       	ldd	r24, Y+2	; 0x02
     8fe:	90 e0       	ldi	r25, 0x00	; 0
     900:	84 2b       	or	r24, r20
     902:	95 2b       	or	r25, r21
		acc_y = ACC_Y[0]<<8;
		acc_y = acc_y | ACC_Y[1];
		acc_z = ACC_Z[0]<<8;
		acc_z = acc_z | ACC_Z[1];
		*ACX=acc_x;
     904:	f8 01       	movw	r30, r16
     906:	91 83       	std	Z+1, r25	; 0x01
     908:	80 83       	st	Z, r24
		*ACY=acc_y;
     90a:	f7 01       	movw	r30, r14
     90c:	71 83       	std	Z+1, r23	; 0x01
     90e:	60 83       	st	Z, r22
		*ACZ=acc_z;
     910:	f6 01       	movw	r30, r12
     912:	31 83       	std	Z+1, r19	; 0x01
     914:	20 83       	st	Z, r18
}
     916:	26 96       	adiw	r28, 0x06	; 6
     918:	0f b6       	in	r0, 0x3f	; 63
     91a:	f8 94       	cli
     91c:	de bf       	out	0x3e, r29	; 62
     91e:	0f be       	out	0x3f, r0	; 63
     920:	cd bf       	out	0x3d, r28	; 61
     922:	df 91       	pop	r29
     924:	cf 91       	pop	r28
     926:	1f 91       	pop	r17
     928:	0f 91       	pop	r16
     92a:	ff 90       	pop	r15
     92c:	ef 90       	pop	r14
     92e:	df 90       	pop	r13
     930:	cf 90       	pop	r12
     932:	08 95       	ret

00000934 <MPU6050_init>:
#include "i2c_lib.c"
float GYRO_XOUT_OFFSET=0,GYRO_YOUT_OFFSET=0,GYRO_ZOUT_OFFSET=0;
float ACC_XOUT_OFFSET=0,ACC_YOUT_OFFSET=0,ACC_ZOUT_OFFSET=0;

void MPU6050_init()
{
     934:	0f 93       	push	r16
     936:	1f 93       	push	r17
     938:	cf 93       	push	r28
     93a:	df 93       	push	r29
     93c:	cd b7       	in	r28, 0x3d	; 61
     93e:	de b7       	in	r29, 0x3e	; 62
     940:	2c 97       	sbiw	r28, 0x0c	; 12
     942:	0f b6       	in	r0, 0x3f	; 63
     944:	f8 94       	cli
     946:	de bf       	out	0x3e, r29	; 62
     948:	0f be       	out	0x3f, r0	; 63
     94a:	cd bf       	out	0x3d, r28	; 61
	i2c_init();
     94c:	0e 94 70 02 	call	0x4e0	; 0x4e0 <i2c_init>
	i2c_sendbyte(DEV_ID,0x6B,0x00);								//Setting MPU6050 out of sleep mode
     950:	80 ed       	ldi	r24, 0xD0	; 208
     952:	6b e6       	ldi	r22, 0x6B	; 107
     954:	40 e0       	ldi	r20, 0x00	; 0
     956:	0e 94 9f 02 	call	0x53e	; 0x53e <i2c_sendbyte>
     95a:	8f ef       	ldi	r24, 0xFF	; 255
     95c:	9f e7       	ldi	r25, 0x7F	; 127
     95e:	a4 e0       	ldi	r26, 0x04	; 4
     960:	81 50       	subi	r24, 0x01	; 1
     962:	90 40       	sbci	r25, 0x00	; 0
     964:	a0 40       	sbci	r26, 0x00	; 0
     966:	e1 f7       	brne	.-8      	; 0x960 <MPU6050_init+0x2c>
     968:	00 c0       	rjmp	.+0      	; 0x96a <MPU6050_init+0x36>
     96a:	00 00       	nop
     96c:	08 ee       	ldi	r16, 0xE8	; 232
     96e:	13 e0       	ldi	r17, 0x03	; 3
	int GYX,GYY,GYZ;
	int ACX,ACY,ACZ;
//calculating gyroscope offset
	for(int i=0;i<1000;i++)
	{
		GYRO_READ(&GYX,&GYY,&GYZ);
     970:	ce 01       	movw	r24, r28
     972:	01 96       	adiw	r24, 0x01	; 1
     974:	be 01       	movw	r22, r28
     976:	6d 5f       	subi	r22, 0xFD	; 253
     978:	7f 4f       	sbci	r23, 0xFF	; 255
     97a:	ae 01       	movw	r20, r28
     97c:	4b 5f       	subi	r20, 0xFB	; 251
     97e:	5f 4f       	sbci	r21, 0xFF	; 255
     980:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <GYRO_READ>
		GYRO_XOUT_OFFSET+=GYX;
     984:	69 81       	ldd	r22, Y+1	; 0x01
     986:	7a 81       	ldd	r23, Y+2	; 0x02
     988:	88 27       	eor	r24, r24
     98a:	77 fd       	sbrc	r23, 7
     98c:	80 95       	com	r24
     98e:	98 2f       	mov	r25, r24
     990:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <__floatsisf>
     994:	9b 01       	movw	r18, r22
     996:	ac 01       	movw	r20, r24
     998:	60 91 64 02 	lds	r22, 0x0264
     99c:	70 91 65 02 	lds	r23, 0x0265
     9a0:	80 91 66 02 	lds	r24, 0x0266
     9a4:	90 91 67 02 	lds	r25, 0x0267
     9a8:	0e 94 56 0e 	call	0x1cac	; 0x1cac <__addsf3>
     9ac:	dc 01       	movw	r26, r24
     9ae:	cb 01       	movw	r24, r22
     9b0:	80 93 64 02 	sts	0x0264, r24
     9b4:	90 93 65 02 	sts	0x0265, r25
     9b8:	a0 93 66 02 	sts	0x0266, r26
     9bc:	b0 93 67 02 	sts	0x0267, r27
		GYRO_YOUT_OFFSET+=GYY;
     9c0:	6b 81       	ldd	r22, Y+3	; 0x03
     9c2:	7c 81       	ldd	r23, Y+4	; 0x04
     9c4:	88 27       	eor	r24, r24
     9c6:	77 fd       	sbrc	r23, 7
     9c8:	80 95       	com	r24
     9ca:	98 2f       	mov	r25, r24
     9cc:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <__floatsisf>
     9d0:	9b 01       	movw	r18, r22
     9d2:	ac 01       	movw	r20, r24
     9d4:	60 91 60 02 	lds	r22, 0x0260
     9d8:	70 91 61 02 	lds	r23, 0x0261
     9dc:	80 91 62 02 	lds	r24, 0x0262
     9e0:	90 91 63 02 	lds	r25, 0x0263
     9e4:	0e 94 56 0e 	call	0x1cac	; 0x1cac <__addsf3>
     9e8:	dc 01       	movw	r26, r24
     9ea:	cb 01       	movw	r24, r22
     9ec:	80 93 60 02 	sts	0x0260, r24
     9f0:	90 93 61 02 	sts	0x0261, r25
     9f4:	a0 93 62 02 	sts	0x0262, r26
     9f8:	b0 93 63 02 	sts	0x0263, r27
		GYRO_ZOUT_OFFSET+=GYZ;
     9fc:	6d 81       	ldd	r22, Y+5	; 0x05
     9fe:	7e 81       	ldd	r23, Y+6	; 0x06
     a00:	88 27       	eor	r24, r24
     a02:	77 fd       	sbrc	r23, 7
     a04:	80 95       	com	r24
     a06:	98 2f       	mov	r25, r24
     a08:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <__floatsisf>
     a0c:	9b 01       	movw	r18, r22
     a0e:	ac 01       	movw	r20, r24
     a10:	60 91 5c 02 	lds	r22, 0x025C
     a14:	70 91 5d 02 	lds	r23, 0x025D
     a18:	80 91 5e 02 	lds	r24, 0x025E
     a1c:	90 91 5f 02 	lds	r25, 0x025F
     a20:	0e 94 56 0e 	call	0x1cac	; 0x1cac <__addsf3>
     a24:	dc 01       	movw	r26, r24
     a26:	cb 01       	movw	r24, r22
     a28:	80 93 5c 02 	sts	0x025C, r24
     a2c:	90 93 5d 02 	sts	0x025D, r25
     a30:	a0 93 5e 02 	sts	0x025E, r26
     a34:	b0 93 5f 02 	sts	0x025F, r27
     a38:	01 50       	subi	r16, 0x01	; 1
     a3a:	10 40       	sbci	r17, 0x00	; 0
	_delay_ms(100);
	
	int GYX,GYY,GYZ;
	int ACX,ACY,ACZ;
//calculating gyroscope offset
	for(int i=0;i<1000;i++)
     a3c:	09 f0       	breq	.+2      	; 0xa40 <MPU6050_init+0x10c>
     a3e:	98 cf       	rjmp	.-208    	; 0x970 <MPU6050_init+0x3c>
		GYRO_READ(&GYX,&GYY,&GYZ);
		GYRO_XOUT_OFFSET+=GYX;
		GYRO_YOUT_OFFSET+=GYY;
		GYRO_ZOUT_OFFSET+=GYZ;
	}
	GYRO_XOUT_OFFSET/=1000;
     a40:	60 91 64 02 	lds	r22, 0x0264
     a44:	70 91 65 02 	lds	r23, 0x0265
     a48:	80 91 66 02 	lds	r24, 0x0266
     a4c:	90 91 67 02 	lds	r25, 0x0267
     a50:	20 e0       	ldi	r18, 0x00	; 0
     a52:	30 e0       	ldi	r19, 0x00	; 0
     a54:	4a e7       	ldi	r20, 0x7A	; 122
     a56:	54 e4       	ldi	r21, 0x44	; 68
     a58:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <__divsf3>
     a5c:	dc 01       	movw	r26, r24
     a5e:	cb 01       	movw	r24, r22
     a60:	80 93 64 02 	sts	0x0264, r24
     a64:	90 93 65 02 	sts	0x0265, r25
     a68:	a0 93 66 02 	sts	0x0266, r26
     a6c:	b0 93 67 02 	sts	0x0267, r27
	GYRO_YOUT_OFFSET/=1000;
     a70:	60 91 60 02 	lds	r22, 0x0260
     a74:	70 91 61 02 	lds	r23, 0x0261
     a78:	80 91 62 02 	lds	r24, 0x0262
     a7c:	90 91 63 02 	lds	r25, 0x0263
     a80:	20 e0       	ldi	r18, 0x00	; 0
     a82:	30 e0       	ldi	r19, 0x00	; 0
     a84:	4a e7       	ldi	r20, 0x7A	; 122
     a86:	54 e4       	ldi	r21, 0x44	; 68
     a88:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <__divsf3>
     a8c:	dc 01       	movw	r26, r24
     a8e:	cb 01       	movw	r24, r22
     a90:	80 93 60 02 	sts	0x0260, r24
     a94:	90 93 61 02 	sts	0x0261, r25
     a98:	a0 93 62 02 	sts	0x0262, r26
     a9c:	b0 93 63 02 	sts	0x0263, r27
	GYRO_ZOUT_OFFSET/=1000;
     aa0:	60 91 5c 02 	lds	r22, 0x025C
     aa4:	70 91 5d 02 	lds	r23, 0x025D
     aa8:	80 91 5e 02 	lds	r24, 0x025E
     aac:	90 91 5f 02 	lds	r25, 0x025F
     ab0:	20 e0       	ldi	r18, 0x00	; 0
     ab2:	30 e0       	ldi	r19, 0x00	; 0
     ab4:	4a e7       	ldi	r20, 0x7A	; 122
     ab6:	54 e4       	ldi	r21, 0x44	; 68
     ab8:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <__divsf3>
     abc:	dc 01       	movw	r26, r24
     abe:	cb 01       	movw	r24, r22
     ac0:	80 93 5c 02 	sts	0x025C, r24
     ac4:	90 93 5d 02 	sts	0x025D, r25
     ac8:	a0 93 5e 02 	sts	0x025E, r26
     acc:	b0 93 5f 02 	sts	0x025F, r27
     ad0:	08 ee       	ldi	r16, 0xE8	; 232
     ad2:	13 e0       	ldi	r17, 0x03	; 3
	
//calculating accelerometer offset
	for(int i=0;i<1000;i++)
	{
		ACC_READ(&ACX,&ACY,&ACZ);
     ad4:	ce 01       	movw	r24, r28
     ad6:	07 96       	adiw	r24, 0x07	; 7
     ad8:	be 01       	movw	r22, r28
     ada:	67 5f       	subi	r22, 0xF7	; 247
     adc:	7f 4f       	sbci	r23, 0xFF	; 255
     ade:	ae 01       	movw	r20, r28
     ae0:	45 5f       	subi	r20, 0xF5	; 245
     ae2:	5f 4f       	sbci	r21, 0xFF	; 255
     ae4:	0e 94 45 04 	call	0x88a	; 0x88a <ACC_READ>
		ACC_XOUT_OFFSET+=ACX;
     ae8:	6f 81       	ldd	r22, Y+7	; 0x07
     aea:	78 85       	ldd	r23, Y+8	; 0x08
     aec:	88 27       	eor	r24, r24
     aee:	77 fd       	sbrc	r23, 7
     af0:	80 95       	com	r24
     af2:	98 2f       	mov	r25, r24
     af4:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <__floatsisf>
     af8:	9b 01       	movw	r18, r22
     afa:	ac 01       	movw	r20, r24
     afc:	60 91 58 02 	lds	r22, 0x0258
     b00:	70 91 59 02 	lds	r23, 0x0259
     b04:	80 91 5a 02 	lds	r24, 0x025A
     b08:	90 91 5b 02 	lds	r25, 0x025B
     b0c:	0e 94 56 0e 	call	0x1cac	; 0x1cac <__addsf3>
     b10:	dc 01       	movw	r26, r24
     b12:	cb 01       	movw	r24, r22
     b14:	80 93 58 02 	sts	0x0258, r24
     b18:	90 93 59 02 	sts	0x0259, r25
     b1c:	a0 93 5a 02 	sts	0x025A, r26
     b20:	b0 93 5b 02 	sts	0x025B, r27
		ACC_YOUT_OFFSET+=ACY;
     b24:	69 85       	ldd	r22, Y+9	; 0x09
     b26:	7a 85       	ldd	r23, Y+10	; 0x0a
     b28:	88 27       	eor	r24, r24
     b2a:	77 fd       	sbrc	r23, 7
     b2c:	80 95       	com	r24
     b2e:	98 2f       	mov	r25, r24
     b30:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <__floatsisf>
     b34:	9b 01       	movw	r18, r22
     b36:	ac 01       	movw	r20, r24
     b38:	60 91 54 02 	lds	r22, 0x0254
     b3c:	70 91 55 02 	lds	r23, 0x0255
     b40:	80 91 56 02 	lds	r24, 0x0256
     b44:	90 91 57 02 	lds	r25, 0x0257
     b48:	0e 94 56 0e 	call	0x1cac	; 0x1cac <__addsf3>
     b4c:	dc 01       	movw	r26, r24
     b4e:	cb 01       	movw	r24, r22
     b50:	80 93 54 02 	sts	0x0254, r24
     b54:	90 93 55 02 	sts	0x0255, r25
     b58:	a0 93 56 02 	sts	0x0256, r26
     b5c:	b0 93 57 02 	sts	0x0257, r27
		ACC_ZOUT_OFFSET+=ACZ;
     b60:	6b 85       	ldd	r22, Y+11	; 0x0b
     b62:	7c 85       	ldd	r23, Y+12	; 0x0c
     b64:	88 27       	eor	r24, r24
     b66:	77 fd       	sbrc	r23, 7
     b68:	80 95       	com	r24
     b6a:	98 2f       	mov	r25, r24
     b6c:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <__floatsisf>
     b70:	9b 01       	movw	r18, r22
     b72:	ac 01       	movw	r20, r24
     b74:	60 91 50 02 	lds	r22, 0x0250
     b78:	70 91 51 02 	lds	r23, 0x0251
     b7c:	80 91 52 02 	lds	r24, 0x0252
     b80:	90 91 53 02 	lds	r25, 0x0253
     b84:	0e 94 56 0e 	call	0x1cac	; 0x1cac <__addsf3>
     b88:	dc 01       	movw	r26, r24
     b8a:	cb 01       	movw	r24, r22
     b8c:	80 93 50 02 	sts	0x0250, r24
     b90:	90 93 51 02 	sts	0x0251, r25
     b94:	a0 93 52 02 	sts	0x0252, r26
     b98:	b0 93 53 02 	sts	0x0253, r27
     b9c:	01 50       	subi	r16, 0x01	; 1
     b9e:	10 40       	sbci	r17, 0x00	; 0
	GYRO_XOUT_OFFSET/=1000;
	GYRO_YOUT_OFFSET/=1000;
	GYRO_ZOUT_OFFSET/=1000;
	
//calculating accelerometer offset
	for(int i=0;i<1000;i++)
     ba0:	09 f0       	breq	.+2      	; 0xba4 <MPU6050_init+0x270>
     ba2:	98 cf       	rjmp	.-208    	; 0xad4 <MPU6050_init+0x1a0>
		ACC_READ(&ACX,&ACY,&ACZ);
		ACC_XOUT_OFFSET+=ACX;
		ACC_YOUT_OFFSET+=ACY;
		ACC_ZOUT_OFFSET+=ACZ;
	}
	ACC_XOUT_OFFSET/=1000;
     ba4:	60 91 58 02 	lds	r22, 0x0258
     ba8:	70 91 59 02 	lds	r23, 0x0259
     bac:	80 91 5a 02 	lds	r24, 0x025A
     bb0:	90 91 5b 02 	lds	r25, 0x025B
     bb4:	20 e0       	ldi	r18, 0x00	; 0
     bb6:	30 e0       	ldi	r19, 0x00	; 0
     bb8:	4a e7       	ldi	r20, 0x7A	; 122
     bba:	54 e4       	ldi	r21, 0x44	; 68
     bbc:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <__divsf3>
     bc0:	dc 01       	movw	r26, r24
     bc2:	cb 01       	movw	r24, r22
     bc4:	80 93 58 02 	sts	0x0258, r24
     bc8:	90 93 59 02 	sts	0x0259, r25
     bcc:	a0 93 5a 02 	sts	0x025A, r26
     bd0:	b0 93 5b 02 	sts	0x025B, r27
	ACC_YOUT_OFFSET/=1000;
     bd4:	60 91 54 02 	lds	r22, 0x0254
     bd8:	70 91 55 02 	lds	r23, 0x0255
     bdc:	80 91 56 02 	lds	r24, 0x0256
     be0:	90 91 57 02 	lds	r25, 0x0257
     be4:	20 e0       	ldi	r18, 0x00	; 0
     be6:	30 e0       	ldi	r19, 0x00	; 0
     be8:	4a e7       	ldi	r20, 0x7A	; 122
     bea:	54 e4       	ldi	r21, 0x44	; 68
     bec:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <__divsf3>
     bf0:	dc 01       	movw	r26, r24
     bf2:	cb 01       	movw	r24, r22
     bf4:	80 93 54 02 	sts	0x0254, r24
     bf8:	90 93 55 02 	sts	0x0255, r25
     bfc:	a0 93 56 02 	sts	0x0256, r26
     c00:	b0 93 57 02 	sts	0x0257, r27
	ACC_ZOUT_OFFSET/=1000;
     c04:	60 91 50 02 	lds	r22, 0x0250
     c08:	70 91 51 02 	lds	r23, 0x0251
     c0c:	80 91 52 02 	lds	r24, 0x0252
     c10:	90 91 53 02 	lds	r25, 0x0253
     c14:	20 e0       	ldi	r18, 0x00	; 0
     c16:	30 e0       	ldi	r19, 0x00	; 0
     c18:	4a e7       	ldi	r20, 0x7A	; 122
     c1a:	54 e4       	ldi	r21, 0x44	; 68
     c1c:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <__divsf3>
     c20:	dc 01       	movw	r26, r24
     c22:	cb 01       	movw	r24, r22
     c24:	80 93 50 02 	sts	0x0250, r24
     c28:	90 93 51 02 	sts	0x0251, r25
     c2c:	a0 93 52 02 	sts	0x0252, r26
     c30:	b0 93 53 02 	sts	0x0253, r27
}
     c34:	2c 96       	adiw	r28, 0x0c	; 12
     c36:	0f b6       	in	r0, 0x3f	; 63
     c38:	f8 94       	cli
     c3a:	de bf       	out	0x3e, r29	; 62
     c3c:	0f be       	out	0x3f, r0	; 63
     c3e:	cd bf       	out	0x3d, r28	; 61
     c40:	df 91       	pop	r29
     c42:	cf 91       	pop	r28
     c44:	1f 91       	pop	r17
     c46:	0f 91       	pop	r16
     c48:	08 95       	ret

00000c4a <millis_init>:

volatile uint64_t millis_prv = 0;

void millis_init()
{
	TCCR0A = 0;
     c4a:	14 bc       	out	0x24, r1	; 36
	// set timer0 with CLKio/8 prescaler
	TCCR0B = _BV(CS01) | _BV(CS00);
     c4c:	83 e0       	ldi	r24, 0x03	; 3
     c4e:	85 bd       	out	0x25, r24	; 37
	// clear any TOV1 Flag set when the timer overflowed
	TIFR0 &= ~TOV0;
     c50:	85 b3       	in	r24, 0x15	; 21
     c52:	85 bb       	out	0x15, r24	; 21
	// set timer0 counter initial value to 0
	TCNT0 = 0x0;
     c54:	16 bc       	out	0x26, r1	; 38
	// enable timer overflow interrupt for Timer0
	TIMSK0 = _BV(TOIE0);
     c56:	81 e0       	ldi	r24, 0x01	; 1
     c58:	80 93 6e 00 	sts	0x006E, r24
	// clear the Power Reduction Timer/Counter0
	PRR0 &= ~PRTIM0;
     c5c:	e4 e6       	ldi	r30, 0x64	; 100
     c5e:	f0 e0       	ldi	r31, 0x00	; 0
     c60:	80 81       	ld	r24, Z
     c62:	8a 7f       	andi	r24, 0xFA	; 250
     c64:	80 83       	st	Z, r24
}
     c66:	08 95       	ret

00000c68 <__vector_23>:

// TIMER0 interrupt handler
ISR(TIMER0_OVF_vect)
{
     c68:	1f 92       	push	r1
     c6a:	0f 92       	push	r0
     c6c:	0f b6       	in	r0, 0x3f	; 63
     c6e:	0f 92       	push	r0
     c70:	0b b6       	in	r0, 0x3b	; 59
     c72:	0f 92       	push	r0
     c74:	11 24       	eor	r1, r1
     c76:	2f 93       	push	r18
     c78:	3f 93       	push	r19
     c7a:	4f 93       	push	r20
     c7c:	5f 93       	push	r21
     c7e:	6f 93       	push	r22
     c80:	7f 93       	push	r23
     c82:	8f 93       	push	r24
     c84:	9f 93       	push	r25
     c86:	af 93       	push	r26
     c88:	ef 93       	push	r30
     c8a:	ff 93       	push	r31
	// reset the counter (overflow is cleared automatically)
	TCNT0 = (uint8_t)(0xFF - ((F_CPU/8)/1000)); // use CLKio/8 pre-scaler (set CS0n accordingly above)
     c8c:	8c ec       	ldi	r24, 0xCC	; 204
     c8e:	86 bd       	out	0x26, r24	; 38
	millis_prv++;
     c90:	50 91 48 02 	lds	r21, 0x0248
     c94:	40 91 49 02 	lds	r20, 0x0249
     c98:	30 91 4a 02 	lds	r19, 0x024A
     c9c:	20 91 4b 02 	lds	r18, 0x024B
     ca0:	90 91 4c 02 	lds	r25, 0x024C
     ca4:	f0 91 4d 02 	lds	r31, 0x024D
     ca8:	e0 91 4e 02 	lds	r30, 0x024E
     cac:	a0 91 4f 02 	lds	r26, 0x024F
     cb0:	75 2f       	mov	r23, r21
     cb2:	7f 5f       	subi	r23, 0xFF	; 255
     cb4:	61 e0       	ldi	r22, 0x01	; 1
     cb6:	75 17       	cp	r23, r21
     cb8:	08 f0       	brcs	.+2      	; 0xcbc <__vector_23+0x54>
     cba:	60 e0       	ldi	r22, 0x00	; 0
     cbc:	84 2f       	mov	r24, r20
     cbe:	50 e0       	ldi	r21, 0x00	; 0
     cc0:	64 0f       	add	r22, r20
     cc2:	41 e0       	ldi	r20, 0x01	; 1
     cc4:	68 17       	cp	r22, r24
     cc6:	08 f0       	brcs	.+2      	; 0xcca <__vector_23+0x62>
     cc8:	40 e0       	ldi	r20, 0x00	; 0
     cca:	54 2b       	or	r21, r20
     ccc:	83 2f       	mov	r24, r19
     cce:	40 e0       	ldi	r20, 0x00	; 0
     cd0:	53 0f       	add	r21, r19
     cd2:	31 e0       	ldi	r19, 0x01	; 1
     cd4:	58 17       	cp	r21, r24
     cd6:	08 f0       	brcs	.+2      	; 0xcda <__vector_23+0x72>
     cd8:	30 e0       	ldi	r19, 0x00	; 0
     cda:	43 2b       	or	r20, r19
     cdc:	82 2f       	mov	r24, r18
     cde:	30 e0       	ldi	r19, 0x00	; 0
     ce0:	42 0f       	add	r20, r18
     ce2:	21 e0       	ldi	r18, 0x01	; 1
     ce4:	48 17       	cp	r20, r24
     ce6:	08 f0       	brcs	.+2      	; 0xcea <__vector_23+0x82>
     ce8:	20 e0       	ldi	r18, 0x00	; 0
     cea:	32 2b       	or	r19, r18
     cec:	89 2f       	mov	r24, r25
     cee:	20 e0       	ldi	r18, 0x00	; 0
     cf0:	39 0f       	add	r19, r25
     cf2:	91 e0       	ldi	r25, 0x01	; 1
     cf4:	38 17       	cp	r19, r24
     cf6:	08 f0       	brcs	.+2      	; 0xcfa <__vector_23+0x92>
     cf8:	90 e0       	ldi	r25, 0x00	; 0
     cfa:	29 2b       	or	r18, r25
     cfc:	8f 2f       	mov	r24, r31
     cfe:	90 e0       	ldi	r25, 0x00	; 0
     d00:	2f 0f       	add	r18, r31
     d02:	f1 e0       	ldi	r31, 0x01	; 1
     d04:	28 17       	cp	r18, r24
     d06:	08 f0       	brcs	.+2      	; 0xd0a <__vector_23+0xa2>
     d08:	f0 e0       	ldi	r31, 0x00	; 0
     d0a:	9f 2b       	or	r25, r31
     d0c:	fe 2f       	mov	r31, r30
     d0e:	80 e0       	ldi	r24, 0x00	; 0
     d10:	9e 0f       	add	r25, r30
     d12:	e1 e0       	ldi	r30, 0x01	; 1
     d14:	9f 17       	cp	r25, r31
     d16:	08 f0       	brcs	.+2      	; 0xd1a <__vector_23+0xb2>
     d18:	e0 e0       	ldi	r30, 0x00	; 0
     d1a:	8e 2b       	or	r24, r30
     d1c:	8a 0f       	add	r24, r26
     d1e:	70 93 48 02 	sts	0x0248, r23
     d22:	60 93 49 02 	sts	0x0249, r22
     d26:	50 93 4a 02 	sts	0x024A, r21
     d2a:	40 93 4b 02 	sts	0x024B, r20
     d2e:	30 93 4c 02 	sts	0x024C, r19
     d32:	20 93 4d 02 	sts	0x024D, r18
     d36:	90 93 4e 02 	sts	0x024E, r25
     d3a:	80 93 4f 02 	sts	0x024F, r24
}
     d3e:	ff 91       	pop	r31
     d40:	ef 91       	pop	r30
     d42:	af 91       	pop	r26
     d44:	9f 91       	pop	r25
     d46:	8f 91       	pop	r24
     d48:	7f 91       	pop	r23
     d4a:	6f 91       	pop	r22
     d4c:	5f 91       	pop	r21
     d4e:	4f 91       	pop	r20
     d50:	3f 91       	pop	r19
     d52:	2f 91       	pop	r18
     d54:	0f 90       	pop	r0
     d56:	0b be       	out	0x3b, r0	; 59
     d58:	0f 90       	pop	r0
     d5a:	0f be       	out	0x3f, r0	; 63
     d5c:	0f 90       	pop	r0
     d5e:	1f 90       	pop	r1
     d60:	18 95       	reti

00000d62 <millis>:

// return elapsed time in milliseconds
uint64_t millis()
{
	return millis_prv;
     d62:	20 91 48 02 	lds	r18, 0x0248
     d66:	30 91 49 02 	lds	r19, 0x0249
     d6a:	40 91 4a 02 	lds	r20, 0x024A
     d6e:	50 91 4b 02 	lds	r21, 0x024B
     d72:	60 91 4c 02 	lds	r22, 0x024C
     d76:	70 91 4d 02 	lds	r23, 0x024D
     d7a:	80 91 4e 02 	lds	r24, 0x024E
     d7e:	90 91 4f 02 	lds	r25, 0x024F
     d82:	08 95       	ret

00000d84 <adc_port_init>:
/***** Call adc_init() and lcd_init() once in main() to use "ADC.c" functions ******/ 


void adc_port_init()			//ADC port initialization
{
	DDRF=0x00;
     d84:	10 ba       	out	0x10, r1	; 16
	PORTF=0x00;
     d86:	11 ba       	out	0x11, r1	; 17
	DDRK=0x00;
     d88:	10 92 07 01 	sts	0x0107, r1
	PORTK=0x00;
     d8c:	10 92 08 01 	sts	0x0108, r1
}
     d90:	08 95       	ret

00000d92 <adc_reg_init>:

void adc_reg_init()			//ADC registers initialization
{
	ADCSRA=0x00;
     d92:	ea e7       	ldi	r30, 0x7A	; 122
     d94:	f0 e0       	ldi	r31, 0x00	; 0
     d96:	10 82       	st	Z, r1
	ADCSRB=0x00;
     d98:	10 92 7b 00 	sts	0x007B, r1
	ADMUX=0x20;			//Enabling Left adjust result
     d9c:	80 e2       	ldi	r24, 0x20	; 32
     d9e:	80 93 7c 00 	sts	0x007C, r24
	ACSR=0x80;			//Disabling analog comparator
     da2:	80 e8       	ldi	r24, 0x80	; 128
     da4:	80 bf       	out	0x30, r24	; 48
	ADCSRA=0x86;			//Enabling ADC and setting pre-scalar of 64
     da6:	86 e8       	ldi	r24, 0x86	; 134
     da8:	80 83       	st	Z, r24
}
     daa:	08 95       	ret

00000dac <adc_init>:

void adc_init()
{
	adc_port_init();
     dac:	0e 94 c2 06 	call	0xd84	; 0xd84 <adc_port_init>
	adc_reg_init();
     db0:	0e 94 c9 06 	call	0xd92	; 0xd92 <adc_reg_init>
}
     db4:	08 95       	ret

00000db6 <ADC_conversion>:
int ADC_conversion(int Ch)		//function for ADC conversion
{
	int a;
	if(Ch>7)
     db6:	88 30       	cpi	r24, 0x08	; 8
     db8:	91 05       	cpc	r25, r1
     dba:	1c f0       	brlt	.+6      	; 0xdc2 <ADC_conversion+0xc>
	{
		ADCSRB = 0x08;
     dbc:	28 e0       	ldi	r18, 0x08	; 8
     dbe:	20 93 7b 00 	sts	0x007B, r18
	}
	Ch = Ch & 0x07;
     dc2:	87 70       	andi	r24, 0x07	; 7
     dc4:	90 70       	andi	r25, 0x00	; 0
	ADMUX= 0x20| Ch;
     dc6:	80 62       	ori	r24, 0x20	; 32
     dc8:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
     dcc:	ea e7       	ldi	r30, 0x7A	; 122
     dce:	f0 e0       	ldi	r31, 0x00	; 0
     dd0:	80 81       	ld	r24, Z
     dd2:	80 64       	ori	r24, 0x40	; 64
     dd4:	80 83       	st	Z, r24
	while((ADCSRA&0x10)==0);	//Wait for ADC conversion to complete
     dd6:	80 81       	ld	r24, Z
     dd8:	84 ff       	sbrs	r24, 4
     dda:	fd cf       	rjmp	.-6      	; 0xdd6 <ADC_conversion+0x20>
	a=ADCH;
     ddc:	80 91 79 00 	lds	r24, 0x0079
	ADCSRA = ADCSRA|0x10; 		//clear ADIF (ADC Interrupt Flag) by writing 1 to it
     de0:	ea e7       	ldi	r30, 0x7A	; 122
     de2:	f0 e0       	ldi	r31, 0x00	; 0
     de4:	90 81       	ld	r25, Z
     de6:	90 61       	ori	r25, 0x10	; 16
     de8:	90 83       	st	Z, r25
	ADCSRB = 0x00;
     dea:	10 92 7b 00 	sts	0x007B, r1
	return a;	
}
     dee:	90 e0       	ldi	r25, 0x00	; 0
     df0:	08 95       	ret

00000df2 <print_sensor>:

void print_sensor(int row, int coloumn,int channel)		//function to print ADC values
{
     df2:	cf 93       	push	r28
     df4:	df 93       	push	r29
     df6:	d8 2f       	mov	r29, r24
     df8:	c6 2f       	mov	r28, r22
     dfa:	ca 01       	movw	r24, r20
	int ADC_Value = ADC_conversion(channel);
     dfc:	0e 94 db 06 	call	0xdb6	; 0xdb6 <ADC_conversion>
     e00:	ac 01       	movw	r20, r24
	lcd_print(row, coloumn, ADC_Value, 3);
     e02:	8d 2f       	mov	r24, r29
     e04:	6c 2f       	mov	r22, r28
     e06:	23 e0       	ldi	r18, 0x03	; 3
     e08:	30 e0       	ldi	r19, 0x00	; 0
     e0a:	0e 94 99 01 	call	0x332	; 0x332 <lcd_print>
}
     e0e:	df 91       	pop	r29
     e10:	cf 91       	pop	r28
     e12:	08 95       	ret

00000e14 <motor_pin_config>:
volatile unsigned int Degrees; //to accept angle in degrees for turning


void motor_pin_config()
{
	DDRA|=0x0F;
     e14:	81 b1       	in	r24, 0x01	; 1
     e16:	8f 60       	ori	r24, 0x0F	; 15
     e18:	81 b9       	out	0x01, r24	; 1
	PORTA&=~(0x0F);
     e1a:	82 b1       	in	r24, 0x02	; 2
     e1c:	80 7f       	andi	r24, 0xF0	; 240
     e1e:	82 b9       	out	0x02, r24	; 2
	DDRL|=(1<<PL3)|(1<<PL4);
     e20:	ea e0       	ldi	r30, 0x0A	; 10
     e22:	f1 e0       	ldi	r31, 0x01	; 1
     e24:	80 81       	ld	r24, Z
     e26:	88 61       	ori	r24, 0x18	; 24
     e28:	80 83       	st	Z, r24
	PORTL|=(1<<PL3)|(1<<PL4);	
     e2a:	eb e0       	ldi	r30, 0x0B	; 11
     e2c:	f1 e0       	ldi	r31, 0x01	; 1
     e2e:	80 81       	ld	r24, Z
     e30:	88 61       	ori	r24, 0x18	; 24
     e32:	80 83       	st	Z, r24
}
     e34:	08 95       	ret

00000e36 <left_encoder_pin_config>:

void left_encoder_pin_config (void)
{
 DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
     e36:	6c 98       	cbi	0x0d, 4	; 13
 PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
     e38:	74 9a       	sbi	0x0e, 4	; 14
}
     e3a:	08 95       	ret

00000e3c <right_encoder_pin_config>:

//Function to configure INT5 (PORTE 5) pin as input for the right position encoder
void right_encoder_pin_config (void)
{
 DDRE  = DDRE & 0xDF;  //Set the direction of the PORTE 4 pin as input
     e3c:	6d 98       	cbi	0x0d, 5	; 13
 PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 4 pin
     e3e:	75 9a       	sbi	0x0e, 5	; 14
}
     e40:	08 95       	ret

00000e42 <left_position_encoder_interrupt_init>:

void left_position_encoder_interrupt_init (void) //Interrupt 4 enable
{
 cli(); //Clears the global interrupt
     e42:	f8 94       	cli
 EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
     e44:	ea e6       	ldi	r30, 0x6A	; 106
     e46:	f0 e0       	ldi	r31, 0x00	; 0
     e48:	80 81       	ld	r24, Z
     e4a:	82 60       	ori	r24, 0x02	; 2
     e4c:	80 83       	st	Z, r24
 EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
     e4e:	ec 9a       	sbi	0x1d, 4	; 29
 sei();   // Enables the global interrupt 
     e50:	78 94       	sei
}
     e52:	08 95       	ret

00000e54 <right_position_encoder_interrupt_init>:

void right_position_encoder_interrupt_init (void) //Interrupt 5 enable
{
 cli(); //Clears the global interrupt
     e54:	f8 94       	cli
 EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
     e56:	ea e6       	ldi	r30, 0x6A	; 106
     e58:	f0 e0       	ldi	r31, 0x00	; 0
     e5a:	80 81       	ld	r24, Z
     e5c:	88 60       	ori	r24, 0x08	; 8
     e5e:	80 83       	st	Z, r24
 EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
     e60:	ed 9a       	sbi	0x1d, 5	; 29
 sei();   // Enables the global interrupt 
     e62:	78 94       	sei
}
     e64:	08 95       	ret

00000e66 <motor_control_init>:


void motor_control_init()  //Motor control initialization
{
	motor_pin_config();
     e66:	0e 94 0a 07 	call	0xe14	; 0xe14 <motor_pin_config>
	left_encoder_pin_config();
     e6a:	0e 94 1b 07 	call	0xe36	; 0xe36 <left_encoder_pin_config>
	right_encoder_pin_config;
	left_position_encoder_interrupt_init();
     e6e:	0e 94 21 07 	call	0xe42	; 0xe42 <left_position_encoder_interrupt_init>
	right_position_encoder_interrupt_init();
     e72:	0e 94 2a 07 	call	0xe54	; 0xe54 <right_position_encoder_interrupt_init>
	buzzer_pin_config();
     e76:	0e 94 ac 00 	call	0x158	; 0x158 <buzzer_pin_config>
}
     e7a:	08 95       	ret

00000e7c <__vector_5>:
ISR(INT4_vect)		//Interrupt Service Routine for INT4 external interrupt
{
     e7c:	1f 92       	push	r1
     e7e:	0f 92       	push	r0
     e80:	0f b6       	in	r0, 0x3f	; 63
     e82:	0f 92       	push	r0
     e84:	11 24       	eor	r1, r1
     e86:	8f 93       	push	r24
     e88:	9f 93       	push	r25
     e8a:	af 93       	push	r26
     e8c:	bf 93       	push	r27
	ShaftCountLeft++;
     e8e:	80 91 44 02 	lds	r24, 0x0244
     e92:	90 91 45 02 	lds	r25, 0x0245
     e96:	a0 91 46 02 	lds	r26, 0x0246
     e9a:	b0 91 47 02 	lds	r27, 0x0247
     e9e:	01 96       	adiw	r24, 0x01	; 1
     ea0:	a1 1d       	adc	r26, r1
     ea2:	b1 1d       	adc	r27, r1
     ea4:	80 93 44 02 	sts	0x0244, r24
     ea8:	90 93 45 02 	sts	0x0245, r25
     eac:	a0 93 46 02 	sts	0x0246, r26
     eb0:	b0 93 47 02 	sts	0x0247, r27
}
     eb4:	bf 91       	pop	r27
     eb6:	af 91       	pop	r26
     eb8:	9f 91       	pop	r25
     eba:	8f 91       	pop	r24
     ebc:	0f 90       	pop	r0
     ebe:	0f be       	out	0x3f, r0	; 63
     ec0:	0f 90       	pop	r0
     ec2:	1f 90       	pop	r1
     ec4:	18 95       	reti

00000ec6 <__vector_6>:

ISR(INT5_vect)		//Interrupt Service Routine for INT5 external interrupt
{
     ec6:	1f 92       	push	r1
     ec8:	0f 92       	push	r0
     eca:	0f b6       	in	r0, 0x3f	; 63
     ecc:	0f 92       	push	r0
     ece:	11 24       	eor	r1, r1
     ed0:	8f 93       	push	r24
     ed2:	9f 93       	push	r25
     ed4:	af 93       	push	r26
     ed6:	bf 93       	push	r27
	ShaftCountRight++;
     ed8:	80 91 40 02 	lds	r24, 0x0240
     edc:	90 91 41 02 	lds	r25, 0x0241
     ee0:	a0 91 42 02 	lds	r26, 0x0242
     ee4:	b0 91 43 02 	lds	r27, 0x0243
     ee8:	01 96       	adiw	r24, 0x01	; 1
     eea:	a1 1d       	adc	r26, r1
     eec:	b1 1d       	adc	r27, r1
     eee:	80 93 40 02 	sts	0x0240, r24
     ef2:	90 93 41 02 	sts	0x0241, r25
     ef6:	a0 93 42 02 	sts	0x0242, r26
     efa:	b0 93 43 02 	sts	0x0243, r27
}
     efe:	bf 91       	pop	r27
     f00:	af 91       	pop	r26
     f02:	9f 91       	pop	r25
     f04:	8f 91       	pop	r24
     f06:	0f 90       	pop	r0
     f08:	0f be       	out	0x3f, r0	; 63
     f0a:	0f 90       	pop	r0
     f0c:	1f 90       	pop	r1
     f0e:	18 95       	reti

00000f10 <motion_set>:
void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;

 Direction &= 0x0F; 		// removing upper nibble for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
     f10:	92 b1       	in	r25, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibble to 0
     f12:	90 7f       	andi	r25, 0xF0	; 240

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;

 Direction &= 0x0F; 		// removing upper nibble for the protection
     f14:	8f 70       	andi	r24, 0x0F	; 15
 PortARestore = PORTA; 		// reading the PORTA original status
 PortARestore &= 0xF0; 		// making lower direction nibble to 0
 PortARestore |= Direction; // adding lower nibble for forward command and restoring the PORTA status
     f16:	98 2b       	or	r25, r24
 PORTA = PortARestore; 		// executing the command
     f18:	92 b9       	out	0x02, r25	; 2
}
     f1a:	08 95       	ret

00000f1c <forward>:

void forward (void) //both wheels forward
{
  motion_set(0x06);
     f1c:	86 e0       	ldi	r24, 0x06	; 6
     f1e:	0e 94 88 07 	call	0xf10	; 0xf10 <motion_set>
}
     f22:	08 95       	ret

00000f24 <back>:

void back (void) //both wheels backward
{
  motion_set(0x09);
     f24:	89 e0       	ldi	r24, 0x09	; 9
     f26:	0e 94 88 07 	call	0xf10	; 0xf10 <motion_set>
}
     f2a:	08 95       	ret

00000f2c <left>:

void left (void) //Left wheel backward, Right wheel forward
{
  motion_set(0x05);
     f2c:	85 e0       	ldi	r24, 0x05	; 5
     f2e:	0e 94 88 07 	call	0xf10	; 0xf10 <motion_set>
}
     f32:	08 95       	ret

00000f34 <right>:

void right (void) //Left wheel forward, Right wheel backward
{
  motion_set(0x0A);
     f34:	8a e0       	ldi	r24, 0x0A	; 10
     f36:	0e 94 88 07 	call	0xf10	; 0xf10 <motion_set>
}
     f3a:	08 95       	ret

00000f3c <soft_left>:

void soft_left (void) //Left wheel stationary, Right wheel forward
{
 motion_set(0x04);
     f3c:	84 e0       	ldi	r24, 0x04	; 4
     f3e:	0e 94 88 07 	call	0xf10	; 0xf10 <motion_set>
}
     f42:	08 95       	ret

00000f44 <soft_right>:

void soft_right (void) //Left wheel forward, Right wheel is stationary
{
 motion_set(0x02);
     f44:	82 e0       	ldi	r24, 0x02	; 2
     f46:	0e 94 88 07 	call	0xf10	; 0xf10 <motion_set>
}
     f4a:	08 95       	ret

00000f4c <soft_left_2>:

void soft_left_2 (void) //Left wheel backward, right wheel stationary
{
 motion_set(0x01);
     f4c:	81 e0       	ldi	r24, 0x01	; 1
     f4e:	0e 94 88 07 	call	0xf10	; 0xf10 <motion_set>
}
     f52:	08 95       	ret

00000f54 <soft_right_2>:

void soft_right_2 (void) //Left wheel stationary, Right wheel backward
{
 motion_set(0x08);
     f54:	88 e0       	ldi	r24, 0x08	; 8
     f56:	0e 94 88 07 	call	0xf10	; 0xf10 <motion_set>
}
     f5a:	08 95       	ret

00000f5c <Stop>:

void Stop (void)		//Stop
{
  motion_set(0x00);
     f5c:	80 e0       	ldi	r24, 0x00	; 0
     f5e:	0e 94 88 07 	call	0xf10	; 0xf10 <motion_set>
}
     f62:	08 95       	ret

00000f64 <angle_rotate>:

void angle_rotate(unsigned int Degrees)
{
     f64:	0f 93       	push	r16
     f66:	1f 93       	push	r17
     f68:	cf 93       	push	r28
 float ReqdShaftCount = 0;
 unsigned long int ReqdShaftCountInt = 0;

 ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
     f6a:	bc 01       	movw	r22, r24
     f6c:	80 e0       	ldi	r24, 0x00	; 0
     f6e:	90 e0       	ldi	r25, 0x00	; 0
     f70:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <__floatunsisf>
     f74:	28 e4       	ldi	r18, 0x48	; 72
     f76:	31 ee       	ldi	r19, 0xE1	; 225
     f78:	42 e8       	ldi	r20, 0x82	; 130
     f7a:	50 e4       	ldi	r21, 0x40	; 64
     f7c:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <__divsf3>
 ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
     f80:	0e 94 84 0f 	call	0x1f08	; 0x1f08 <__fixunssfsi>
     f84:	dc 01       	movw	r26, r24
     f86:	cb 01       	movw	r24, r22
     f88:	a0 e0       	ldi	r26, 0x00	; 0
     f8a:	b0 e0       	ldi	r27, 0x00	; 0
 ShaftCountRight = 0; 
     f8c:	10 92 40 02 	sts	0x0240, r1
     f90:	10 92 41 02 	sts	0x0241, r1
     f94:	10 92 42 02 	sts	0x0242, r1
     f98:	10 92 43 02 	sts	0x0243, r1
 ShaftCountLeft = 0; 
     f9c:	10 92 44 02 	sts	0x0244, r1
     fa0:	10 92 45 02 	sts	0x0245, r1
     fa4:	10 92 46 02 	sts	0x0246, r1
     fa8:	10 92 47 02 	sts	0x0247, r1

 while (1)
 {
  if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
     fac:	f1 e0       	ldi	r31, 0x01	; 1
     fae:	c0 e0       	ldi	r28, 0x00	; 0
     fb0:	40 91 40 02 	lds	r20, 0x0240
     fb4:	50 91 41 02 	lds	r21, 0x0241
     fb8:	60 91 42 02 	lds	r22, 0x0242
     fbc:	70 91 43 02 	lds	r23, 0x0243
     fc0:	00 91 44 02 	lds	r16, 0x0244
     fc4:	10 91 45 02 	lds	r17, 0x0245
     fc8:	20 91 46 02 	lds	r18, 0x0246
     fcc:	30 91 47 02 	lds	r19, 0x0247
     fd0:	ef 2f       	mov	r30, r31
     fd2:	48 17       	cp	r20, r24
     fd4:	59 07       	cpc	r21, r25
     fd6:	6a 07       	cpc	r22, r26
     fd8:	7b 07       	cpc	r23, r27
     fda:	08 f4       	brcc	.+2      	; 0xfde <angle_rotate+0x7a>
     fdc:	ec 2f       	mov	r30, r28
     fde:	ee 23       	and	r30, r30
     fe0:	49 f4       	brne	.+18     	; 0xff4 <angle_rotate+0x90>
     fe2:	4f 2f       	mov	r20, r31
     fe4:	08 17       	cp	r16, r24
     fe6:	19 07       	cpc	r17, r25
     fe8:	2a 07       	cpc	r18, r26
     fea:	3b 07       	cpc	r19, r27
     fec:	08 f4       	brcc	.+2      	; 0xff0 <angle_rotate+0x8c>
     fee:	4c 2f       	mov	r20, r28
     ff0:	44 23       	and	r20, r20
     ff2:	f1 f2       	breq	.-68     	; 0xfb0 <angle_rotate+0x4c>
  break;
 }
 Stop(); //Stop robot
     ff4:	0e 94 ae 07 	call	0xf5c	; 0xf5c <Stop>
}
     ff8:	cf 91       	pop	r28
     ffa:	1f 91       	pop	r17
     ffc:	0f 91       	pop	r16
     ffe:	08 95       	ret

00001000 <linear_distance_mm>:
void linear_distance_mm(unsigned int DistanceInMM)
{
 float ReqdShaftCount = 0;
 unsigned long int ReqdShaftCountInt = 0;

 ReqdShaftCount = DistanceInMM / 5.338; // division by resolution to get shaft count
    1000:	bc 01       	movw	r22, r24
    1002:	80 e0       	ldi	r24, 0x00	; 0
    1004:	90 e0       	ldi	r25, 0x00	; 0
    1006:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <__floatunsisf>
    100a:	25 ee       	ldi	r18, 0xE5	; 229
    100c:	30 ed       	ldi	r19, 0xD0	; 208
    100e:	4a ea       	ldi	r20, 0xAA	; 170
    1010:	50 e4       	ldi	r21, 0x40	; 64
    1012:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <__divsf3>
 ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
    1016:	0e 94 84 0f 	call	0x1f08	; 0x1f08 <__fixunssfsi>
    101a:	46 2f       	mov	r20, r22
    101c:	57 2f       	mov	r21, r23
    101e:	68 2f       	mov	r22, r24
    1020:	79 2f       	mov	r23, r25
  
 ShaftCountRight = 0;
    1022:	10 92 40 02 	sts	0x0240, r1
    1026:	10 92 41 02 	sts	0x0241, r1
    102a:	10 92 42 02 	sts	0x0242, r1
    102e:	10 92 43 02 	sts	0x0243, r1
 while(1)
 {
  if(ShaftCountRight > ReqdShaftCountInt)
    1032:	80 91 40 02 	lds	r24, 0x0240
    1036:	90 91 41 02 	lds	r25, 0x0241
    103a:	a0 91 42 02 	lds	r26, 0x0242
    103e:	b0 91 43 02 	lds	r27, 0x0243
    1042:	48 17       	cp	r20, r24
    1044:	59 07       	cpc	r21, r25
    1046:	6a 07       	cpc	r22, r26
    1048:	7b 07       	cpc	r23, r27
    104a:	98 f7       	brcc	.-26     	; 0x1032 <linear_distance_mm+0x32>
  {
  	break;
  }
 } 
 Stop(); //Stop robot
    104c:	0e 94 ae 07 	call	0xf5c	; 0xf5c <Stop>
}
    1050:	08 95       	ret

00001052 <Stop_delay>:

void Stop_delay()
{
	Stop();
    1052:	0e 94 ae 07 	call	0xf5c	; 0xf5c <Stop>
    1056:	8f ef       	ldi	r24, 0xFF	; 255
    1058:	9f e3       	ldi	r25, 0x3F	; 63
    105a:	a2 e0       	ldi	r26, 0x02	; 2
    105c:	81 50       	subi	r24, 0x01	; 1
    105e:	90 40       	sbci	r25, 0x00	; 0
    1060:	a0 40       	sbci	r26, 0x00	; 0
    1062:	e1 f7       	brne	.-8      	; 0x105c <Stop_delay+0xa>
    1064:	00 c0       	rjmp	.+0      	; 0x1066 <Stop_delay+0x14>
    1066:	00 00       	nop
	_delay_ms(50);
}
    1068:	08 95       	ret

0000106a <forward_mm>:

void forward_mm(unsigned int DistanceInMM)
{
    106a:	cf 93       	push	r28
    106c:	df 93       	push	r29
    106e:	ec 01       	movw	r28, r24
 forward();
    1070:	0e 94 8e 07 	call	0xf1c	; 0xf1c <forward>
 linear_distance_mm(DistanceInMM);
    1074:	ce 01       	movw	r24, r28
    1076:	0e 94 00 08 	call	0x1000	; 0x1000 <linear_distance_mm>
}
    107a:	df 91       	pop	r29
    107c:	cf 91       	pop	r28
    107e:	08 95       	ret

00001080 <back_mm>:

void back_mm(unsigned int DistanceInMM)
{
    1080:	cf 93       	push	r28
    1082:	df 93       	push	r29
    1084:	ec 01       	movw	r28, r24
 back();
    1086:	0e 94 92 07 	call	0xf24	; 0xf24 <back>
 linear_distance_mm(DistanceInMM);
    108a:	ce 01       	movw	r24, r28
    108c:	0e 94 00 08 	call	0x1000	; 0x1000 <linear_distance_mm>
}
    1090:	df 91       	pop	r29
    1092:	cf 91       	pop	r28
    1094:	08 95       	ret

00001096 <left_degrees>:

void left_degrees(unsigned int Degrees) 
{
    1096:	cf 93       	push	r28
    1098:	df 93       	push	r29
    109a:	ec 01       	movw	r28, r24
// 88 pulses for 360 degrees rotation 4.090 degrees per count
 left(); //Turn left
    109c:	0e 94 96 07 	call	0xf2c	; 0xf2c <left>
 angle_rotate(Degrees);
    10a0:	ce 01       	movw	r24, r28
    10a2:	0e 94 b2 07 	call	0xf64	; 0xf64 <angle_rotate>
}
    10a6:	df 91       	pop	r29
    10a8:	cf 91       	pop	r28
    10aa:	08 95       	ret

000010ac <right_degrees>:



void right_degrees(unsigned int Degrees)
{
    10ac:	cf 93       	push	r28
    10ae:	df 93       	push	r29
    10b0:	ec 01       	movw	r28, r24
// 88 pulses for 360 degrees rotation 4.090 degrees per count
 right(); //Turn right
    10b2:	0e 94 9a 07 	call	0xf34	; 0xf34 <right>
 angle_rotate(Degrees);
    10b6:	ce 01       	movw	r24, r28
    10b8:	0e 94 b2 07 	call	0xf64	; 0xf64 <angle_rotate>
}
    10bc:	df 91       	pop	r29
    10be:	cf 91       	pop	r28
    10c0:	08 95       	ret

000010c2 <soft_left_degrees>:


void soft_left_degrees(unsigned int Degrees)
{
    10c2:	cf 93       	push	r28
    10c4:	df 93       	push	r29
    10c6:	ec 01       	movw	r28, r24
 // 176 pulses for 360 degrees rotation 2.045 degrees per count
 soft_left(); //Turn soft left
    10c8:	0e 94 9e 07 	call	0xf3c	; 0xf3c <soft_left>
 Degrees=Degrees*2;
 angle_rotate(Degrees);
    10cc:	ce 01       	movw	r24, r28
    10ce:	88 0f       	add	r24, r24
    10d0:	99 1f       	adc	r25, r25
    10d2:	0e 94 b2 07 	call	0xf64	; 0xf64 <angle_rotate>
}
    10d6:	df 91       	pop	r29
    10d8:	cf 91       	pop	r28
    10da:	08 95       	ret

000010dc <soft_right_degrees>:

void soft_right_degrees(unsigned int Degrees)
{
    10dc:	cf 93       	push	r28
    10de:	df 93       	push	r29
    10e0:	ec 01       	movw	r28, r24
 // 176 pulses for 360 degrees rotation 2.045 degrees per count
 soft_right();  //Turn soft right
    10e2:	0e 94 a2 07 	call	0xf44	; 0xf44 <soft_right>
 Degrees=Degrees*2;
 angle_rotate(Degrees);
    10e6:	ce 01       	movw	r24, r28
    10e8:	88 0f       	add	r24, r24
    10ea:	99 1f       	adc	r25, r25
    10ec:	0e 94 b2 07 	call	0xf64	; 0xf64 <angle_rotate>
}
    10f0:	df 91       	pop	r29
    10f2:	cf 91       	pop	r28
    10f4:	08 95       	ret

000010f6 <soft_left_2_degrees>:

void soft_left_2_degrees(unsigned int Degrees)
{
    10f6:	cf 93       	push	r28
    10f8:	df 93       	push	r29
    10fa:	ec 01       	movw	r28, r24
 // 176 pulses for 360 degrees rotation 2.045 degrees per count
 soft_left_2(); //Turn reverse soft left
    10fc:	0e 94 a6 07 	call	0xf4c	; 0xf4c <soft_left_2>
 Degrees=Degrees*2;
 angle_rotate(Degrees);
    1100:	ce 01       	movw	r24, r28
    1102:	88 0f       	add	r24, r24
    1104:	99 1f       	adc	r25, r25
    1106:	0e 94 b2 07 	call	0xf64	; 0xf64 <angle_rotate>
}
    110a:	df 91       	pop	r29
    110c:	cf 91       	pop	r28
    110e:	08 95       	ret

00001110 <soft_right_2_degrees>:

void soft_right_2_degrees(unsigned int Degrees)
{
    1110:	cf 93       	push	r28
    1112:	df 93       	push	r29
    1114:	ec 01       	movw	r28, r24
 // 176 pulses for 360 degrees rotation 2.045 degrees per count
 soft_right_2();  //Turn reverse soft right
    1116:	0e 94 aa 07 	call	0xf54	; 0xf54 <soft_right_2>
 Degrees=Degrees*2;
 angle_rotate(Degrees);
    111a:	ce 01       	movw	r24, r28
    111c:	88 0f       	add	r24, r24
    111e:	99 1f       	adc	r25, r25
    1120:	0e 94 b2 07 	call	0xf64	; 0xf64 <angle_rotate>
}
    1124:	df 91       	pop	r29
    1126:	cf 91       	pop	r28
    1128:	08 95       	ret

0000112a <buzzer_on>:

void buzzer_on (void)
{
	//buzzer on
	unsigned char port_restore = 0;
	port_restore = PINC;
    112a:	86 b1       	in	r24, 0x06	; 6
	port_restore = port_restore | 0x08;
    112c:	88 60       	ori	r24, 0x08	; 8
	PORTC = port_restore;
    112e:	88 b9       	out	0x08, r24	; 8
}
    1130:	08 95       	ret

00001132 <buzzer_off>:

void buzzer_off (void)
{
	//buzzer off
	unsigned char port_restore = 0;
	port_restore = PINC;
    1132:	86 b1       	in	r24, 0x06	; 6
	port_restore = port_restore & 0xF7;
    1134:	87 7f       	andi	r24, 0xF7	; 247
	PORTC = port_restore;
    1136:	88 b9       	out	0x08, r24	; 8
}
    1138:	08 95       	ret

0000113a <timer5_init>:

void timer5_init()					//Timer 5 initialization
{
	//Fast PWM 8-bit mode (Non-inverting)
	//Pre-scalar of 256
	TCCR5A=0b10101001;
    113a:	89 ea       	ldi	r24, 0xA9	; 169
    113c:	80 93 20 01 	sts	0x0120, r24
	TCCR5B=0b00001100;
    1140:	8c e0       	ldi	r24, 0x0C	; 12
    1142:	80 93 21 01 	sts	0x0121, r24
	TCNT5=0;		//Setting timer value to zero
    1146:	10 92 25 01 	sts	0x0125, r1
    114a:	10 92 24 01 	sts	0x0124, r1
	OCR5A=255;		//Output Compare register A initialization
    114e:	8f ef       	ldi	r24, 0xFF	; 255
    1150:	90 e0       	ldi	r25, 0x00	; 0
    1152:	90 93 29 01 	sts	0x0129, r25
    1156:	80 93 28 01 	sts	0x0128, r24
	OCR5B=255;		//Output Compare register B initialization
    115a:	90 93 2b 01 	sts	0x012B, r25
    115e:	80 93 2a 01 	sts	0x012A, r24
}
    1162:	08 95       	ret

00001164 <velocity>:

void velocity(int left_motor,int right_motor)			//Function for velocity variation using PWM
{
	OCR5A=left_motor;
    1164:	28 2f       	mov	r18, r24
    1166:	39 2f       	mov	r19, r25
    1168:	30 93 29 01 	sts	0x0129, r19
    116c:	20 93 28 01 	sts	0x0128, r18
	OCR5B=right_motor;
    1170:	86 2f       	mov	r24, r22
    1172:	97 2f       	mov	r25, r23
    1174:	90 93 2b 01 	sts	0x012B, r25
    1178:	80 93 2a 01 	sts	0x012A, r24
	
}
    117c:	08 95       	ret

0000117e <servo1_pin_config>:


//Configure PORTB 5 pin for servo motor 1 operation
void servo1_pin_config (void)
{
	DDRB  = DDRB | 0x20;  //making PORTB 5 pin output
    117e:	25 9a       	sbi	0x04, 5	; 4
	PORTB = PORTB | 0x20; //setting PORTB 5 pin to logic 1
    1180:	2d 9a       	sbi	0x05, 5	; 5
}
    1182:	08 95       	ret

00001184 <port_init>:

void port_init(void)
{
	servo1_pin_config(); //Configure PORTB 5 pin for servo motor 1 operation
    1184:	0e 94 bf 08 	call	0x117e	; 0x117e <servo1_pin_config>
}
    1188:	08 95       	ret

0000118a <timer1_init>:

void timer1_init(void)
{
	TCCR1B = 0x00; //stop
    118a:	e1 e8       	ldi	r30, 0x81	; 129
    118c:	f0 e0       	ldi	r31, 0x00	; 0
    118e:	10 82       	st	Z, r1
	TCNT1H = 0xFC; //Counter high value to which OCR1xH value is to be compared with
    1190:	8c ef       	ldi	r24, 0xFC	; 252
    1192:	80 93 85 00 	sts	0x0085, r24
	TCNT1L = 0x01;	//Counter low value to which OCR1xH value is to be compared with
    1196:	81 e0       	ldi	r24, 0x01	; 1
    1198:	80 93 84 00 	sts	0x0084, r24
	OCR1AH = 0x03;	//Output compare Register high value for servo 1
    119c:	93 e0       	ldi	r25, 0x03	; 3
    119e:	90 93 89 00 	sts	0x0089, r25
	OCR1AL = 0xFF;	//Output Compare Register low Value For servo 1
    11a2:	8f ef       	ldi	r24, 0xFF	; 255
    11a4:	80 93 88 00 	sts	0x0088, r24
	ICR1H  = 0x03;	
    11a8:	90 93 87 00 	sts	0x0087, r25
	ICR1L  = 0xFF;
    11ac:	80 93 86 00 	sts	0x0086, r24
	TCCR1A = 0xAB; /*{COM1A1=1, COM1A0=0; COM1B1=1, COM1B0=0; COM1C1=1 COM1C0=0}
    11b0:	8b ea       	ldi	r24, 0xAB	; 171
    11b2:	80 93 80 00 	sts	0x0080, r24
 					For Overriding normal port functionality to OCRnA outputs.
				  {WGM11=1, WGM10=1} Along With WGM12 in TCCR1B for Selecting FAST PWM Mode*/
	TCCR1C = 0x00;
    11b6:	10 92 82 00 	sts	0x0082, r1
	TCCR1B = 0x0C; //WGM12=1; CS12=1, CS11=0, CS10=0 (Prescaler=256)
    11ba:	8c e0       	ldi	r24, 0x0C	; 12
    11bc:	80 83       	st	Z, r24
}	
    11be:	08 95       	ret

000011c0 <init_servo>:

//Function to initialize all the peripherals
void init_servo(void)
{
	cli(); //disable all interrupts
    11c0:	f8 94       	cli
	port_init();
    11c2:	0e 94 c2 08 	call	0x1184	; 0x1184 <port_init>
	timer1_init();
    11c6:	0e 94 c5 08 	call	0x118a	; 0x118a <timer1_init>
	sei(); //re-enable interrupts
    11ca:	78 94       	sei
}
    11cc:	08 95       	ret

000011ce <servo_1>:
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
	OCR1AH = 0x00;
    11ce:	10 92 89 00 	sts	0x0089, r1

//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
    11d2:	68 2f       	mov	r22, r24
    11d4:	70 e0       	ldi	r23, 0x00	; 0
    11d6:	80 e0       	ldi	r24, 0x00	; 0
    11d8:	90 e0       	ldi	r25, 0x00	; 0
    11da:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <__floatunsisf>
    11de:	2b e7       	ldi	r18, 0x7B	; 123
    11e0:	34 e1       	ldi	r19, 0x14	; 20
    11e2:	4e ee       	ldi	r20, 0xEE	; 238
    11e4:	5f e3       	ldi	r21, 0x3F	; 63
    11e6:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <__divsf3>
    11ea:	20 e0       	ldi	r18, 0x00	; 0
    11ec:	30 e0       	ldi	r19, 0x00	; 0
    11ee:	4c e0       	ldi	r20, 0x0C	; 12
    11f0:	52 e4       	ldi	r21, 0x42	; 66
    11f2:	0e 94 56 0e 	call	0x1cac	; 0x1cac <__addsf3>
	OCR1AH = 0x00;
	OCR1AL = (unsigned char) PositionPanServo;
    11f6:	0e 94 84 0f 	call	0x1f08	; 0x1f08 <__fixunssfsi>
    11fa:	60 93 88 00 	sts	0x0088, r22
}
    11fe:	08 95       	ret

00001200 <Angle_setup>:

unsigned long timer; //it's a timer, saved as a big-ass unsigned int.  We use it to save times from the "micros()" command and subtract the present time in microseconds from the time stored in timer to calculate the time for each loop.
float compAngleX, compAngleY; //These are the angles in the complementary filter

void Angle_setup()
{
    1200:	8f 92       	push	r8
    1202:	9f 92       	push	r9
    1204:	af 92       	push	r10
    1206:	bf 92       	push	r11
    1208:	cf 92       	push	r12
    120a:	df 92       	push	r13
    120c:	ef 92       	push	r14
    120e:	ff 92       	push	r15
    1210:	cf 93       	push	r28
    1212:	df 93       	push	r29
    1214:	cd b7       	in	r28, 0x3d	; 61
    1216:	de b7       	in	r29, 0x3e	; 62
    1218:	2c 97       	sbiw	r28, 0x0c	; 12
    121a:	0f b6       	in	r0, 0x3f	; 63
    121c:	f8 94       	cli
    121e:	de bf       	out	0x3e, r29	; 62
    1220:	0f be       	out	0x3f, r0	; 63
    1222:	cd bf       	out	0x3d, r28	; 61
	    float GYX=0,GYY=0,GYZ=0;
		int gyx,gyy,gyz,acx,acy,acz;
		GYRO_READ(&gyx,&gyy,&gyz);
    1224:	ce 01       	movw	r24, r28
    1226:	01 96       	adiw	r24, 0x01	; 1
    1228:	be 01       	movw	r22, r28
    122a:	6d 5f       	subi	r22, 0xFD	; 253
    122c:	7f 4f       	sbci	r23, 0xFF	; 255
    122e:	ae 01       	movw	r20, r28
    1230:	4b 5f       	subi	r20, 0xFB	; 251
    1232:	5f 4f       	sbci	r21, 0xFF	; 255
    1234:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <GYRO_READ>
		ACC_READ(&acx,&acy,&acz);
    1238:	ce 01       	movw	r24, r28
    123a:	07 96       	adiw	r24, 0x07	; 7
    123c:	be 01       	movw	r22, r28
    123e:	67 5f       	subi	r22, 0xF7	; 247
    1240:	7f 4f       	sbci	r23, 0xFF	; 255
    1242:	ae 01       	movw	r20, r28
    1244:	45 5f       	subi	r20, 0xF5	; 245
    1246:	5f 4f       	sbci	r21, 0xFF	; 255
    1248:	0e 94 45 04 	call	0x88a	; 0x88a <ACC_READ>
		GYX=(float)(gyx-GYRO_XOUT_OFFSET)/GYRO_FACTOR;
		GYY=(float)(gyy-GYRO_YOUT_OFFSET)/GYRO_FACTOR;
		GYZ=(float)(gyz-GYRO_ZOUT_OFFSET)/GYRO_FACTOR;
		float roll=atan2(acy,acz)*RAD_TO_DEG;
    124c:	6b 85       	ldd	r22, Y+11	; 0x0b
    124e:	7c 85       	ldd	r23, Y+12	; 0x0c
    1250:	88 27       	eor	r24, r24
    1252:	77 fd       	sbrc	r23, 7
    1254:	80 95       	com	r24
    1256:	98 2f       	mov	r25, r24
    1258:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <__floatsisf>
    125c:	6b 01       	movw	r12, r22
    125e:	7c 01       	movw	r14, r24
    1260:	69 85       	ldd	r22, Y+9	; 0x09
    1262:	7a 85       	ldd	r23, Y+10	; 0x0a
    1264:	88 27       	eor	r24, r24
    1266:	77 fd       	sbrc	r23, 7
    1268:	80 95       	com	r24
    126a:	98 2f       	mov	r25, r24
    126c:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <__floatsisf>
    1270:	a7 01       	movw	r20, r14
    1272:	96 01       	movw	r18, r12
    1274:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <atan2>
    1278:	4b 01       	movw	r8, r22
    127a:	5c 01       	movw	r10, r24
		float pitch=atan2(-acx,acz)*RAD_TO_DEG;
    127c:	6f 81       	ldd	r22, Y+7	; 0x07
    127e:	78 85       	ldd	r23, Y+8	; 0x08
    1280:	70 95       	com	r23
    1282:	61 95       	neg	r22
    1284:	7f 4f       	sbci	r23, 0xFF	; 255
    1286:	88 27       	eor	r24, r24
    1288:	77 fd       	sbrc	r23, 7
    128a:	80 95       	com	r24
    128c:	98 2f       	mov	r25, r24
    128e:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <__floatsisf>
    1292:	a7 01       	movw	r20, r14
    1294:	96 01       	movw	r18, r12
    1296:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <atan2>
    129a:	6b 01       	movw	r12, r22
    129c:	7c 01       	movw	r14, r24
		GYRO_READ(&gyx,&gyy,&gyz);
		ACC_READ(&acx,&acy,&acz);
		GYX=(float)(gyx-GYRO_XOUT_OFFSET)/GYRO_FACTOR;
		GYY=(float)(gyy-GYRO_YOUT_OFFSET)/GYRO_FACTOR;
		GYZ=(float)(gyz-GYRO_ZOUT_OFFSET)/GYRO_FACTOR;
		float roll=atan2(acy,acz)*RAD_TO_DEG;
    129e:	c5 01       	movw	r24, r10
    12a0:	b4 01       	movw	r22, r8
    12a2:	20 e0       	ldi	r18, 0x00	; 0
    12a4:	30 e0       	ldi	r19, 0x00	; 0
    12a6:	44 e3       	ldi	r20, 0x34	; 52
    12a8:	53 e4       	ldi	r21, 0x43	; 67
    12aa:	0e 94 a8 10 	call	0x2150	; 0x2150 <__mulsf3>
    12ae:	2b ed       	ldi	r18, 0xDB	; 219
    12b0:	3f e0       	ldi	r19, 0x0F	; 15
    12b2:	49 e4       	ldi	r20, 0x49	; 73
    12b4:	50 e4       	ldi	r21, 0x40	; 64
    12b6:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <__divsf3>
    12ba:	dc 01       	movw	r26, r24
    12bc:	cb 01       	movw	r24, r22
		float pitch=atan2(-acx,acz)*RAD_TO_DEG;
		compAngleX = roll;
    12be:	80 93 6c 02 	sts	0x026C, r24
    12c2:	90 93 6d 02 	sts	0x026D, r25
    12c6:	a0 93 6e 02 	sts	0x026E, r26
    12ca:	b0 93 6f 02 	sts	0x026F, r27
		ACC_READ(&acx,&acy,&acz);
		GYX=(float)(gyx-GYRO_XOUT_OFFSET)/GYRO_FACTOR;
		GYY=(float)(gyy-GYRO_YOUT_OFFSET)/GYRO_FACTOR;
		GYZ=(float)(gyz-GYRO_ZOUT_OFFSET)/GYRO_FACTOR;
		float roll=atan2(acy,acz)*RAD_TO_DEG;
		float pitch=atan2(-acx,acz)*RAD_TO_DEG;
    12ce:	c7 01       	movw	r24, r14
    12d0:	b6 01       	movw	r22, r12
    12d2:	20 e0       	ldi	r18, 0x00	; 0
    12d4:	30 e0       	ldi	r19, 0x00	; 0
    12d6:	44 e3       	ldi	r20, 0x34	; 52
    12d8:	53 e4       	ldi	r21, 0x43	; 67
    12da:	0e 94 a8 10 	call	0x2150	; 0x2150 <__mulsf3>
    12de:	2b ed       	ldi	r18, 0xDB	; 219
    12e0:	3f e0       	ldi	r19, 0x0F	; 15
    12e2:	49 e4       	ldi	r20, 0x49	; 73
    12e4:	50 e4       	ldi	r21, 0x40	; 64
    12e6:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <__divsf3>
    12ea:	dc 01       	movw	r26, r24
    12ec:	cb 01       	movw	r24, r22
		compAngleX = roll;
		compAngleY = pitch;
    12ee:	80 93 78 02 	sts	0x0278, r24
    12f2:	90 93 79 02 	sts	0x0279, r25
    12f6:	a0 93 7a 02 	sts	0x027A, r26
    12fa:	b0 93 7b 02 	sts	0x027B, r27
		timer=millis();
    12fe:	0e 94 b1 06 	call	0xd62	; 0xd62 <millis>
    1302:	20 93 68 02 	sts	0x0268, r18
    1306:	30 93 69 02 	sts	0x0269, r19
    130a:	40 93 6a 02 	sts	0x026A, r20
    130e:	50 93 6b 02 	sts	0x026B, r21
}
    1312:	2c 96       	adiw	r28, 0x0c	; 12
    1314:	0f b6       	in	r0, 0x3f	; 63
    1316:	f8 94       	cli
    1318:	de bf       	out	0x3e, r29	; 62
    131a:	0f be       	out	0x3f, r0	; 63
    131c:	cd bf       	out	0x3d, r28	; 61
    131e:	df 91       	pop	r29
    1320:	cf 91       	pop	r28
    1322:	ff 90       	pop	r15
    1324:	ef 90       	pop	r14
    1326:	df 90       	pop	r13
    1328:	cf 90       	pop	r12
    132a:	bf 90       	pop	r11
    132c:	af 90       	pop	r10
    132e:	9f 90       	pop	r9
    1330:	8f 90       	pop	r8
    1332:	08 95       	ret

00001334 <Angle_values>:

void Angle_values(float *X,float *Y)
{
    1334:	2f 92       	push	r2
    1336:	3f 92       	push	r3
    1338:	4f 92       	push	r4
    133a:	5f 92       	push	r5
    133c:	6f 92       	push	r6
    133e:	7f 92       	push	r7
    1340:	8f 92       	push	r8
    1342:	9f 92       	push	r9
    1344:	af 92       	push	r10
    1346:	bf 92       	push	r11
    1348:	cf 92       	push	r12
    134a:	df 92       	push	r13
    134c:	ef 92       	push	r14
    134e:	ff 92       	push	r15
    1350:	0f 93       	push	r16
    1352:	1f 93       	push	r17
    1354:	cf 93       	push	r28
    1356:	df 93       	push	r29
    1358:	cd b7       	in	r28, 0x3d	; 61
    135a:	de b7       	in	r29, 0x3e	; 62
    135c:	6d 97       	sbiw	r28, 0x1d	; 29
    135e:	0f b6       	in	r0, 0x3f	; 63
    1360:	f8 94       	cli
    1362:	de bf       	out	0x3e, r29	; 62
    1364:	0f be       	out	0x3f, r0	; 63
    1366:	cd bf       	out	0x3d, r28	; 61
    1368:	9b 8b       	std	Y+19, r25	; 0x13
    136a:	8a 8b       	std	Y+18, r24	; 0x12
    136c:	7d 8b       	std	Y+21, r23	; 0x15
    136e:	6c 8b       	std	Y+20, r22	; 0x14
	float GYX=0,GYY=0,GYZ=0;
	int gyx,gyy,gyz,acx,acy,acz;
	GYRO_READ(&gyx,&gyy,&gyz);
    1370:	ce 01       	movw	r24, r28
    1372:	01 96       	adiw	r24, 0x01	; 1
    1374:	be 01       	movw	r22, r28
    1376:	6d 5f       	subi	r22, 0xFD	; 253
    1378:	7f 4f       	sbci	r23, 0xFF	; 255
    137a:	ae 01       	movw	r20, r28
    137c:	4b 5f       	subi	r20, 0xFB	; 251
    137e:	5f 4f       	sbci	r21, 0xFF	; 255
    1380:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <GYRO_READ>
	ACC_READ(&acx,&acy,&acz);
    1384:	ce 01       	movw	r24, r28
    1386:	07 96       	adiw	r24, 0x07	; 7
    1388:	be 01       	movw	r22, r28
    138a:	67 5f       	subi	r22, 0xF7	; 247
    138c:	7f 4f       	sbci	r23, 0xFF	; 255
    138e:	ae 01       	movw	r20, r28
    1390:	45 5f       	subi	r20, 0xF5	; 245
    1392:	5f 4f       	sbci	r21, 0xFF	; 255
    1394:	0e 94 45 04 	call	0x88a	; 0x88a <ACC_READ>
	GYX=(float)(gyx-GYRO_XOUT_OFFSET)/GYRO_FACTOR;
    1398:	69 81       	ldd	r22, Y+1	; 0x01
    139a:	7a 81       	ldd	r23, Y+2	; 0x02
    139c:	88 27       	eor	r24, r24
    139e:	77 fd       	sbrc	r23, 7
    13a0:	80 95       	com	r24
    13a2:	98 2f       	mov	r25, r24
    13a4:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <__floatsisf>
    13a8:	20 91 64 02 	lds	r18, 0x0264
    13ac:	30 91 65 02 	lds	r19, 0x0265
    13b0:	40 91 66 02 	lds	r20, 0x0266
    13b4:	50 91 67 02 	lds	r21, 0x0267
    13b8:	0e 94 55 0e 	call	0x1caa	; 0x1caa <__subsf3>
    13bc:	20 e0       	ldi	r18, 0x00	; 0
    13be:	30 e0       	ldi	r19, 0x00	; 0
    13c0:	43 e0       	ldi	r20, 0x03	; 3
    13c2:	53 e4       	ldi	r21, 0x43	; 67
    13c4:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <__divsf3>
    13c8:	6e 8b       	std	Y+22, r22	; 0x16
    13ca:	7f 8b       	std	Y+23, r23	; 0x17
    13cc:	88 8f       	std	Y+24, r24	; 0x18
    13ce:	99 8f       	std	Y+25, r25	; 0x19
	GYY=(float)(gyy-GYRO_YOUT_OFFSET)/GYRO_FACTOR;
    13d0:	6b 81       	ldd	r22, Y+3	; 0x03
    13d2:	7c 81       	ldd	r23, Y+4	; 0x04
    13d4:	88 27       	eor	r24, r24
    13d6:	77 fd       	sbrc	r23, 7
    13d8:	80 95       	com	r24
    13da:	98 2f       	mov	r25, r24
    13dc:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <__floatsisf>
    13e0:	20 91 60 02 	lds	r18, 0x0260
    13e4:	30 91 61 02 	lds	r19, 0x0261
    13e8:	40 91 62 02 	lds	r20, 0x0262
    13ec:	50 91 63 02 	lds	r21, 0x0263
    13f0:	0e 94 55 0e 	call	0x1caa	; 0x1caa <__subsf3>
    13f4:	20 e0       	ldi	r18, 0x00	; 0
    13f6:	30 e0       	ldi	r19, 0x00	; 0
    13f8:	43 e0       	ldi	r20, 0x03	; 3
    13fa:	53 e4       	ldi	r21, 0x43	; 67
    13fc:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <__divsf3>
    1400:	6a 8f       	std	Y+26, r22	; 0x1a
    1402:	7b 8f       	std	Y+27, r23	; 0x1b
    1404:	8c 8f       	std	Y+28, r24	; 0x1c
    1406:	9d 8f       	std	Y+29, r25	; 0x1d
	GYZ=(float)(gyz-GYRO_ZOUT_OFFSET)/GYRO_FACTOR;
	float dt = (float)(millis()-timer)/1000 ;
    1408:	0e 94 b1 06 	call	0xd62	; 0xd62 <millis>
    140c:	e2 2f       	mov	r30, r18
    140e:	f3 2f       	mov	r31, r19
    1410:	00 91 68 02 	lds	r16, 0x0268
    1414:	10 91 69 02 	lds	r17, 0x0269
    1418:	20 91 6a 02 	lds	r18, 0x026A
    141c:	30 91 6b 02 	lds	r19, 0x026B
    1420:	48 01       	movw	r8, r16
    1422:	59 01       	movw	r10, r18
    1424:	2e 2f       	mov	r18, r30
    1426:	28 19       	sub	r18, r8
    1428:	31 e0       	ldi	r19, 0x01	; 1
    142a:	e2 17       	cp	r30, r18
    142c:	08 f0       	brcs	.+2      	; 0x1430 <Angle_values+0xfc>
    142e:	30 e0       	ldi	r19, 0x00	; 0
    1430:	ef 2f       	mov	r30, r31
    1432:	e9 19       	sub	r30, r9
    1434:	a1 e0       	ldi	r26, 0x01	; 1
    1436:	fe 17       	cp	r31, r30
    1438:	08 f0       	brcs	.+2      	; 0x143c <Angle_values+0x108>
    143a:	a0 e0       	ldi	r26, 0x00	; 0
    143c:	fe 2f       	mov	r31, r30
    143e:	f3 1b       	sub	r31, r19
    1440:	3f 2f       	mov	r19, r31
    1442:	f1 e0       	ldi	r31, 0x01	; 1
    1444:	e3 17       	cp	r30, r19
    1446:	08 f0       	brcs	.+2      	; 0x144a <Angle_values+0x116>
    1448:	f0 e0       	ldi	r31, 0x00	; 0
    144a:	af 2b       	or	r26, r31
    144c:	f4 2f       	mov	r31, r20
    144e:	fa 19       	sub	r31, r10
    1450:	e1 e0       	ldi	r30, 0x01	; 1
    1452:	4f 17       	cp	r20, r31
    1454:	08 f0       	brcs	.+2      	; 0x1458 <Angle_values+0x124>
    1456:	e0 e0       	ldi	r30, 0x00	; 0
    1458:	4f 2f       	mov	r20, r31
    145a:	4a 1b       	sub	r20, r26
    145c:	a1 e0       	ldi	r26, 0x01	; 1
    145e:	f4 17       	cp	r31, r20
    1460:	08 f0       	brcs	.+2      	; 0x1464 <Angle_values+0x130>
    1462:	a0 e0       	ldi	r26, 0x00	; 0
    1464:	ea 2b       	or	r30, r26
    1466:	a5 2f       	mov	r26, r21
    1468:	ab 19       	sub	r26, r11
    146a:	f1 e0       	ldi	r31, 0x01	; 1
    146c:	5a 17       	cp	r21, r26
    146e:	08 f0       	brcs	.+2      	; 0x1472 <Angle_values+0x13e>
    1470:	f0 e0       	ldi	r31, 0x00	; 0
    1472:	5a 2f       	mov	r21, r26
    1474:	5e 1b       	sub	r21, r30
    1476:	e1 e0       	ldi	r30, 0x01	; 1
    1478:	a5 17       	cp	r26, r21
    147a:	08 f0       	brcs	.+2      	; 0x147e <Angle_values+0x14a>
    147c:	e0 e0       	ldi	r30, 0x00	; 0
    147e:	fe 2b       	or	r31, r30
    1480:	a6 2f       	mov	r26, r22
    1482:	e0 e0       	ldi	r30, 0x00	; 0
    1484:	6f 1b       	sub	r22, r31
    1486:	f1 e0       	ldi	r31, 0x01	; 1
    1488:	a6 17       	cp	r26, r22
    148a:	08 f0       	brcs	.+2      	; 0x148e <Angle_values+0x15a>
    148c:	f0 e0       	ldi	r31, 0x00	; 0
    148e:	ef 2b       	or	r30, r31
    1490:	a7 2f       	mov	r26, r23
    1492:	f0 e0       	ldi	r31, 0x00	; 0
    1494:	7e 1b       	sub	r23, r30
    1496:	e1 e0       	ldi	r30, 0x01	; 1
    1498:	a7 17       	cp	r26, r23
    149a:	08 f0       	brcs	.+2      	; 0x149e <Angle_values+0x16a>
    149c:	e0 e0       	ldi	r30, 0x00	; 0
    149e:	fe 2b       	or	r31, r30
    14a0:	a8 2f       	mov	r26, r24
    14a2:	e0 e0       	ldi	r30, 0x00	; 0
    14a4:	8f 1b       	sub	r24, r31
    14a6:	f1 e0       	ldi	r31, 0x01	; 1
    14a8:	a8 17       	cp	r26, r24
    14aa:	08 f0       	brcs	.+2      	; 0x14ae <Angle_values+0x17a>
    14ac:	f0 e0       	ldi	r31, 0x00	; 0
    14ae:	ef 2b       	or	r30, r31
    14b0:	9e 1b       	sub	r25, r30
    14b2:	0e 94 ed 0f 	call	0x1fda	; 0x1fda <__floatundisf>
    14b6:	20 e0       	ldi	r18, 0x00	; 0
    14b8:	30 e0       	ldi	r19, 0x00	; 0
    14ba:	4a e7       	ldi	r20, 0x7A	; 122
    14bc:	54 e4       	ldi	r21, 0x44	; 68
    14be:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <__divsf3>
    14c2:	c6 2e       	mov	r12, r22
    14c4:	37 2e       	mov	r3, r23
    14c6:	28 2e       	mov	r2, r24
    14c8:	9d 87       	std	Y+13, r25	; 0x0d
	timer = millis();
    14ca:	0e 94 b1 06 	call	0xd62	; 0xd62 <millis>
    14ce:	20 93 68 02 	sts	0x0268, r18
    14d2:	30 93 69 02 	sts	0x0269, r19
    14d6:	40 93 6a 02 	sts	0x026A, r20
    14da:	50 93 6b 02 	sts	0x026B, r21
	float roll=atan2(acy,acz)*RAD_TO_DEG;
    14de:	6b 85       	ldd	r22, Y+11	; 0x0b
    14e0:	7c 85       	ldd	r23, Y+12	; 0x0c
    14e2:	88 27       	eor	r24, r24
    14e4:	77 fd       	sbrc	r23, 7
    14e6:	80 95       	com	r24
    14e8:	98 2f       	mov	r25, r24
    14ea:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <__floatsisf>
    14ee:	4b 01       	movw	r8, r22
    14f0:	5c 01       	movw	r10, r24
    14f2:	69 85       	ldd	r22, Y+9	; 0x09
    14f4:	7a 85       	ldd	r23, Y+10	; 0x0a
    14f6:	88 27       	eor	r24, r24
    14f8:	77 fd       	sbrc	r23, 7
    14fa:	80 95       	com	r24
    14fc:	98 2f       	mov	r25, r24
    14fe:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <__floatsisf>
    1502:	a5 01       	movw	r20, r10
    1504:	94 01       	movw	r18, r8
    1506:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <atan2>
    150a:	2b 01       	movw	r4, r22
    150c:	3c 01       	movw	r6, r24
	float pitch=atan2(-acx,acz)*RAD_TO_DEG;
    150e:	6f 81       	ldd	r22, Y+7	; 0x07
    1510:	78 85       	ldd	r23, Y+8	; 0x08
    1512:	70 95       	com	r23
    1514:	61 95       	neg	r22
    1516:	7f 4f       	sbci	r23, 0xFF	; 255
    1518:	88 27       	eor	r24, r24
    151a:	77 fd       	sbrc	r23, 7
    151c:	80 95       	com	r24
    151e:	98 2f       	mov	r25, r24
    1520:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <__floatsisf>
    1524:	a5 01       	movw	r20, r10
    1526:	94 01       	movw	r18, r8
    1528:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <atan2>
    152c:	6e 87       	std	Y+14, r22	; 0x0e
    152e:	7f 87       	std	Y+15, r23	; 0x0f
    1530:	88 8b       	std	Y+16, r24	; 0x10
    1532:	99 8b       	std	Y+17, r25	; 0x11
	compAngleX = 0.7 * (compAngleX + GYX * dt) + 0.3 * roll; // Calculate the angle using a Complimentary filter
    1534:	5e 89       	ldd	r21, Y+22	; 0x16
    1536:	4f 89       	ldd	r20, Y+23	; 0x17
    1538:	38 8d       	ldd	r19, Y+24	; 0x18
    153a:	29 8d       	ldd	r18, Y+25	; 0x19
    153c:	85 2f       	mov	r24, r21
    153e:	94 2f       	mov	r25, r20
    1540:	a3 2f       	mov	r26, r19
    1542:	b2 2f       	mov	r27, r18
    1544:	bc 01       	movw	r22, r24
    1546:	cd 01       	movw	r24, r26
    1548:	4d 85       	ldd	r20, Y+13	; 0x0d
    154a:	0c 2d       	mov	r16, r12
    154c:	13 2d       	mov	r17, r3
    154e:	22 2d       	mov	r18, r2
    1550:	34 2f       	mov	r19, r20
    1552:	a9 01       	movw	r20, r18
    1554:	98 01       	movw	r18, r16
    1556:	0e 94 a8 10 	call	0x2150	; 0x2150 <__mulsf3>
    155a:	20 91 6c 02 	lds	r18, 0x026C
    155e:	30 91 6d 02 	lds	r19, 0x026D
    1562:	40 91 6e 02 	lds	r20, 0x026E
    1566:	50 91 6f 02 	lds	r21, 0x026F
    156a:	0e 94 56 0e 	call	0x1cac	; 0x1cac <__addsf3>
    156e:	23 e3       	ldi	r18, 0x33	; 51
    1570:	33 e3       	ldi	r19, 0x33	; 51
    1572:	43 e3       	ldi	r20, 0x33	; 51
    1574:	5f e3       	ldi	r21, 0x3F	; 63
    1576:	0e 94 a8 10 	call	0x2150	; 0x2150 <__mulsf3>
    157a:	4b 01       	movw	r8, r22
    157c:	5c 01       	movw	r10, r24
	GYX=(float)(gyx-GYRO_XOUT_OFFSET)/GYRO_FACTOR;
	GYY=(float)(gyy-GYRO_YOUT_OFFSET)/GYRO_FACTOR;
	GYZ=(float)(gyz-GYRO_ZOUT_OFFSET)/GYRO_FACTOR;
	float dt = (float)(millis()-timer)/1000 ;
	timer = millis();
	float roll=atan2(acy,acz)*RAD_TO_DEG;
    157e:	c3 01       	movw	r24, r6
    1580:	b2 01       	movw	r22, r4
    1582:	20 e0       	ldi	r18, 0x00	; 0
    1584:	30 e0       	ldi	r19, 0x00	; 0
    1586:	44 e3       	ldi	r20, 0x34	; 52
    1588:	53 e4       	ldi	r21, 0x43	; 67
    158a:	0e 94 a8 10 	call	0x2150	; 0x2150 <__mulsf3>
    158e:	2b ed       	ldi	r18, 0xDB	; 219
    1590:	3f e0       	ldi	r19, 0x0F	; 15
    1592:	49 e4       	ldi	r20, 0x49	; 73
    1594:	50 e4       	ldi	r21, 0x40	; 64
    1596:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <__divsf3>
	float pitch=atan2(-acx,acz)*RAD_TO_DEG;
	compAngleX = 0.7 * (compAngleX + GYX * dt) + 0.3 * roll; // Calculate the angle using a Complimentary filter
    159a:	2a e9       	ldi	r18, 0x9A	; 154
    159c:	39 e9       	ldi	r19, 0x99	; 153
    159e:	49 e9       	ldi	r20, 0x99	; 153
    15a0:	5e e3       	ldi	r21, 0x3E	; 62
    15a2:	0e 94 a8 10 	call	0x2150	; 0x2150 <__mulsf3>
    15a6:	9b 01       	movw	r18, r22
    15a8:	ac 01       	movw	r20, r24
    15aa:	c5 01       	movw	r24, r10
    15ac:	b4 01       	movw	r22, r8
    15ae:	0e 94 56 0e 	call	0x1cac	; 0x1cac <__addsf3>
    15b2:	86 2e       	mov	r8, r22
    15b4:	f7 2e       	mov	r15, r23
    15b6:	e8 2e       	mov	r14, r24
    15b8:	d9 2e       	mov	r13, r25
    15ba:	86 2f       	mov	r24, r22
    15bc:	9f 2d       	mov	r25, r15
    15be:	ae 2d       	mov	r26, r14
    15c0:	bd 2d       	mov	r27, r13
    15c2:	80 93 6c 02 	sts	0x026C, r24
    15c6:	90 93 6d 02 	sts	0x026D, r25
    15ca:	a0 93 6e 02 	sts	0x026E, r26
    15ce:	b0 93 6f 02 	sts	0x026F, r27
	compAngleY = 0.7 * (compAngleY + GYY * dt) + 0.3 * pitch;
    15d2:	5a 8d       	ldd	r21, Y+26	; 0x1a
    15d4:	4b 8d       	ldd	r20, Y+27	; 0x1b
    15d6:	3c 8d       	ldd	r19, Y+28	; 0x1c
    15d8:	2d 8d       	ldd	r18, Y+29	; 0x1d
    15da:	85 2f       	mov	r24, r21
    15dc:	94 2f       	mov	r25, r20
    15de:	a3 2f       	mov	r26, r19
    15e0:	b2 2f       	mov	r27, r18
    15e2:	bc 01       	movw	r22, r24
    15e4:	cd 01       	movw	r24, r26
    15e6:	4d 85       	ldd	r20, Y+13	; 0x0d
    15e8:	22 2d       	mov	r18, r2
    15ea:	34 2f       	mov	r19, r20
    15ec:	a9 01       	movw	r20, r18
    15ee:	98 01       	movw	r18, r16
    15f0:	0e 94 a8 10 	call	0x2150	; 0x2150 <__mulsf3>
    15f4:	20 91 78 02 	lds	r18, 0x0278
    15f8:	30 91 79 02 	lds	r19, 0x0279
    15fc:	40 91 7a 02 	lds	r20, 0x027A
    1600:	50 91 7b 02 	lds	r21, 0x027B
    1604:	0e 94 56 0e 	call	0x1cac	; 0x1cac <__addsf3>
    1608:	23 e3       	ldi	r18, 0x33	; 51
    160a:	33 e3       	ldi	r19, 0x33	; 51
    160c:	43 e3       	ldi	r20, 0x33	; 51
    160e:	5f e3       	ldi	r21, 0x3F	; 63
    1610:	0e 94 a8 10 	call	0x2150	; 0x2150 <__mulsf3>
    1614:	2b 01       	movw	r4, r22
    1616:	3c 01       	movw	r6, r24
	GYY=(float)(gyy-GYRO_YOUT_OFFSET)/GYRO_FACTOR;
	GYZ=(float)(gyz-GYRO_ZOUT_OFFSET)/GYRO_FACTOR;
	float dt = (float)(millis()-timer)/1000 ;
	timer = millis();
	float roll=atan2(acy,acz)*RAD_TO_DEG;
	float pitch=atan2(-acx,acz)*RAD_TO_DEG;
    1618:	6e 85       	ldd	r22, Y+14	; 0x0e
    161a:	7f 85       	ldd	r23, Y+15	; 0x0f
    161c:	88 89       	ldd	r24, Y+16	; 0x10
    161e:	99 89       	ldd	r25, Y+17	; 0x11
    1620:	20 e0       	ldi	r18, 0x00	; 0
    1622:	30 e0       	ldi	r19, 0x00	; 0
    1624:	44 e3       	ldi	r20, 0x34	; 52
    1626:	53 e4       	ldi	r21, 0x43	; 67
    1628:	0e 94 a8 10 	call	0x2150	; 0x2150 <__mulsf3>
    162c:	2b ed       	ldi	r18, 0xDB	; 219
    162e:	3f e0       	ldi	r19, 0x0F	; 15
    1630:	49 e4       	ldi	r20, 0x49	; 73
    1632:	50 e4       	ldi	r21, 0x40	; 64
    1634:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <__divsf3>
	compAngleX = 0.7 * (compAngleX + GYX * dt) + 0.3 * roll; // Calculate the angle using a Complimentary filter
	compAngleY = 0.7 * (compAngleY + GYY * dt) + 0.3 * pitch;
    1638:	2a e9       	ldi	r18, 0x9A	; 154
    163a:	39 e9       	ldi	r19, 0x99	; 153
    163c:	49 e9       	ldi	r20, 0x99	; 153
    163e:	5e e3       	ldi	r21, 0x3E	; 62
    1640:	0e 94 a8 10 	call	0x2150	; 0x2150 <__mulsf3>
    1644:	9b 01       	movw	r18, r22
    1646:	ac 01       	movw	r20, r24
    1648:	c3 01       	movw	r24, r6
    164a:	b2 01       	movw	r22, r4
    164c:	0e 94 56 0e 	call	0x1cac	; 0x1cac <__addsf3>
    1650:	dc 01       	movw	r26, r24
    1652:	cb 01       	movw	r24, r22
    1654:	80 93 78 02 	sts	0x0278, r24
    1658:	90 93 79 02 	sts	0x0279, r25
    165c:	a0 93 7a 02 	sts	0x027A, r26
    1660:	b0 93 7b 02 	sts	0x027B, r27
	*X = compAngleX;
    1664:	88 2d       	mov	r24, r8
    1666:	9f 2d       	mov	r25, r15
    1668:	ae 2d       	mov	r26, r14
    166a:	bd 2d       	mov	r27, r13
    166c:	ea 89       	ldd	r30, Y+18	; 0x12
    166e:	fb 89       	ldd	r31, Y+19	; 0x13
    1670:	80 83       	st	Z, r24
    1672:	91 83       	std	Z+1, r25	; 0x01
    1674:	a2 83       	std	Z+2, r26	; 0x02
    1676:	b3 83       	std	Z+3, r27	; 0x03
	*Y = compAngleY;
    1678:	80 91 78 02 	lds	r24, 0x0278
    167c:	90 91 79 02 	lds	r25, 0x0279
    1680:	a0 91 7a 02 	lds	r26, 0x027A
    1684:	b0 91 7b 02 	lds	r27, 0x027B
    1688:	ec 89       	ldd	r30, Y+20	; 0x14
    168a:	fd 89       	ldd	r31, Y+21	; 0x15
    168c:	80 83       	st	Z, r24
    168e:	91 83       	std	Z+1, r25	; 0x01
    1690:	a2 83       	std	Z+2, r26	; 0x02
    1692:	b3 83       	std	Z+3, r27	; 0x03
    1694:	6d 96       	adiw	r28, 0x1d	; 29
    1696:	0f b6       	in	r0, 0x3f	; 63
    1698:	f8 94       	cli
    169a:	de bf       	out	0x3e, r29	; 62
    169c:	0f be       	out	0x3f, r0	; 63
    169e:	cd bf       	out	0x3d, r28	; 61
    16a0:	df 91       	pop	r29
    16a2:	cf 91       	pop	r28
    16a4:	1f 91       	pop	r17
    16a6:	0f 91       	pop	r16
    16a8:	ff 90       	pop	r15
    16aa:	ef 90       	pop	r14
    16ac:	df 90       	pop	r13
    16ae:	cf 90       	pop	r12
    16b0:	bf 90       	pop	r11
    16b2:	af 90       	pop	r10
    16b4:	9f 90       	pop	r9
    16b6:	8f 90       	pop	r8
    16b8:	7f 90       	pop	r7
    16ba:	6f 90       	pop	r6
    16bc:	5f 90       	pop	r5
    16be:	4f 90       	pop	r4
    16c0:	3f 90       	pop	r3
    16c2:	2f 90       	pop	r2
    16c4:	08 95       	ret

000016c6 <setup>:
#include "Servo1.c"
#include "Angle_calc.c"

void setup()
{
	uart0_init();
    16c6:	0e 94 26 02 	call	0x44c	; 0x44c <uart0_init>
	lcd_init();
    16ca:	0e 94 1d 01 	call	0x23a	; 0x23a <lcd_init>
	MPU6050_init();
    16ce:	0e 94 9a 04 	call	0x934	; 0x934 <MPU6050_init>
	millis_init();
    16d2:	0e 94 25 06 	call	0xc4a	; 0xc4a <millis_init>
	adc_init();
    16d6:	0e 94 d6 06 	call	0xdac	; 0xdac <adc_init>
	motor_control_init();
    16da:	0e 94 33 07 	call	0xe66	; 0xe66 <motor_control_init>
	timer5_init();
    16de:	0e 94 9d 08 	call	0x113a	; 0x113a <timer5_init>
////////////////////////	TCS3200_init();
	init_servo();
    16e2:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <init_servo>
	Angle_setup();
    16e6:	0e 94 00 09 	call	0x1200	; 0x1200 <Angle_setup>
}
    16ea:	08 95       	ret

000016ec <Right_90>:

void Right_90()
{
	velocity(FAST,FAST);
    16ec:	88 ec       	ldi	r24, 0xC8	; 200
    16ee:	90 e0       	ldi	r25, 0x00	; 0
    16f0:	68 ec       	ldi	r22, 0xC8	; 200
    16f2:	70 e0       	ldi	r23, 0x00	; 0
    16f4:	0e 94 b2 08 	call	0x1164	; 0x1164 <velocity>
	forward_mm(65);
    16f8:	81 e4       	ldi	r24, 0x41	; 65
    16fa:	90 e0       	ldi	r25, 0x00	; 0
    16fc:	0e 94 35 08 	call	0x106a	; 0x106a <forward_mm>
	right_degrees(90);
    1700:	8a e5       	ldi	r24, 0x5A	; 90
    1702:	90 e0       	ldi	r25, 0x00	; 0
    1704:	0e 94 56 08 	call	0x10ac	; 0x10ac <right_degrees>
}
    1708:	08 95       	ret

0000170a <left_90>:

void left_90()
{
	velocity(FAST,FAST);
    170a:	88 ec       	ldi	r24, 0xC8	; 200
    170c:	90 e0       	ldi	r25, 0x00	; 0
    170e:	68 ec       	ldi	r22, 0xC8	; 200
    1710:	70 e0       	ldi	r23, 0x00	; 0
    1712:	0e 94 b2 08 	call	0x1164	; 0x1164 <velocity>
	forward_mm(65);
    1716:	81 e4       	ldi	r24, 0x41	; 65
    1718:	90 e0       	ldi	r25, 0x00	; 0
    171a:	0e 94 35 08 	call	0x106a	; 0x106a <forward_mm>
	left_degrees(90);
    171e:	8a e5       	ldi	r24, 0x5A	; 90
    1720:	90 e0       	ldi	r25, 0x00	; 0
    1722:	0e 94 4b 08 	call	0x1096	; 0x1096 <left_degrees>
}
    1726:	08 95       	ret

00001728 <U_turn>:

void U_turn()
{
	velocity(FAST,FAST);
    1728:	88 ec       	ldi	r24, 0xC8	; 200
    172a:	90 e0       	ldi	r25, 0x00	; 0
    172c:	68 ec       	ldi	r22, 0xC8	; 200
    172e:	70 e0       	ldi	r23, 0x00	; 0
    1730:	0e 94 b2 08 	call	0x1164	; 0x1164 <velocity>
	forward_mm(65);
    1734:	81 e4       	ldi	r24, 0x41	; 65
    1736:	90 e0       	ldi	r25, 0x00	; 0
    1738:	0e 94 35 08 	call	0x106a	; 0x106a <forward_mm>
	right();
    173c:	0e 94 9a 07 	call	0xf34	; 0xf34 <right>
	angle_rotate(180);
    1740:	84 eb       	ldi	r24, 0xB4	; 180
    1742:	90 e0       	ldi	r25, 0x00	; 0
    1744:	0e 94 b2 07 	call	0xf64	; 0xf64 <angle_rotate>
}
    1748:	08 95       	ret

0000174a <loop>:

void loop()
{
    174a:	2f 92       	push	r2
    174c:	3f 92       	push	r3
    174e:	4f 92       	push	r4
    1750:	5f 92       	push	r5
    1752:	6f 92       	push	r6
    1754:	7f 92       	push	r7
    1756:	8f 92       	push	r8
    1758:	9f 92       	push	r9
    175a:	af 92       	push	r10
    175c:	bf 92       	push	r11
    175e:	cf 92       	push	r12
    1760:	df 92       	push	r13
    1762:	ef 92       	push	r14
    1764:	ff 92       	push	r15
    1766:	0f 93       	push	r16
    1768:	1f 93       	push	r17
    176a:	cf 93       	push	r28
    176c:	df 93       	push	r29
    176e:	cd b7       	in	r28, 0x3d	; 61
    1770:	de b7       	in	r29, 0x3e	; 62
    1772:	ae 97       	sbiw	r28, 0x2e	; 46
    1774:	0f b6       	in	r0, 0x3f	; 63
    1776:	f8 94       	cli
    1778:	de bf       	out	0x3e, r29	; 62
    177a:	0f be       	out	0x3f, r0	; 63
    177c:	cd bf       	out	0x3d, r28	; 61
				_delay_ms(2000);
	//			COL2 = colorDetect();
				servo_1(0);
				_delay_ms(100);
			}
			snprintf(dataC,sizeof(dataC),"C:%03d,%03d,%c,%c",SSM,SSF,COL1,COL2);
    177e:	0f 2e       	mov	r0, r31
    1780:	f9 e0       	ldi	r31, 0x09	; 9
    1782:	2f 2e       	mov	r2, r31
    1784:	33 24       	eor	r3, r3
    1786:	f0 2d       	mov	r31, r0
    1788:	2c 0e       	add	r2, r28
    178a:	3d 1e       	adc	r3, r29
	{
		char NOD='0',COL1='0',COL2='0',INST;
		int SSM=0,SSF=0,ADC1,ADC2,ADC3,L_S,M_S,R_S,IR2,IR3,IR4;
		float AX,AY;
		
		forward();								//Initiating the robot
    178c:	0e 94 8e 07 	call	0xf1c	; 0xf1c <forward>
		velocity(VERY_FAST,VERY_FAST);
    1790:	8a ef       	ldi	r24, 0xFA	; 250
    1792:	90 e0       	ldi	r25, 0x00	; 0
    1794:	6a ef       	ldi	r22, 0xFA	; 250
    1796:	70 e0       	ldi	r23, 0x00	; 0
    1798:	0e 94 b2 08 	call	0x1164	; 0x1164 <velocity>
		
		Angle_values(&AX,&AY);					//Getting Euler angles about X and Y axis
    179c:	ce 01       	movw	r24, r28
    179e:	05 96       	adiw	r24, 0x05	; 5
    17a0:	be 01       	movw	r22, r28
    17a2:	6f 5f       	subi	r22, 0xFF	; 255
    17a4:	7f 4f       	sbci	r23, 0xFF	; 255
    17a6:	0e 94 9a 09 	call	0x1334	; 0x1334 <Angle_values>
		ADC1=ADC_conversion(3);					//White line sensor 1 readings	
    17aa:	83 e0       	ldi	r24, 0x03	; 3
    17ac:	90 e0       	ldi	r25, 0x00	; 0
    17ae:	0e 94 db 06 	call	0xdb6	; 0xdb6 <ADC_conversion>
    17b2:	8c 01       	movw	r16, r24
		ADC2=ADC_conversion(2);					//White line sensor 2 readings
    17b4:	82 e0       	ldi	r24, 0x02	; 2
    17b6:	90 e0       	ldi	r25, 0x00	; 0
    17b8:	0e 94 db 06 	call	0xdb6	; 0xdb6 <ADC_conversion>
    17bc:	5c 01       	movw	r10, r24
		ADC3=ADC_conversion(1);					//White line sensor 3 readings
    17be:	81 e0       	ldi	r24, 0x01	; 1
    17c0:	90 e0       	ldi	r25, 0x00	; 0
    17c2:	0e 94 db 06 	call	0xdb6	; 0xdb6 <ADC_conversion>
    17c6:	3c 01       	movw	r6, r24
		SSM = ADC_conversion(9);				//Sharp sensor movable readings
    17c8:	89 e0       	ldi	r24, 0x09	; 9
    17ca:	90 e0       	ldi	r25, 0x00	; 0
    17cc:	0e 94 db 06 	call	0xdb6	; 0xdb6 <ADC_conversion>
    17d0:	2c 01       	movw	r4, r24
		SSF = ADC_conversion(13);				//Sharp sensor fixed readings
    17d2:	8d e0       	ldi	r24, 0x0D	; 13
    17d4:	90 e0       	ldi	r25, 0x00	; 0
    17d6:	0e 94 db 06 	call	0xdb6	; 0xdb6 <ADC_conversion>
    17da:	98 a7       	lds	r25, 0x78
    17dc:	8f a3       	lds	r24, 0x5f
		IR2 = ADC_conversion(5);				//IR sensor 2 readings
    17de:	85 e0       	ldi	r24, 0x05	; 5
    17e0:	90 e0       	ldi	r25, 0x00	; 0
    17e2:	0e 94 db 06 	call	0xdb6	; 0xdb6 <ADC_conversion>
    17e6:	9a a7       	lds	r25, 0x7a
    17e8:	89 a7       	lds	r24, 0x79
		IR3 = ADC_conversion(6);				//IR sensor 3 readings
    17ea:	86 e0       	ldi	r24, 0x06	; 6
    17ec:	90 e0       	ldi	r25, 0x00	; 0
    17ee:	0e 94 db 06 	call	0xdb6	; 0xdb6 <ADC_conversion>
    17f2:	9c a7       	lds	r25, 0x7c
    17f4:	8b a7       	lds	r24, 0x7b
		IR4 = ADC_conversion(7);				//IR sensor 4 readings
    17f6:	87 e0       	ldi	r24, 0x07	; 7
    17f8:	90 e0       	ldi	r25, 0x00	; 0
    17fa:	0e 94 db 06 	call	0xdb6	; 0xdb6 <ADC_conversion>
    17fe:	9e a7       	lds	r25, 0x7e
    1800:	8d a7       	lds	r24, 0x7d

		
		if(ADC1>LINE_THRESHOLD)
			L_S=0;
    1802:	ee 24       	eor	r14, r14
    1804:	ff 24       	eor	r15, r15
    1806:	e3 94       	inc	r14
    1808:	0b 30       	cpi	r16, 0x0B	; 11
    180a:	11 05       	cpc	r17, r1
    180c:	14 f0       	brlt	.+4      	; 0x1812 <loop+0xc8>
    180e:	ee 24       	eor	r14, r14
    1810:	ff 24       	eor	r15, r15
		else
			L_S=1;
		
		if(ADC2>LINE_THRESHOLD)
			M_S=0;
    1812:	cc 24       	eor	r12, r12
    1814:	dd 24       	eor	r13, r13
    1816:	c3 94       	inc	r12
    1818:	8b e0       	ldi	r24, 0x0B	; 11
    181a:	a8 16       	cp	r10, r24
    181c:	b1 04       	cpc	r11, r1
    181e:	14 f0       	brlt	.+4      	; 0x1824 <loop+0xda>
    1820:	cc 24       	eor	r12, r12
    1822:	dd 24       	eor	r13, r13
		else
			M_S=1;
		
		if(ADC3>LINE_THRESHOLD)
			R_S=0;
    1824:	88 24       	eor	r8, r8
    1826:	99 24       	eor	r9, r9
    1828:	83 94       	inc	r8
    182a:	9b e0       	ldi	r25, 0x0B	; 11
    182c:	69 16       	cp	r6, r25
    182e:	71 04       	cpc	r7, r1
    1830:	14 f0       	brlt	.+4      	; 0x1836 <loop+0xec>
    1832:	88 24       	eor	r8, r8
    1834:	99 24       	eor	r9, r9
		else
			R_S=1;
		
		if(SSM>SS_THRESHOLD)
			SSM=1;
    1836:	aa 24       	eor	r10, r10
    1838:	bb 24       	eor	r11, r11
    183a:	a3 94       	inc	r10
    183c:	ab e5       	ldi	r26, 0x5B	; 91
    183e:	4a 16       	cp	r4, r26
    1840:	51 04       	cpc	r5, r1
    1842:	14 f4       	brge	.+4      	; 0x1848 <loop+0xfe>
    1844:	aa 24       	eor	r10, r10
    1846:	bb 24       	eor	r11, r11
		else 
			SSM=0;
			
		if(SSF>SS_THRESHOLD)
			SSF=1;
    1848:	01 e0       	ldi	r16, 0x01	; 1
    184a:	10 e0       	ldi	r17, 0x00	; 0
    184c:	8f a1       	lds	r24, 0x4f
    184e:	98 a5       	lds	r25, 0x68
    1850:	8b 35       	cpi	r24, 0x5B	; 91
    1852:	91 05       	cpc	r25, r1
    1854:	14 f4       	brge	.+4      	; 0x185a <loop+0x110>
    1856:	00 e0       	ldi	r16, 0x00	; 0
    1858:	10 e0       	ldi	r17, 0x00	; 0
		else
			SSF=0;		
/********************SERVO AND COLOUR SENSOR PART********************/

		if(SSM==1 || SSF==1)				//checking for objects either sides
    185a:	91 e0       	ldi	r25, 0x01	; 1
    185c:	a9 16       	cp	r10, r25
    185e:	b1 04       	cpc	r11, r1
    1860:	09 f4       	brne	.+2      	; 0x1864 <loop+0x11a>
    1862:	ef c1       	rjmp	.+990    	; 0x1c42 <loop+0x4f8>
    1864:	01 30       	cpi	r16, 0x01	; 1
    1866:	11 05       	cpc	r17, r1
    1868:	09 f0       	breq	.+2      	; 0x186c <loop+0x122>
    186a:	a1 c0       	rjmp	.+322    	; 0x19ae <loop+0x264>
    186c:	8f ef       	ldi	r24, 0xFF	; 255
    186e:	9f e3       	ldi	r25, 0x3F	; 63
    1870:	a2 e0       	ldi	r26, 0x02	; 2
    1872:	81 50       	subi	r24, 0x01	; 1
    1874:	90 40       	sbci	r25, 0x00	; 0
    1876:	a0 40       	sbci	r26, 0x00	; 0
    1878:	e1 f7       	brne	.-8      	; 0x1872 <loop+0x128>
    187a:	00 c0       	rjmp	.+0      	; 0x187c <loop+0x132>
    187c:	00 00       	nop
		{
			char dataC[20];
			_delay_ms(50);
			Stop();
    187e:	0e 94 ae 07 	call	0xf5c	; 0xf5c <Stop>
			buzzer_on();
    1882:	0e 94 95 08 	call	0x112a	; 0x112a <buzzer_on>
    1886:	8f ef       	ldi	r24, 0xFF	; 255
    1888:	9f ef       	ldi	r25, 0xFF	; 255
    188a:	a8 e0       	ldi	r26, 0x08	; 8
    188c:	81 50       	subi	r24, 0x01	; 1
    188e:	90 40       	sbci	r25, 0x00	; 0
    1890:	a0 40       	sbci	r26, 0x00	; 0
    1892:	e1 f7       	brne	.-8      	; 0x188c <loop+0x142>
    1894:	00 c0       	rjmp	.+0      	; 0x1896 <loop+0x14c>
    1896:	00 00       	nop
			_delay_ms(200);
			buzzer_off();
    1898:	0e 94 99 08 	call	0x1132	; 0x1132 <buzzer_off>
			if(SSM==0 && SSF==1)		
    189c:	a1 14       	cp	r10, r1
    189e:	b1 04       	cpc	r11, r1
    18a0:	19 f5       	brne	.+70     	; 0x18e8 <loop+0x19e>
			{
				servo_1(180);
    18a2:	84 eb       	ldi	r24, 0xB4	; 180
    18a4:	0e 94 e7 08 	call	0x11ce	; 0x11ce <servo_1>
    18a8:	8f ef       	ldi	r24, 0xFF	; 255
    18aa:	9f ef       	ldi	r25, 0xFF	; 255
    18ac:	a9 e5       	ldi	r26, 0x59	; 89
    18ae:	81 50       	subi	r24, 0x01	; 1
    18b0:	90 40       	sbci	r25, 0x00	; 0
    18b2:	a0 40       	sbci	r26, 0x00	; 0
    18b4:	e1 f7       	brne	.-8      	; 0x18ae <loop+0x164>
    18b6:	00 c0       	rjmp	.+0      	; 0x18b8 <loop+0x16e>
    18b8:	00 00       	nop
				_delay_ms(2000);
	//			COL2 = colorDetect();
				servo_1(0);
    18ba:	80 e0       	ldi	r24, 0x00	; 0
    18bc:	0e 94 e7 08 	call	0x11ce	; 0x11ce <servo_1>
    18c0:	8f ef       	ldi	r24, 0xFF	; 255
    18c2:	9f e7       	ldi	r25, 0x7F	; 127
    18c4:	a4 e0       	ldi	r26, 0x04	; 4
    18c6:	81 50       	subi	r24, 0x01	; 1
    18c8:	90 40       	sbci	r25, 0x00	; 0
    18ca:	a0 40       	sbci	r26, 0x00	; 0
    18cc:	e1 f7       	brne	.-8      	; 0x18c6 <loop+0x17c>
    18ce:	00 c0       	rjmp	.+0      	; 0x18d0 <loop+0x186>
    18d0:	00 00       	nop
    18d2:	2b c0       	rjmp	.+86     	; 0x192a <loop+0x1e0>
    18d4:	8f ef       	ldi	r24, 0xFF	; 255
    18d6:	9f ef       	ldi	r25, 0xFF	; 255
    18d8:	a9 e5       	ldi	r26, 0x59	; 89
    18da:	81 50       	subi	r24, 0x01	; 1
    18dc:	90 40       	sbci	r25, 0x00	; 0
    18de:	a0 40       	sbci	r26, 0x00	; 0
    18e0:	e1 f7       	brne	.-8      	; 0x18da <loop+0x190>
    18e2:	00 c0       	rjmp	.+0      	; 0x18e4 <loop+0x19a>
    18e4:	00 00       	nop
    18e6:	21 c0       	rjmp	.+66     	; 0x192a <loop+0x1e0>
    18e8:	8f ef       	ldi	r24, 0xFF	; 255
    18ea:	9f ef       	ldi	r25, 0xFF	; 255
    18ec:	a9 e5       	ldi	r26, 0x59	; 89
    18ee:	81 50       	subi	r24, 0x01	; 1
    18f0:	90 40       	sbci	r25, 0x00	; 0
    18f2:	a0 40       	sbci	r26, 0x00	; 0
    18f4:	e1 f7       	brne	.-8      	; 0x18ee <loop+0x1a4>
    18f6:	00 c0       	rjmp	.+0      	; 0x18f8 <loop+0x1ae>
    18f8:	00 00       	nop
			
			else 
			{
				_delay_ms(2000);
	//			COL1 = colorDetect();
				servo_1(180);
    18fa:	84 eb       	ldi	r24, 0xB4	; 180
    18fc:	0e 94 e7 08 	call	0x11ce	; 0x11ce <servo_1>
    1900:	8f ef       	ldi	r24, 0xFF	; 255
    1902:	9f ef       	ldi	r25, 0xFF	; 255
    1904:	a9 e5       	ldi	r26, 0x59	; 89
    1906:	81 50       	subi	r24, 0x01	; 1
    1908:	90 40       	sbci	r25, 0x00	; 0
    190a:	a0 40       	sbci	r26, 0x00	; 0
    190c:	e1 f7       	brne	.-8      	; 0x1906 <loop+0x1bc>
    190e:	00 c0       	rjmp	.+0      	; 0x1910 <loop+0x1c6>
    1910:	00 00       	nop
				_delay_ms(2000);
	//			COL2 = colorDetect();
				servo_1(0);
    1912:	80 e0       	ldi	r24, 0x00	; 0
    1914:	0e 94 e7 08 	call	0x11ce	; 0x11ce <servo_1>
    1918:	8f ef       	ldi	r24, 0xFF	; 255
    191a:	9f e7       	ldi	r25, 0x7F	; 127
    191c:	a4 e0       	ldi	r26, 0x04	; 4
    191e:	81 50       	subi	r24, 0x01	; 1
    1920:	90 40       	sbci	r25, 0x00	; 0
    1922:	a0 40       	sbci	r26, 0x00	; 0
    1924:	e1 f7       	brne	.-8      	; 0x191e <loop+0x1d4>
    1926:	00 c0       	rjmp	.+0      	; 0x1928 <loop+0x1de>
    1928:	00 00       	nop
				_delay_ms(100);
			}
			snprintf(dataC,sizeof(dataC),"C:%03d,%03d,%c,%c",SSM,SSF,COL1,COL2);
    192a:	ad b7       	in	r26, 0x3d	; 61
    192c:	be b7       	in	r27, 0x3e	; 62
    192e:	1e 97       	sbiw	r26, 0x0e	; 14
    1930:	0f b6       	in	r0, 0x3f	; 63
    1932:	f8 94       	cli
    1934:	be bf       	out	0x3e, r27	; 62
    1936:	0f be       	out	0x3f, r0	; 63
    1938:	ad bf       	out	0x3d, r26	; 61
    193a:	ed b7       	in	r30, 0x3d	; 61
    193c:	fe b7       	in	r31, 0x3e	; 62
    193e:	31 96       	adiw	r30, 0x01	; 1
    1940:	12 96       	adiw	r26, 0x02	; 2
    1942:	3c 92       	st	X, r3
    1944:	2e 92       	st	-X, r2
    1946:	11 97       	sbiw	r26, 0x01	; 1
    1948:	84 e1       	ldi	r24, 0x14	; 20
    194a:	90 e0       	ldi	r25, 0x00	; 0
    194c:	93 83       	std	Z+3, r25	; 0x03
    194e:	82 83       	std	Z+2, r24	; 0x02
    1950:	a0 e0       	ldi	r26, 0x00	; 0
    1952:	b2 e0       	ldi	r27, 0x02	; 2
    1954:	b5 83       	std	Z+5, r27	; 0x05
    1956:	a4 83       	std	Z+4, r26	; 0x04
    1958:	b7 82       	std	Z+7, r11	; 0x07
    195a:	a6 82       	std	Z+6, r10	; 0x06
    195c:	11 87       	std	Z+9, r17	; 0x09
    195e:	00 87       	std	Z+8, r16	; 0x08
    1960:	80 e3       	ldi	r24, 0x30	; 48
    1962:	90 e0       	ldi	r25, 0x00	; 0
    1964:	93 87       	std	Z+11, r25	; 0x0b
    1966:	82 87       	std	Z+10, r24	; 0x0a
    1968:	95 87       	std	Z+13, r25	; 0x0d
    196a:	84 87       	std	Z+12, r24	; 0x0c
    196c:	0e 94 22 11 	call	0x2244	; 0x2244 <snprintf>
			send_string(dataC);
    1970:	ad b7       	in	r26, 0x3d	; 61
    1972:	be b7       	in	r27, 0x3e	; 62
    1974:	1e 96       	adiw	r26, 0x0e	; 14
    1976:	0f b6       	in	r0, 0x3f	; 63
    1978:	f8 94       	cli
    197a:	be bf       	out	0x3e, r27	; 62
    197c:	0f be       	out	0x3f, r0	; 63
    197e:	ad bf       	out	0x3d, r26	; 61
    1980:	c1 01       	movw	r24, r2
    1982:	0e 94 49 02 	call	0x492	; 0x492 <send_string>
			USART_Transmit(13);
    1986:	8d e0       	ldi	r24, 0x0D	; 13
    1988:	0e 94 39 02 	call	0x472	; 0x472 <USART_Transmit>
			forward();
    198c:	0e 94 8e 07 	call	0xf1c	; 0xf1c <forward>
			velocity(VERY_FAST,VERY_FAST);
    1990:	8a ef       	ldi	r24, 0xFA	; 250
    1992:	90 e0       	ldi	r25, 0x00	; 0
    1994:	6a ef       	ldi	r22, 0xFA	; 250
    1996:	70 e0       	ldi	r23, 0x00	; 0
    1998:	0e 94 b2 08 	call	0x1164	; 0x1164 <velocity>
    199c:	8f ef       	ldi	r24, 0xFF	; 255
    199e:	9f e7       	ldi	r25, 0x7F	; 127
    19a0:	a4 e0       	ldi	r26, 0x04	; 4
    19a2:	81 50       	subi	r24, 0x01	; 1
    19a4:	90 40       	sbci	r25, 0x00	; 0
    19a6:	a0 40       	sbci	r26, 0x00	; 0
    19a8:	e1 f7       	brne	.-8      	; 0x19a2 <loop+0x258>
    19aa:	00 c0       	rjmp	.+0      	; 0x19ac <loop+0x262>
    19ac:	00 00       	nop
			_delay_ms(100);
		}

		if(L_S==1 && M_S==1 && R_S==1)
    19ae:	91 e0       	ldi	r25, 0x01	; 1
    19b0:	e9 16       	cp	r14, r25
    19b2:	f1 04       	cpc	r15, r1
    19b4:	b1 f5       	brne	.+108    	; 0x1a22 <loop+0x2d8>
    19b6:	a1 e0       	ldi	r26, 0x01	; 1
    19b8:	ca 16       	cp	r12, r26
    19ba:	d1 04       	cpc	r13, r1
    19bc:	09 f0       	breq	.+2      	; 0x19c0 <loop+0x276>
    19be:	5e c1       	rjmp	.+700    	; 0x1c7c <loop+0x532>
    19c0:	b1 e0       	ldi	r27, 0x01	; 1
    19c2:	8b 16       	cp	r8, r27
    19c4:	91 04       	cpc	r9, r1
    19c6:	09 f0       	breq	.+2      	; 0x19ca <loop+0x280>
    19c8:	59 c1       	rjmp	.+690    	; 0x1c7c <loop+0x532>
		{
			forward();
    19ca:	0e 94 8e 07 	call	0xf1c	; 0xf1c <forward>
			velocity(VERY_FAST,VERY_FAST);
    19ce:	8a ef       	ldi	r24, 0xFA	; 250
    19d0:	90 e0       	ldi	r25, 0x00	; 0
    19d2:	6a ef       	ldi	r22, 0xFA	; 250
    19d4:	70 e0       	ldi	r23, 0x00	; 0
    19d6:	0e 94 b2 08 	call	0x1164	; 0x1164 <velocity>
    19da:	54 c1       	rjmp	.+680    	; 0x1c84 <loop+0x53a>
		}

		if(L_S==1 && M_S==0 && R_S==1)
    19dc:	81 e0       	ldi	r24, 0x01	; 1
    19de:	88 16       	cp	r8, r24
    19e0:	91 04       	cpc	r9, r1
    19e2:	09 f0       	breq	.+2      	; 0x19e6 <loop+0x29c>
    19e4:	4f c1       	rjmp	.+670    	; 0x1c84 <loop+0x53a>
		{
			forward();
    19e6:	0e 94 8e 07 	call	0xf1c	; 0xf1c <forward>
			velocity(VERY_FAST,VERY_FAST);
    19ea:	8a ef       	ldi	r24, 0xFA	; 250
    19ec:	90 e0       	ldi	r25, 0x00	; 0
    19ee:	6a ef       	ldi	r22, 0xFA	; 250
    19f0:	70 e0       	ldi	r23, 0x00	; 0
    19f2:	0e 94 b2 08 	call	0x1164	; 0x1164 <velocity>
    19f6:	15 c0       	rjmp	.+42     	; 0x1a22 <loop+0x2d8>
		}

		if(L_S==1 && M_S==1 && R_S==0)
    19f8:	81 14       	cp	r8, r1
    19fa:	91 04       	cpc	r9, r1
    19fc:	91 f4       	brne	.+36     	; 0x1a22 <loop+0x2d8>
		{
			right();
    19fe:	0e 94 9a 07 	call	0xf34	; 0xf34 <right>
			velocity(120,50);
    1a02:	88 e7       	ldi	r24, 0x78	; 120
    1a04:	90 e0       	ldi	r25, 0x00	; 0
    1a06:	62 e3       	ldi	r22, 0x32	; 50
    1a08:	70 e0       	ldi	r23, 0x00	; 0
    1a0a:	0e 94 b2 08 	call	0x1164	; 0x1164 <velocity>
    1a0e:	82 e3       	ldi	r24, 0x32	; 50
    1a10:	93 eb       	ldi	r25, 0xB3	; 179
    1a12:	a2 e0       	ldi	r26, 0x02	; 2
    1a14:	81 50       	subi	r24, 0x01	; 1
    1a16:	90 40       	sbci	r25, 0x00	; 0
    1a18:	a0 40       	sbci	r26, 0x00	; 0
    1a1a:	e1 f7       	brne	.-8      	; 0x1a14 <loop+0x2ca>
    1a1c:	00 c0       	rjmp	.+0      	; 0x1a1e <loop+0x2d4>
    1a1e:	00 c0       	rjmp	.+0      	; 0x1a20 <loop+0x2d6>
    1a20:	24 c0       	rjmp	.+72     	; 0x1a6a <loop+0x320>
			_delay_ms(60);
		}

		if(L_S==0 && M_S==1 && R_S==1)
    1a22:	e1 14       	cp	r14, r1
    1a24:	f1 04       	cpc	r15, r1
    1a26:	09 f5       	brne	.+66     	; 0x1a6a <loop+0x320>
    1a28:	91 e0       	ldi	r25, 0x01	; 1
    1a2a:	c9 16       	cp	r12, r25
    1a2c:	d1 04       	cpc	r13, r1
    1a2e:	09 f0       	breq	.+2      	; 0x1a32 <loop+0x2e8>
    1a30:	2f c1       	rjmp	.+606    	; 0x1c90 <loop+0x546>
    1a32:	a1 e0       	ldi	r26, 0x01	; 1
    1a34:	8a 16       	cp	r8, r26
    1a36:	91 04       	cpc	r9, r1
    1a38:	09 f0       	breq	.+2      	; 0x1a3c <loop+0x2f2>
    1a3a:	2a c1       	rjmp	.+596    	; 0x1c90 <loop+0x546>
		{
			left();
    1a3c:	0e 94 96 07 	call	0xf2c	; 0xf2c <left>
			velocity(50,120);
    1a40:	82 e3       	ldi	r24, 0x32	; 50
    1a42:	90 e0       	ldi	r25, 0x00	; 0
    1a44:	68 e7       	ldi	r22, 0x78	; 120
    1a46:	70 e0       	ldi	r23, 0x00	; 0
    1a48:	0e 94 b2 08 	call	0x1164	; 0x1164 <velocity>
    1a4c:	82 e3       	ldi	r24, 0x32	; 50
    1a4e:	93 eb       	ldi	r25, 0xB3	; 179
    1a50:	a2 e0       	ldi	r26, 0x02	; 2
    1a52:	81 50       	subi	r24, 0x01	; 1
    1a54:	90 40       	sbci	r25, 0x00	; 0
    1a56:	a0 40       	sbci	r26, 0x00	; 0
    1a58:	e1 f7       	brne	.-8      	; 0x1a52 <loop+0x308>
    1a5a:	00 c0       	rjmp	.+0      	; 0x1a5c <loop+0x312>
    1a5c:	00 c0       	rjmp	.+0      	; 0x1a5e <loop+0x314>
    1a5e:	05 c0       	rjmp	.+10     	; 0x1a6a <loop+0x320>
			_delay_ms(60);
		}
		
		if((L_S==0 && M_S==0 && R_S==1) || (L_S==1 && M_S==0 && R_S==0)|| (L_S==0 && M_S==0 && R_S==0))
    1a60:	91 e0       	ldi	r25, 0x01	; 1
    1a62:	89 16       	cp	r8, r25
    1a64:	91 04       	cpc	r9, r1
    1a66:	89 f4       	brne	.+34     	; 0x1a8a <loop+0x340>
    1a68:	18 c0       	rjmp	.+48     	; 0x1a9a <loop+0x350>
    1a6a:	a1 e0       	ldi	r26, 0x01	; 1
    1a6c:	ea 16       	cp	r14, r26
    1a6e:	f1 04       	cpc	r15, r1
    1a70:	41 f4       	brne	.+16     	; 0x1a82 <loop+0x338>
    1a72:	c1 14       	cp	r12, r1
    1a74:	d1 04       	cpc	r13, r1
    1a76:	09 f0       	breq	.+2      	; 0x1a7a <loop+0x330>
    1a78:	a0 c0       	rjmp	.+320    	; 0x1bba <loop+0x470>
    1a7a:	81 14       	cp	r8, r1
    1a7c:	91 04       	cpc	r9, r1
    1a7e:	69 f0       	breq	.+26     	; 0x1a9a <loop+0x350>
    1a80:	9c c0       	rjmp	.+312    	; 0x1bba <loop+0x470>
    1a82:	e1 14       	cp	r14, r1
    1a84:	f1 04       	cpc	r15, r1
    1a86:	09 f0       	breq	.+2      	; 0x1a8a <loop+0x340>
    1a88:	98 c0       	rjmp	.+304    	; 0x1bba <loop+0x470>
    1a8a:	c1 14       	cp	r12, r1
    1a8c:	d1 04       	cpc	r13, r1
    1a8e:	09 f0       	breq	.+2      	; 0x1a92 <loop+0x348>
    1a90:	94 c0       	rjmp	.+296    	; 0x1bba <loop+0x470>
    1a92:	81 14       	cp	r8, r1
    1a94:	91 04       	cpc	r9, r1
    1a96:	09 f0       	breq	.+2      	; 0x1a9a <loop+0x350>
    1a98:	90 c0       	rjmp	.+288    	; 0x1bba <loop+0x470>
		{
			char dataN[20];
			NOD = '1';
			Stop();
    1a9a:	0e 94 ae 07 	call	0xf5c	; 0xf5c <Stop>
			buzzer_on();
    1a9e:	0e 94 95 08 	call	0x112a	; 0x112a <buzzer_on>
    1aa2:	8f ef       	ldi	r24, 0xFF	; 255
    1aa4:	9f e8       	ldi	r25, 0x8F	; 143
    1aa6:	01 97       	sbiw	r24, 0x01	; 1
    1aa8:	f1 f7       	brne	.-4      	; 0x1aa6 <loop+0x35c>
    1aaa:	00 c0       	rjmp	.+0      	; 0x1aac <loop+0x362>
    1aac:	00 00       	nop
			_delay_ms(10);
			buzzer_off();
    1aae:	0e 94 99 08 	call	0x1132	; 0x1132 <buzzer_off>
/******* SENDING SECTION WHEN NODE DETECTED***********/	

			snprintf(dataN,sizeof(dataN),"N:%03d,%03d,%03d",IR2,IR3,IR4);
    1ab2:	ad b7       	in	r26, 0x3d	; 61
    1ab4:	be b7       	in	r27, 0x3e	; 62
    1ab6:	1c 97       	sbiw	r26, 0x0c	; 12
    1ab8:	0f b6       	in	r0, 0x3f	; 63
    1aba:	f8 94       	cli
    1abc:	be bf       	out	0x3e, r27	; 62
    1abe:	0f be       	out	0x3f, r0	; 63
    1ac0:	ad bf       	out	0x3d, r26	; 61
    1ac2:	ed b7       	in	r30, 0x3d	; 61
    1ac4:	fe b7       	in	r31, 0x3e	; 62
    1ac6:	31 96       	adiw	r30, 0x01	; 1
    1ac8:	12 96       	adiw	r26, 0x02	; 2
    1aca:	3c 92       	st	X, r3
    1acc:	2e 92       	st	-X, r2
    1ace:	11 97       	sbiw	r26, 0x01	; 1
    1ad0:	84 e1       	ldi	r24, 0x14	; 20
    1ad2:	90 e0       	ldi	r25, 0x00	; 0
    1ad4:	93 83       	std	Z+3, r25	; 0x03
    1ad6:	82 83       	std	Z+2, r24	; 0x02
    1ad8:	a2 e1       	ldi	r26, 0x12	; 18
    1ada:	b2 e0       	ldi	r27, 0x02	; 2
    1adc:	b5 83       	std	Z+5, r27	; 0x05
    1ade:	a4 83       	std	Z+4, r26	; 0x04
    1ae0:	89 a5       	lds	r24, 0x69
    1ae2:	9a a5       	lds	r25, 0x6a
    1ae4:	97 83       	std	Z+7, r25	; 0x07
    1ae6:	86 83       	std	Z+6, r24	; 0x06
    1ae8:	ab a5       	lds	r26, 0x6b
    1aea:	bc a5       	lds	r27, 0x6c
    1aec:	b1 87       	std	Z+9, r27	; 0x09
    1aee:	a0 87       	std	Z+8, r26	; 0x08
    1af0:	8d a5       	lds	r24, 0x6d
    1af2:	9e a5       	lds	r25, 0x6e
    1af4:	93 87       	std	Z+11, r25	; 0x0b
    1af6:	82 87       	std	Z+10, r24	; 0x0a
    1af8:	0e 94 22 11 	call	0x2244	; 0x2244 <snprintf>
			send_string(dataN);
    1afc:	ad b7       	in	r26, 0x3d	; 61
    1afe:	be b7       	in	r27, 0x3e	; 62
    1b00:	1c 96       	adiw	r26, 0x0c	; 12
    1b02:	0f b6       	in	r0, 0x3f	; 63
    1b04:	f8 94       	cli
    1b06:	be bf       	out	0x3e, r27	; 62
    1b08:	0f be       	out	0x3f, r0	; 63
    1b0a:	ad bf       	out	0x3d, r26	; 61
    1b0c:	c1 01       	movw	r24, r2
    1b0e:	0e 94 49 02 	call	0x492	; 0x492 <send_string>
			USART_Transmit(13);
    1b12:	8d e0       	ldi	r24, 0x0D	; 13
    1b14:	0e 94 39 02 	call	0x472	; 0x472 <USART_Transmit>
			INST = USART_Receive();
    1b18:	0e 94 41 02 	call	0x482	; 0x482 <USART_Receive>
    1b1c:	18 2f       	mov	r17, r24
			if(INST=='F')
    1b1e:	86 34       	cpi	r24, 0x46	; 70
    1b20:	91 f4       	brne	.+36     	; 0x1b46 <loop+0x3fc>
			{
				velocity(VERY_FAST,VERY_FAST);
    1b22:	8a ef       	ldi	r24, 0xFA	; 250
    1b24:	90 e0       	ldi	r25, 0x00	; 0
    1b26:	6a ef       	ldi	r22, 0xFA	; 250
    1b28:	70 e0       	ldi	r23, 0x00	; 0
    1b2a:	0e 94 b2 08 	call	0x1164	; 0x1164 <velocity>
				forward();
    1b2e:	0e 94 8e 07 	call	0xf1c	; 0xf1c <forward>
    1b32:	8f ef       	ldi	r24, 0xFF	; 255
    1b34:	9f e7       	ldi	r25, 0x7F	; 127
    1b36:	af e1       	ldi	r26, 0x1F	; 31
    1b38:	81 50       	subi	r24, 0x01	; 1
    1b3a:	90 40       	sbci	r25, 0x00	; 0
    1b3c:	a0 40       	sbci	r26, 0x00	; 0
    1b3e:	e1 f7       	brne	.-8      	; 0x1b38 <loop+0x3ee>
    1b40:	00 c0       	rjmp	.+0      	; 0x1b42 <loop+0x3f8>
    1b42:	00 00       	nop
    1b44:	0a c0       	rjmp	.+20     	; 0x1b5a <loop+0x410>
				_delay_ms(700);
			}
			
			if(INST=='R')
    1b46:	82 35       	cpi	r24, 0x52	; 82
    1b48:	19 f4       	brne	.+6      	; 0x1b50 <loop+0x406>
			{
				Right_90();
    1b4a:	0e 94 76 0b 	call	0x16ec	; 0x16ec <Right_90>
    1b4e:	0a c0       	rjmp	.+20     	; 0x1b64 <loop+0x41a>
			}
			
			if(INST=='L')
    1b50:	8c 34       	cpi	r24, 0x4C	; 76
    1b52:	19 f4       	brne	.+6      	; 0x1b5a <loop+0x410>
			{
				left_90();
    1b54:	0e 94 85 0b 	call	0x170a	; 0x170a <left_90>
    1b58:	19 ce       	rjmp	.-974    	; 0x178c <loop+0x42>
			}
			
			if(INST=='U')
    1b5a:	15 35       	cpi	r17, 0x55	; 85
    1b5c:	19 f4       	brne	.+6      	; 0x1b64 <loop+0x41a>
			{
				U_turn();
    1b5e:	0e 94 94 0b 	call	0x1728	; 0x1728 <U_turn>
    1b62:	14 ce       	rjmp	.-984    	; 0x178c <loop+0x42>
			}
			
			if(INST=='S')
    1b64:	13 35       	cpi	r17, 0x53	; 83
    1b66:	09 f0       	breq	.+2      	; 0x1b6a <loop+0x420>
    1b68:	11 ce       	rjmp	.-990    	; 0x178c <loop+0x42>
			{
				Stop();
    1b6a:	0e 94 ae 07 	call	0xf5c	; 0xf5c <Stop>
				buzzer_on();
    1b6e:	0e 94 95 08 	call	0x112a	; 0x112a <buzzer_on>
    1b72:	8f ef       	ldi	r24, 0xFF	; 255
    1b74:	9f ef       	ldi	r25, 0xFF	; 255
    1b76:	a0 ee       	ldi	r26, 0xE0	; 224
    1b78:	81 50       	subi	r24, 0x01	; 1
    1b7a:	90 40       	sbci	r25, 0x00	; 0
    1b7c:	a0 40       	sbci	r26, 0x00	; 0
    1b7e:	e1 f7       	brne	.-8      	; 0x1b78 <loop+0x42e>
    1b80:	00 c0       	rjmp	.+0      	; 0x1b82 <loop+0x438>
    1b82:	00 00       	nop
				_delay_ms(5000);
				buzzer_off();
    1b84:	0e 94 99 08 	call	0x1132	; 0x1132 <buzzer_off>
			send_string(dataD);
			USART_Transmit(13);
		}
	}
	
}
    1b88:	ae 96       	adiw	r28, 0x2e	; 46
    1b8a:	0f b6       	in	r0, 0x3f	; 63
    1b8c:	f8 94       	cli
    1b8e:	de bf       	out	0x3e, r29	; 62
    1b90:	0f be       	out	0x3f, r0	; 63
    1b92:	cd bf       	out	0x3d, r28	; 61
    1b94:	df 91       	pop	r29
    1b96:	cf 91       	pop	r28
    1b98:	1f 91       	pop	r17
    1b9a:	0f 91       	pop	r16
    1b9c:	ff 90       	pop	r15
    1b9e:	ef 90       	pop	r14
    1ba0:	df 90       	pop	r13
    1ba2:	cf 90       	pop	r12
    1ba4:	bf 90       	pop	r11
    1ba6:	af 90       	pop	r10
    1ba8:	9f 90       	pop	r9
    1baa:	8f 90       	pop	r8
    1bac:	7f 90       	pop	r7
    1bae:	6f 90       	pop	r6
    1bb0:	5f 90       	pop	r5
    1bb2:	4f 90       	pop	r4
    1bb4:	3f 90       	pop	r3
    1bb6:	2f 90       	pop	r2
    1bb8:	08 95       	ret
		
		else
		{
			/**********Sending Section ***********/
			char dataD[30];
			snprintf(dataD,sizeof(dataD),"D:%5.2f,%5.2f,%03d,%03d,%03d",AX,AY,IR2,IR3,IR4);
    1bba:	ad b7       	in	r26, 0x3d	; 61
    1bbc:	be b7       	in	r27, 0x3e	; 62
    1bbe:	54 97       	sbiw	r26, 0x14	; 20
    1bc0:	0f b6       	in	r0, 0x3f	; 63
    1bc2:	f8 94       	cli
    1bc4:	be bf       	out	0x3e, r27	; 62
    1bc6:	0f be       	out	0x3f, r0	; 63
    1bc8:	ad bf       	out	0x3d, r26	; 61
    1bca:	ed b7       	in	r30, 0x3d	; 61
    1bcc:	fe b7       	in	r31, 0x3e	; 62
    1bce:	31 96       	adiw	r30, 0x01	; 1
    1bd0:	12 96       	adiw	r26, 0x02	; 2
    1bd2:	3c 92       	st	X, r3
    1bd4:	2e 92       	st	-X, r2
    1bd6:	11 97       	sbiw	r26, 0x01	; 1
    1bd8:	8e e1       	ldi	r24, 0x1E	; 30
    1bda:	90 e0       	ldi	r25, 0x00	; 0
    1bdc:	93 83       	std	Z+3, r25	; 0x03
    1bde:	82 83       	std	Z+2, r24	; 0x02
    1be0:	a3 e2       	ldi	r26, 0x23	; 35
    1be2:	b2 e0       	ldi	r27, 0x02	; 2
    1be4:	b5 83       	std	Z+5, r27	; 0x05
    1be6:	a4 83       	std	Z+4, r26	; 0x04
    1be8:	8d 81       	ldd	r24, Y+5	; 0x05
    1bea:	9e 81       	ldd	r25, Y+6	; 0x06
    1bec:	af 81       	ldd	r26, Y+7	; 0x07
    1bee:	b8 85       	ldd	r27, Y+8	; 0x08
    1bf0:	86 83       	std	Z+6, r24	; 0x06
    1bf2:	97 83       	std	Z+7, r25	; 0x07
    1bf4:	a0 87       	std	Z+8, r26	; 0x08
    1bf6:	b1 87       	std	Z+9, r27	; 0x09
    1bf8:	89 81       	ldd	r24, Y+1	; 0x01
    1bfa:	9a 81       	ldd	r25, Y+2	; 0x02
    1bfc:	ab 81       	ldd	r26, Y+3	; 0x03
    1bfe:	bc 81       	ldd	r27, Y+4	; 0x04
    1c00:	82 87       	std	Z+10, r24	; 0x0a
    1c02:	93 87       	std	Z+11, r25	; 0x0b
    1c04:	a4 87       	std	Z+12, r26	; 0x0c
    1c06:	b5 87       	std	Z+13, r27	; 0x0d
    1c08:	89 a5       	lds	r24, 0x69
    1c0a:	9a a5       	lds	r25, 0x6a
    1c0c:	97 87       	std	Z+15, r25	; 0x0f
    1c0e:	86 87       	std	Z+14, r24	; 0x0e
    1c10:	ab a5       	lds	r26, 0x6b
    1c12:	bc a5       	lds	r27, 0x6c
    1c14:	b1 8b       	std	Z+17, r27	; 0x11
    1c16:	a0 8b       	std	Z+16, r26	; 0x10
    1c18:	8d a5       	lds	r24, 0x6d
    1c1a:	9e a5       	lds	r25, 0x6e
    1c1c:	93 8b       	std	Z+19, r25	; 0x13
    1c1e:	82 8b       	std	Z+18, r24	; 0x12
    1c20:	0e 94 22 11 	call	0x2244	; 0x2244 <snprintf>
			send_string(dataD);
    1c24:	ad b7       	in	r26, 0x3d	; 61
    1c26:	be b7       	in	r27, 0x3e	; 62
    1c28:	54 96       	adiw	r26, 0x14	; 20
    1c2a:	0f b6       	in	r0, 0x3f	; 63
    1c2c:	f8 94       	cli
    1c2e:	be bf       	out	0x3e, r27	; 62
    1c30:	0f be       	out	0x3f, r0	; 63
    1c32:	ad bf       	out	0x3d, r26	; 61
    1c34:	c1 01       	movw	r24, r2
    1c36:	0e 94 49 02 	call	0x492	; 0x492 <send_string>
			USART_Transmit(13);
    1c3a:	8d e0       	ldi	r24, 0x0D	; 13
    1c3c:	0e 94 39 02 	call	0x472	; 0x472 <USART_Transmit>
    1c40:	a5 cd       	rjmp	.-1206   	; 0x178c <loop+0x42>
    1c42:	8f ef       	ldi	r24, 0xFF	; 255
    1c44:	9f e3       	ldi	r25, 0x3F	; 63
    1c46:	a2 e0       	ldi	r26, 0x02	; 2
    1c48:	81 50       	subi	r24, 0x01	; 1
    1c4a:	90 40       	sbci	r25, 0x00	; 0
    1c4c:	a0 40       	sbci	r26, 0x00	; 0
    1c4e:	e1 f7       	brne	.-8      	; 0x1c48 <loop+0x4fe>
    1c50:	00 c0       	rjmp	.+0      	; 0x1c52 <loop+0x508>
    1c52:	00 00       	nop

		if(SSM==1 || SSF==1)				//checking for objects either sides
		{
			char dataC[20];
			_delay_ms(50);
			Stop();
    1c54:	0e 94 ae 07 	call	0xf5c	; 0xf5c <Stop>
			buzzer_on();
    1c58:	0e 94 95 08 	call	0x112a	; 0x112a <buzzer_on>
    1c5c:	8f ef       	ldi	r24, 0xFF	; 255
    1c5e:	9f ef       	ldi	r25, 0xFF	; 255
    1c60:	a8 e0       	ldi	r26, 0x08	; 8
    1c62:	81 50       	subi	r24, 0x01	; 1
    1c64:	90 40       	sbci	r25, 0x00	; 0
    1c66:	a0 40       	sbci	r26, 0x00	; 0
    1c68:	e1 f7       	brne	.-8      	; 0x1c62 <loop+0x518>
    1c6a:	00 c0       	rjmp	.+0      	; 0x1c6c <loop+0x522>
    1c6c:	00 00       	nop
			_delay_ms(200);
			buzzer_off();
    1c6e:	0e 94 99 08 	call	0x1132	; 0x1132 <buzzer_off>
	//			COL2 = colorDetect();
				servo_1(0);
				_delay_ms(100);
			}
			
			else if(SSM==1 && SSF==0)
    1c72:	01 15       	cp	r16, r1
    1c74:	11 05       	cpc	r17, r1
    1c76:	09 f0       	breq	.+2      	; 0x1c7a <loop+0x530>
    1c78:	37 ce       	rjmp	.-914    	; 0x18e8 <loop+0x19e>
    1c7a:	2c ce       	rjmp	.-936    	; 0x18d4 <loop+0x18a>
		{
			forward();
			velocity(VERY_FAST,VERY_FAST);
		}

		if(L_S==1 && M_S==0 && R_S==1)
    1c7c:	c1 14       	cp	r12, r1
    1c7e:	d1 04       	cpc	r13, r1
    1c80:	09 f4       	brne	.+2      	; 0x1c84 <loop+0x53a>
    1c82:	ac ce       	rjmp	.-680    	; 0x19dc <loop+0x292>
		{
			forward();
			velocity(VERY_FAST,VERY_FAST);
		}

		if(L_S==1 && M_S==1 && R_S==0)
    1c84:	91 e0       	ldi	r25, 0x01	; 1
    1c86:	c9 16       	cp	r12, r25
    1c88:	d1 04       	cpc	r13, r1
    1c8a:	09 f0       	breq	.+2      	; 0x1c8e <loop+0x544>
    1c8c:	ca ce       	rjmp	.-620    	; 0x1a22 <loop+0x2d8>
    1c8e:	b4 ce       	rjmp	.-664    	; 0x19f8 <loop+0x2ae>
			left();
			velocity(50,120);
			_delay_ms(60);
		}
		
		if((L_S==0 && M_S==0 && R_S==1) || (L_S==1 && M_S==0 && R_S==0)|| (L_S==0 && M_S==0 && R_S==0))
    1c90:	c1 14       	cp	r12, r1
    1c92:	d1 04       	cpc	r13, r1
    1c94:	09 f4       	brne	.+2      	; 0x1c98 <loop+0x54e>
    1c96:	e4 ce       	rjmp	.-568    	; 0x1a60 <loop+0x316>
    1c98:	e8 ce       	rjmp	.-560    	; 0x1a6a <loop+0x320>

00001c9a <main>:
	
}

void main()
{
	setup();
    1c9a:	0e 94 63 0b 	call	0x16c6	; 0x16c6 <setup>
	DDRE&=~(1<<PINE7);					//Initialization for Interrupt switch
    1c9e:	6f 98       	cbi	0x0d, 7	; 13
	while(bit_is_set(PINE,7))			//waiting for interrupt switch to be pressed
    1ca0:	67 99       	sbic	0x0c, 7	; 12
    1ca2:	fe cf       	rjmp	.-4      	; 0x1ca0 <main+0x6>
	;
	loop();
    1ca4:	0e 94 a5 0b 	call	0x174a	; 0x174a <loop>
    1ca8:	08 95       	ret

00001caa <__subsf3>:
    1caa:	50 58       	subi	r21, 0x80	; 128

00001cac <__addsf3>:
    1cac:	bb 27       	eor	r27, r27
    1cae:	aa 27       	eor	r26, r26
    1cb0:	0e d0       	rcall	.+28     	; 0x1cce <__addsf3x>
    1cb2:	0d c2       	rjmp	.+1050   	; 0x20ce <__fp_round>
    1cb4:	fe d1       	rcall	.+1020   	; 0x20b2 <__fp_pscA>
    1cb6:	30 f0       	brcs	.+12     	; 0x1cc4 <__addsf3+0x18>
    1cb8:	03 d2       	rcall	.+1030   	; 0x20c0 <__fp_pscB>
    1cba:	20 f0       	brcs	.+8      	; 0x1cc4 <__addsf3+0x18>
    1cbc:	31 f4       	brne	.+12     	; 0x1cca <__addsf3+0x1e>
    1cbe:	9f 3f       	cpi	r25, 0xFF	; 255
    1cc0:	11 f4       	brne	.+4      	; 0x1cc6 <__addsf3+0x1a>
    1cc2:	1e f4       	brtc	.+6      	; 0x1cca <__addsf3+0x1e>
    1cc4:	ce c1       	rjmp	.+924    	; 0x2062 <__fp_nan>
    1cc6:	0e f4       	brtc	.+2      	; 0x1cca <__addsf3+0x1e>
    1cc8:	e0 95       	com	r30
    1cca:	e7 fb       	bst	r30, 7
    1ccc:	c4 c1       	rjmp	.+904    	; 0x2056 <__fp_inf>

00001cce <__addsf3x>:
    1cce:	e9 2f       	mov	r30, r25
    1cd0:	0f d2       	rcall	.+1054   	; 0x20f0 <__fp_split3>
    1cd2:	80 f3       	brcs	.-32     	; 0x1cb4 <__addsf3+0x8>
    1cd4:	ba 17       	cp	r27, r26
    1cd6:	62 07       	cpc	r22, r18
    1cd8:	73 07       	cpc	r23, r19
    1cda:	84 07       	cpc	r24, r20
    1cdc:	95 07       	cpc	r25, r21
    1cde:	18 f0       	brcs	.+6      	; 0x1ce6 <__addsf3x+0x18>
    1ce0:	71 f4       	brne	.+28     	; 0x1cfe <__addsf3x+0x30>
    1ce2:	9e f5       	brtc	.+102    	; 0x1d4a <__addsf3x+0x7c>
    1ce4:	27 c2       	rjmp	.+1102   	; 0x2134 <__fp_zero>
    1ce6:	0e f4       	brtc	.+2      	; 0x1cea <__addsf3x+0x1c>
    1ce8:	e0 95       	com	r30
    1cea:	0b 2e       	mov	r0, r27
    1cec:	ba 2f       	mov	r27, r26
    1cee:	a0 2d       	mov	r26, r0
    1cf0:	0b 01       	movw	r0, r22
    1cf2:	b9 01       	movw	r22, r18
    1cf4:	90 01       	movw	r18, r0
    1cf6:	0c 01       	movw	r0, r24
    1cf8:	ca 01       	movw	r24, r20
    1cfa:	a0 01       	movw	r20, r0
    1cfc:	11 24       	eor	r1, r1
    1cfe:	ff 27       	eor	r31, r31
    1d00:	59 1b       	sub	r21, r25
    1d02:	99 f0       	breq	.+38     	; 0x1d2a <__addsf3x+0x5c>
    1d04:	59 3f       	cpi	r21, 0xF9	; 249
    1d06:	50 f4       	brcc	.+20     	; 0x1d1c <__addsf3x+0x4e>
    1d08:	50 3e       	cpi	r21, 0xE0	; 224
    1d0a:	68 f1       	brcs	.+90     	; 0x1d66 <__addsf3x+0x98>
    1d0c:	1a 16       	cp	r1, r26
    1d0e:	f0 40       	sbci	r31, 0x00	; 0
    1d10:	a2 2f       	mov	r26, r18
    1d12:	23 2f       	mov	r18, r19
    1d14:	34 2f       	mov	r19, r20
    1d16:	44 27       	eor	r20, r20
    1d18:	58 5f       	subi	r21, 0xF8	; 248
    1d1a:	f3 cf       	rjmp	.-26     	; 0x1d02 <__addsf3x+0x34>
    1d1c:	46 95       	lsr	r20
    1d1e:	37 95       	ror	r19
    1d20:	27 95       	ror	r18
    1d22:	a7 95       	ror	r26
    1d24:	f0 40       	sbci	r31, 0x00	; 0
    1d26:	53 95       	inc	r21
    1d28:	c9 f7       	brne	.-14     	; 0x1d1c <__addsf3x+0x4e>
    1d2a:	7e f4       	brtc	.+30     	; 0x1d4a <__addsf3x+0x7c>
    1d2c:	1f 16       	cp	r1, r31
    1d2e:	ba 0b       	sbc	r27, r26
    1d30:	62 0b       	sbc	r22, r18
    1d32:	73 0b       	sbc	r23, r19
    1d34:	84 0b       	sbc	r24, r20
    1d36:	ba f0       	brmi	.+46     	; 0x1d66 <__addsf3x+0x98>
    1d38:	91 50       	subi	r25, 0x01	; 1
    1d3a:	a1 f0       	breq	.+40     	; 0x1d64 <__addsf3x+0x96>
    1d3c:	ff 0f       	add	r31, r31
    1d3e:	bb 1f       	adc	r27, r27
    1d40:	66 1f       	adc	r22, r22
    1d42:	77 1f       	adc	r23, r23
    1d44:	88 1f       	adc	r24, r24
    1d46:	c2 f7       	brpl	.-16     	; 0x1d38 <__addsf3x+0x6a>
    1d48:	0e c0       	rjmp	.+28     	; 0x1d66 <__addsf3x+0x98>
    1d4a:	ba 0f       	add	r27, r26
    1d4c:	62 1f       	adc	r22, r18
    1d4e:	73 1f       	adc	r23, r19
    1d50:	84 1f       	adc	r24, r20
    1d52:	48 f4       	brcc	.+18     	; 0x1d66 <__addsf3x+0x98>
    1d54:	87 95       	ror	r24
    1d56:	77 95       	ror	r23
    1d58:	67 95       	ror	r22
    1d5a:	b7 95       	ror	r27
    1d5c:	f7 95       	ror	r31
    1d5e:	9e 3f       	cpi	r25, 0xFE	; 254
    1d60:	08 f0       	brcs	.+2      	; 0x1d64 <__addsf3x+0x96>
    1d62:	b3 cf       	rjmp	.-154    	; 0x1cca <__addsf3+0x1e>
    1d64:	93 95       	inc	r25
    1d66:	88 0f       	add	r24, r24
    1d68:	08 f0       	brcs	.+2      	; 0x1d6c <__addsf3x+0x9e>
    1d6a:	99 27       	eor	r25, r25
    1d6c:	ee 0f       	add	r30, r30
    1d6e:	97 95       	ror	r25
    1d70:	87 95       	ror	r24
    1d72:	08 95       	ret
    1d74:	9e d1       	rcall	.+828    	; 0x20b2 <__fp_pscA>
    1d76:	58 f0       	brcs	.+22     	; 0x1d8e <__addsf3x+0xc0>
    1d78:	80 e8       	ldi	r24, 0x80	; 128
    1d7a:	91 e0       	ldi	r25, 0x01	; 1
    1d7c:	09 f4       	brne	.+2      	; 0x1d80 <__addsf3x+0xb2>
    1d7e:	9e ef       	ldi	r25, 0xFE	; 254
    1d80:	9f d1       	rcall	.+830    	; 0x20c0 <__fp_pscB>
    1d82:	28 f0       	brcs	.+10     	; 0x1d8e <__addsf3x+0xc0>
    1d84:	40 e8       	ldi	r20, 0x80	; 128
    1d86:	51 e0       	ldi	r21, 0x01	; 1
    1d88:	59 f4       	brne	.+22     	; 0x1da0 <atan2+0xe>
    1d8a:	5e ef       	ldi	r21, 0xFE	; 254
    1d8c:	09 c0       	rjmp	.+18     	; 0x1da0 <atan2+0xe>
    1d8e:	69 c1       	rjmp	.+722    	; 0x2062 <__fp_nan>
    1d90:	d1 c1       	rjmp	.+930    	; 0x2134 <__fp_zero>

00001d92 <atan2>:
    1d92:	e9 2f       	mov	r30, r25
    1d94:	e0 78       	andi	r30, 0x80	; 128
    1d96:	ac d1       	rcall	.+856    	; 0x20f0 <__fp_split3>
    1d98:	68 f3       	brcs	.-38     	; 0x1d74 <__addsf3x+0xa6>
    1d9a:	09 2e       	mov	r0, r25
    1d9c:	05 2a       	or	r0, r21
    1d9e:	c1 f3       	breq	.-16     	; 0x1d90 <__addsf3x+0xc2>
    1da0:	26 17       	cp	r18, r22
    1da2:	37 07       	cpc	r19, r23
    1da4:	48 07       	cpc	r20, r24
    1da6:	59 07       	cpc	r21, r25
    1da8:	38 f0       	brcs	.+14     	; 0x1db8 <atan2+0x26>
    1daa:	0e 2e       	mov	r0, r30
    1dac:	07 f8       	bld	r0, 7
    1dae:	e0 25       	eor	r30, r0
    1db0:	69 f0       	breq	.+26     	; 0x1dcc <atan2+0x3a>
    1db2:	e0 25       	eor	r30, r0
    1db4:	e0 64       	ori	r30, 0x40	; 64
    1db6:	0a c0       	rjmp	.+20     	; 0x1dcc <atan2+0x3a>
    1db8:	ef 63       	ori	r30, 0x3F	; 63
    1dba:	07 f8       	bld	r0, 7
    1dbc:	00 94       	com	r0
    1dbe:	07 fa       	bst	r0, 7
    1dc0:	db 01       	movw	r26, r22
    1dc2:	b9 01       	movw	r22, r18
    1dc4:	9d 01       	movw	r18, r26
    1dc6:	dc 01       	movw	r26, r24
    1dc8:	ca 01       	movw	r24, r20
    1dca:	ad 01       	movw	r20, r26
    1dcc:	ef 93       	push	r30
    1dce:	43 d0       	rcall	.+134    	; 0x1e56 <__divsf3_pse>
    1dd0:	7e d1       	rcall	.+764    	; 0x20ce <__fp_round>
    1dd2:	0a d0       	rcall	.+20     	; 0x1de8 <atan>
    1dd4:	5f 91       	pop	r21
    1dd6:	55 23       	and	r21, r21
    1dd8:	31 f0       	breq	.+12     	; 0x1de6 <atan2+0x54>
    1dda:	2b ed       	ldi	r18, 0xDB	; 219
    1ddc:	3f e0       	ldi	r19, 0x0F	; 15
    1dde:	49 e4       	ldi	r20, 0x49	; 73
    1de0:	50 fd       	sbrc	r21, 0
    1de2:	49 ec       	ldi	r20, 0xC9	; 201
    1de4:	63 cf       	rjmp	.-314    	; 0x1cac <__addsf3>
    1de6:	08 95       	ret

00001de8 <atan>:
    1de8:	df 93       	push	r29
    1dea:	dd 27       	eor	r29, r29
    1dec:	b9 2f       	mov	r27, r25
    1dee:	bf 77       	andi	r27, 0x7F	; 127
    1df0:	40 e8       	ldi	r20, 0x80	; 128
    1df2:	5f e3       	ldi	r21, 0x3F	; 63
    1df4:	16 16       	cp	r1, r22
    1df6:	17 06       	cpc	r1, r23
    1df8:	48 07       	cpc	r20, r24
    1dfa:	5b 07       	cpc	r21, r27
    1dfc:	10 f4       	brcc	.+4      	; 0x1e02 <atan+0x1a>
    1dfe:	d9 2f       	mov	r29, r25
    1e00:	a0 d1       	rcall	.+832    	; 0x2142 <inverse>
    1e02:	9f 93       	push	r25
    1e04:	8f 93       	push	r24
    1e06:	7f 93       	push	r23
    1e08:	6f 93       	push	r22
    1e0a:	05 d2       	rcall	.+1034   	; 0x2216 <square>
    1e0c:	e4 ee       	ldi	r30, 0xE4	; 228
    1e0e:	f0 e0       	ldi	r31, 0x00	; 0
    1e10:	2b d1       	rcall	.+598    	; 0x2068 <__fp_powser>
    1e12:	5d d1       	rcall	.+698    	; 0x20ce <__fp_round>
    1e14:	2f 91       	pop	r18
    1e16:	3f 91       	pop	r19
    1e18:	4f 91       	pop	r20
    1e1a:	5f 91       	pop	r21
    1e1c:	a5 d1       	rcall	.+842    	; 0x2168 <__mulsf3x>
    1e1e:	dd 23       	and	r29, r29
    1e20:	49 f0       	breq	.+18     	; 0x1e34 <atan+0x4c>
    1e22:	90 58       	subi	r25, 0x80	; 128
    1e24:	a2 ea       	ldi	r26, 0xA2	; 162
    1e26:	2a ed       	ldi	r18, 0xDA	; 218
    1e28:	3f e0       	ldi	r19, 0x0F	; 15
    1e2a:	49 ec       	ldi	r20, 0xC9	; 201
    1e2c:	5f e3       	ldi	r21, 0x3F	; 63
    1e2e:	d0 78       	andi	r29, 0x80	; 128
    1e30:	5d 27       	eor	r21, r29
    1e32:	4d df       	rcall	.-358    	; 0x1cce <__addsf3x>
    1e34:	df 91       	pop	r29
    1e36:	4b c1       	rjmp	.+662    	; 0x20ce <__fp_round>

00001e38 <__divsf3>:
    1e38:	0c d0       	rcall	.+24     	; 0x1e52 <__divsf3x>
    1e3a:	49 c1       	rjmp	.+658    	; 0x20ce <__fp_round>
    1e3c:	41 d1       	rcall	.+642    	; 0x20c0 <__fp_pscB>
    1e3e:	40 f0       	brcs	.+16     	; 0x1e50 <__divsf3+0x18>
    1e40:	38 d1       	rcall	.+624    	; 0x20b2 <__fp_pscA>
    1e42:	30 f0       	brcs	.+12     	; 0x1e50 <__divsf3+0x18>
    1e44:	21 f4       	brne	.+8      	; 0x1e4e <__divsf3+0x16>
    1e46:	5f 3f       	cpi	r21, 0xFF	; 255
    1e48:	19 f0       	breq	.+6      	; 0x1e50 <__divsf3+0x18>
    1e4a:	05 c1       	rjmp	.+522    	; 0x2056 <__fp_inf>
    1e4c:	51 11       	cpse	r21, r1
    1e4e:	73 c1       	rjmp	.+742    	; 0x2136 <__fp_szero>
    1e50:	08 c1       	rjmp	.+528    	; 0x2062 <__fp_nan>

00001e52 <__divsf3x>:
    1e52:	4e d1       	rcall	.+668    	; 0x20f0 <__fp_split3>
    1e54:	98 f3       	brcs	.-26     	; 0x1e3c <__divsf3+0x4>

00001e56 <__divsf3_pse>:
    1e56:	99 23       	and	r25, r25
    1e58:	c9 f3       	breq	.-14     	; 0x1e4c <__divsf3+0x14>
    1e5a:	55 23       	and	r21, r21
    1e5c:	b1 f3       	breq	.-20     	; 0x1e4a <__divsf3+0x12>
    1e5e:	95 1b       	sub	r25, r21
    1e60:	55 0b       	sbc	r21, r21
    1e62:	bb 27       	eor	r27, r27
    1e64:	aa 27       	eor	r26, r26
    1e66:	62 17       	cp	r22, r18
    1e68:	73 07       	cpc	r23, r19
    1e6a:	84 07       	cpc	r24, r20
    1e6c:	38 f0       	brcs	.+14     	; 0x1e7c <__divsf3_pse+0x26>
    1e6e:	9f 5f       	subi	r25, 0xFF	; 255
    1e70:	5f 4f       	sbci	r21, 0xFF	; 255
    1e72:	22 0f       	add	r18, r18
    1e74:	33 1f       	adc	r19, r19
    1e76:	44 1f       	adc	r20, r20
    1e78:	aa 1f       	adc	r26, r26
    1e7a:	a9 f3       	breq	.-22     	; 0x1e66 <__divsf3_pse+0x10>
    1e7c:	33 d0       	rcall	.+102    	; 0x1ee4 <__divsf3_pse+0x8e>
    1e7e:	0e 2e       	mov	r0, r30
    1e80:	3a f0       	brmi	.+14     	; 0x1e90 <__divsf3_pse+0x3a>
    1e82:	e0 e8       	ldi	r30, 0x80	; 128
    1e84:	30 d0       	rcall	.+96     	; 0x1ee6 <__divsf3_pse+0x90>
    1e86:	91 50       	subi	r25, 0x01	; 1
    1e88:	50 40       	sbci	r21, 0x00	; 0
    1e8a:	e6 95       	lsr	r30
    1e8c:	00 1c       	adc	r0, r0
    1e8e:	ca f7       	brpl	.-14     	; 0x1e82 <__divsf3_pse+0x2c>
    1e90:	29 d0       	rcall	.+82     	; 0x1ee4 <__divsf3_pse+0x8e>
    1e92:	fe 2f       	mov	r31, r30
    1e94:	27 d0       	rcall	.+78     	; 0x1ee4 <__divsf3_pse+0x8e>
    1e96:	66 0f       	add	r22, r22
    1e98:	77 1f       	adc	r23, r23
    1e9a:	88 1f       	adc	r24, r24
    1e9c:	bb 1f       	adc	r27, r27
    1e9e:	26 17       	cp	r18, r22
    1ea0:	37 07       	cpc	r19, r23
    1ea2:	48 07       	cpc	r20, r24
    1ea4:	ab 07       	cpc	r26, r27
    1ea6:	b0 e8       	ldi	r27, 0x80	; 128
    1ea8:	09 f0       	breq	.+2      	; 0x1eac <__divsf3_pse+0x56>
    1eaa:	bb 0b       	sbc	r27, r27
    1eac:	80 2d       	mov	r24, r0
    1eae:	bf 01       	movw	r22, r30
    1eb0:	ff 27       	eor	r31, r31
    1eb2:	93 58       	subi	r25, 0x83	; 131
    1eb4:	5f 4f       	sbci	r21, 0xFF	; 255
    1eb6:	2a f0       	brmi	.+10     	; 0x1ec2 <__divsf3_pse+0x6c>
    1eb8:	9e 3f       	cpi	r25, 0xFE	; 254
    1eba:	51 05       	cpc	r21, r1
    1ebc:	68 f0       	brcs	.+26     	; 0x1ed8 <__divsf3_pse+0x82>
    1ebe:	cb c0       	rjmp	.+406    	; 0x2056 <__fp_inf>
    1ec0:	3a c1       	rjmp	.+628    	; 0x2136 <__fp_szero>
    1ec2:	5f 3f       	cpi	r21, 0xFF	; 255
    1ec4:	ec f3       	brlt	.-6      	; 0x1ec0 <__divsf3_pse+0x6a>
    1ec6:	98 3e       	cpi	r25, 0xE8	; 232
    1ec8:	dc f3       	brlt	.-10     	; 0x1ec0 <__divsf3_pse+0x6a>
    1eca:	86 95       	lsr	r24
    1ecc:	77 95       	ror	r23
    1ece:	67 95       	ror	r22
    1ed0:	b7 95       	ror	r27
    1ed2:	f7 95       	ror	r31
    1ed4:	9f 5f       	subi	r25, 0xFF	; 255
    1ed6:	c9 f7       	brne	.-14     	; 0x1eca <__divsf3_pse+0x74>
    1ed8:	88 0f       	add	r24, r24
    1eda:	91 1d       	adc	r25, r1
    1edc:	96 95       	lsr	r25
    1ede:	87 95       	ror	r24
    1ee0:	97 f9       	bld	r25, 7
    1ee2:	08 95       	ret
    1ee4:	e1 e0       	ldi	r30, 0x01	; 1
    1ee6:	66 0f       	add	r22, r22
    1ee8:	77 1f       	adc	r23, r23
    1eea:	88 1f       	adc	r24, r24
    1eec:	bb 1f       	adc	r27, r27
    1eee:	62 17       	cp	r22, r18
    1ef0:	73 07       	cpc	r23, r19
    1ef2:	84 07       	cpc	r24, r20
    1ef4:	ba 07       	cpc	r27, r26
    1ef6:	20 f0       	brcs	.+8      	; 0x1f00 <__divsf3_pse+0xaa>
    1ef8:	62 1b       	sub	r22, r18
    1efa:	73 0b       	sbc	r23, r19
    1efc:	84 0b       	sbc	r24, r20
    1efe:	ba 0b       	sbc	r27, r26
    1f00:	ee 1f       	adc	r30, r30
    1f02:	88 f7       	brcc	.-30     	; 0x1ee6 <__divsf3_pse+0x90>
    1f04:	e0 95       	com	r30
    1f06:	08 95       	ret

00001f08 <__fixunssfsi>:
    1f08:	fb d0       	rcall	.+502    	; 0x2100 <__fp_splitA>
    1f0a:	88 f0       	brcs	.+34     	; 0x1f2e <__fixunssfsi+0x26>
    1f0c:	9f 57       	subi	r25, 0x7F	; 127
    1f0e:	90 f0       	brcs	.+36     	; 0x1f34 <__fixunssfsi+0x2c>
    1f10:	b9 2f       	mov	r27, r25
    1f12:	99 27       	eor	r25, r25
    1f14:	b7 51       	subi	r27, 0x17	; 23
    1f16:	a0 f0       	brcs	.+40     	; 0x1f40 <__fixunssfsi+0x38>
    1f18:	d1 f0       	breq	.+52     	; 0x1f4e <__fixunssfsi+0x46>
    1f1a:	66 0f       	add	r22, r22
    1f1c:	77 1f       	adc	r23, r23
    1f1e:	88 1f       	adc	r24, r24
    1f20:	99 1f       	adc	r25, r25
    1f22:	1a f0       	brmi	.+6      	; 0x1f2a <__fixunssfsi+0x22>
    1f24:	ba 95       	dec	r27
    1f26:	c9 f7       	brne	.-14     	; 0x1f1a <__fixunssfsi+0x12>
    1f28:	12 c0       	rjmp	.+36     	; 0x1f4e <__fixunssfsi+0x46>
    1f2a:	b1 30       	cpi	r27, 0x01	; 1
    1f2c:	81 f0       	breq	.+32     	; 0x1f4e <__fixunssfsi+0x46>
    1f2e:	02 d1       	rcall	.+516    	; 0x2134 <__fp_zero>
    1f30:	b1 e0       	ldi	r27, 0x01	; 1
    1f32:	08 95       	ret
    1f34:	ff c0       	rjmp	.+510    	; 0x2134 <__fp_zero>
    1f36:	67 2f       	mov	r22, r23
    1f38:	78 2f       	mov	r23, r24
    1f3a:	88 27       	eor	r24, r24
    1f3c:	b8 5f       	subi	r27, 0xF8	; 248
    1f3e:	39 f0       	breq	.+14     	; 0x1f4e <__fixunssfsi+0x46>
    1f40:	b9 3f       	cpi	r27, 0xF9	; 249
    1f42:	cc f3       	brlt	.-14     	; 0x1f36 <__fixunssfsi+0x2e>
    1f44:	86 95       	lsr	r24
    1f46:	77 95       	ror	r23
    1f48:	67 95       	ror	r22
    1f4a:	b3 95       	inc	r27
    1f4c:	d9 f7       	brne	.-10     	; 0x1f44 <__fixunssfsi+0x3c>
    1f4e:	3e f4       	brtc	.+14     	; 0x1f5e <__fixunssfsi+0x56>
    1f50:	90 95       	com	r25
    1f52:	80 95       	com	r24
    1f54:	70 95       	com	r23
    1f56:	61 95       	neg	r22
    1f58:	7f 4f       	sbci	r23, 0xFF	; 255
    1f5a:	8f 4f       	sbci	r24, 0xFF	; 255
    1f5c:	9f 4f       	sbci	r25, 0xFF	; 255
    1f5e:	08 95       	ret

00001f60 <__floatunsisf>:
    1f60:	e8 94       	clt
    1f62:	09 c0       	rjmp	.+18     	; 0x1f76 <__floatsisf+0x12>

00001f64 <__floatsisf>:
    1f64:	97 fb       	bst	r25, 7
    1f66:	3e f4       	brtc	.+14     	; 0x1f76 <__floatsisf+0x12>
    1f68:	90 95       	com	r25
    1f6a:	80 95       	com	r24
    1f6c:	70 95       	com	r23
    1f6e:	61 95       	neg	r22
    1f70:	7f 4f       	sbci	r23, 0xFF	; 255
    1f72:	8f 4f       	sbci	r24, 0xFF	; 255
    1f74:	9f 4f       	sbci	r25, 0xFF	; 255
    1f76:	99 23       	and	r25, r25
    1f78:	a9 f0       	breq	.+42     	; 0x1fa4 <__floatsisf+0x40>
    1f7a:	f9 2f       	mov	r31, r25
    1f7c:	96 e9       	ldi	r25, 0x96	; 150
    1f7e:	bb 27       	eor	r27, r27
    1f80:	93 95       	inc	r25
    1f82:	f6 95       	lsr	r31
    1f84:	87 95       	ror	r24
    1f86:	77 95       	ror	r23
    1f88:	67 95       	ror	r22
    1f8a:	b7 95       	ror	r27
    1f8c:	f1 11       	cpse	r31, r1
    1f8e:	f8 cf       	rjmp	.-16     	; 0x1f80 <__floatsisf+0x1c>
    1f90:	fa f4       	brpl	.+62     	; 0x1fd0 <__floatsisf+0x6c>
    1f92:	bb 0f       	add	r27, r27
    1f94:	11 f4       	brne	.+4      	; 0x1f9a <__floatsisf+0x36>
    1f96:	60 ff       	sbrs	r22, 0
    1f98:	1b c0       	rjmp	.+54     	; 0x1fd0 <__floatsisf+0x6c>
    1f9a:	6f 5f       	subi	r22, 0xFF	; 255
    1f9c:	7f 4f       	sbci	r23, 0xFF	; 255
    1f9e:	8f 4f       	sbci	r24, 0xFF	; 255
    1fa0:	9f 4f       	sbci	r25, 0xFF	; 255
    1fa2:	16 c0       	rjmp	.+44     	; 0x1fd0 <__floatsisf+0x6c>
    1fa4:	88 23       	and	r24, r24
    1fa6:	11 f0       	breq	.+4      	; 0x1fac <__floatsisf+0x48>
    1fa8:	96 e9       	ldi	r25, 0x96	; 150
    1faa:	11 c0       	rjmp	.+34     	; 0x1fce <__floatsisf+0x6a>
    1fac:	77 23       	and	r23, r23
    1fae:	21 f0       	breq	.+8      	; 0x1fb8 <__floatsisf+0x54>
    1fb0:	9e e8       	ldi	r25, 0x8E	; 142
    1fb2:	87 2f       	mov	r24, r23
    1fb4:	76 2f       	mov	r23, r22
    1fb6:	05 c0       	rjmp	.+10     	; 0x1fc2 <__floatsisf+0x5e>
    1fb8:	66 23       	and	r22, r22
    1fba:	71 f0       	breq	.+28     	; 0x1fd8 <__floatsisf+0x74>
    1fbc:	96 e8       	ldi	r25, 0x86	; 134
    1fbe:	86 2f       	mov	r24, r22
    1fc0:	70 e0       	ldi	r23, 0x00	; 0
    1fc2:	60 e0       	ldi	r22, 0x00	; 0
    1fc4:	2a f0       	brmi	.+10     	; 0x1fd0 <__floatsisf+0x6c>
    1fc6:	9a 95       	dec	r25
    1fc8:	66 0f       	add	r22, r22
    1fca:	77 1f       	adc	r23, r23
    1fcc:	88 1f       	adc	r24, r24
    1fce:	da f7       	brpl	.-10     	; 0x1fc6 <__floatsisf+0x62>
    1fd0:	88 0f       	add	r24, r24
    1fd2:	96 95       	lsr	r25
    1fd4:	87 95       	ror	r24
    1fd6:	97 f9       	bld	r25, 7
    1fd8:	08 95       	ret

00001fda <__floatundisf>:
    1fda:	e8 94       	clt

00001fdc <__fp_di2sf>:
    1fdc:	f9 2f       	mov	r31, r25
    1fde:	96 eb       	ldi	r25, 0xB6	; 182
    1fe0:	ff 23       	and	r31, r31
    1fe2:	81 f0       	breq	.+32     	; 0x2004 <__fp_di2sf+0x28>
    1fe4:	12 16       	cp	r1, r18
    1fe6:	13 06       	cpc	r1, r19
    1fe8:	14 06       	cpc	r1, r20
    1fea:	44 0b       	sbc	r20, r20
    1fec:	93 95       	inc	r25
    1fee:	f6 95       	lsr	r31
    1ff0:	87 95       	ror	r24
    1ff2:	77 95       	ror	r23
    1ff4:	67 95       	ror	r22
    1ff6:	57 95       	ror	r21
    1ff8:	40 40       	sbci	r20, 0x00	; 0
    1ffa:	ff 23       	and	r31, r31
    1ffc:	b9 f7       	brne	.-18     	; 0x1fec <__fp_di2sf+0x10>
    1ffe:	1b c0       	rjmp	.+54     	; 0x2036 <__fp_di2sf+0x5a>
    2000:	99 27       	eor	r25, r25
    2002:	08 95       	ret
    2004:	88 23       	and	r24, r24
    2006:	51 f4       	brne	.+20     	; 0x201c <__fp_di2sf+0x40>
    2008:	98 50       	subi	r25, 0x08	; 8
    200a:	d2 f7       	brpl	.-12     	; 0x2000 <__fp_di2sf+0x24>
    200c:	87 2b       	or	r24, r23
    200e:	76 2f       	mov	r23, r22
    2010:	65 2f       	mov	r22, r21
    2012:	54 2f       	mov	r21, r20
    2014:	43 2f       	mov	r20, r19
    2016:	32 2f       	mov	r19, r18
    2018:	20 e0       	ldi	r18, 0x00	; 0
    201a:	b1 f3       	breq	.-20     	; 0x2008 <__fp_di2sf+0x2c>
    201c:	12 16       	cp	r1, r18
    201e:	13 06       	cpc	r1, r19
    2020:	14 06       	cpc	r1, r20
    2022:	44 0b       	sbc	r20, r20
    2024:	88 23       	and	r24, r24
    2026:	3a f0       	brmi	.+14     	; 0x2036 <__fp_di2sf+0x5a>
    2028:	9a 95       	dec	r25
    202a:	44 0f       	add	r20, r20
    202c:	55 1f       	adc	r21, r21
    202e:	66 1f       	adc	r22, r22
    2030:	77 1f       	adc	r23, r23
    2032:	88 1f       	adc	r24, r24
    2034:	ca f7       	brpl	.-14     	; 0x2028 <__fp_di2sf+0x4c>
    2036:	55 23       	and	r21, r21
    2038:	4a f4       	brpl	.+18     	; 0x204c <__fp_di2sf+0x70>
    203a:	44 0f       	add	r20, r20
    203c:	55 1f       	adc	r21, r21
    203e:	11 f4       	brne	.+4      	; 0x2044 <__fp_di2sf+0x68>
    2040:	60 ff       	sbrs	r22, 0
    2042:	04 c0       	rjmp	.+8      	; 0x204c <__fp_di2sf+0x70>
    2044:	6f 5f       	subi	r22, 0xFF	; 255
    2046:	7f 4f       	sbci	r23, 0xFF	; 255
    2048:	8f 4f       	sbci	r24, 0xFF	; 255
    204a:	9f 4f       	sbci	r25, 0xFF	; 255
    204c:	88 0f       	add	r24, r24
    204e:	96 95       	lsr	r25
    2050:	87 95       	ror	r24
    2052:	97 f9       	bld	r25, 7
    2054:	08 95       	ret

00002056 <__fp_inf>:
    2056:	97 f9       	bld	r25, 7
    2058:	9f 67       	ori	r25, 0x7F	; 127
    205a:	80 e8       	ldi	r24, 0x80	; 128
    205c:	70 e0       	ldi	r23, 0x00	; 0
    205e:	60 e0       	ldi	r22, 0x00	; 0
    2060:	08 95       	ret

00002062 <__fp_nan>:
    2062:	9f ef       	ldi	r25, 0xFF	; 255
    2064:	80 ec       	ldi	r24, 0xC0	; 192
    2066:	08 95       	ret

00002068 <__fp_powser>:
    2068:	df 93       	push	r29
    206a:	cf 93       	push	r28
    206c:	1f 93       	push	r17
    206e:	0f 93       	push	r16
    2070:	ff 92       	push	r15
    2072:	ef 92       	push	r14
    2074:	df 92       	push	r13
    2076:	7b 01       	movw	r14, r22
    2078:	8c 01       	movw	r16, r24
    207a:	68 94       	set
    207c:	05 c0       	rjmp	.+10     	; 0x2088 <__fp_powser+0x20>
    207e:	da 2e       	mov	r13, r26
    2080:	ef 01       	movw	r28, r30
    2082:	72 d0       	rcall	.+228    	; 0x2168 <__mulsf3x>
    2084:	fe 01       	movw	r30, r28
    2086:	e8 94       	clt
    2088:	a5 91       	lpm	r26, Z+
    208a:	25 91       	lpm	r18, Z+
    208c:	35 91       	lpm	r19, Z+
    208e:	45 91       	lpm	r20, Z+
    2090:	55 91       	lpm	r21, Z+
    2092:	ae f3       	brts	.-22     	; 0x207e <__fp_powser+0x16>
    2094:	ef 01       	movw	r28, r30
    2096:	1b de       	rcall	.-970    	; 0x1cce <__addsf3x>
    2098:	fe 01       	movw	r30, r28
    209a:	97 01       	movw	r18, r14
    209c:	a8 01       	movw	r20, r16
    209e:	da 94       	dec	r13
    20a0:	79 f7       	brne	.-34     	; 0x2080 <__fp_powser+0x18>
    20a2:	df 90       	pop	r13
    20a4:	ef 90       	pop	r14
    20a6:	ff 90       	pop	r15
    20a8:	0f 91       	pop	r16
    20aa:	1f 91       	pop	r17
    20ac:	cf 91       	pop	r28
    20ae:	df 91       	pop	r29
    20b0:	08 95       	ret

000020b2 <__fp_pscA>:
    20b2:	00 24       	eor	r0, r0
    20b4:	0a 94       	dec	r0
    20b6:	16 16       	cp	r1, r22
    20b8:	17 06       	cpc	r1, r23
    20ba:	18 06       	cpc	r1, r24
    20bc:	09 06       	cpc	r0, r25
    20be:	08 95       	ret

000020c0 <__fp_pscB>:
    20c0:	00 24       	eor	r0, r0
    20c2:	0a 94       	dec	r0
    20c4:	12 16       	cp	r1, r18
    20c6:	13 06       	cpc	r1, r19
    20c8:	14 06       	cpc	r1, r20
    20ca:	05 06       	cpc	r0, r21
    20cc:	08 95       	ret

000020ce <__fp_round>:
    20ce:	09 2e       	mov	r0, r25
    20d0:	03 94       	inc	r0
    20d2:	00 0c       	add	r0, r0
    20d4:	11 f4       	brne	.+4      	; 0x20da <__fp_round+0xc>
    20d6:	88 23       	and	r24, r24
    20d8:	52 f0       	brmi	.+20     	; 0x20ee <__fp_round+0x20>
    20da:	bb 0f       	add	r27, r27
    20dc:	40 f4       	brcc	.+16     	; 0x20ee <__fp_round+0x20>
    20de:	bf 2b       	or	r27, r31
    20e0:	11 f4       	brne	.+4      	; 0x20e6 <__fp_round+0x18>
    20e2:	60 ff       	sbrs	r22, 0
    20e4:	04 c0       	rjmp	.+8      	; 0x20ee <__fp_round+0x20>
    20e6:	6f 5f       	subi	r22, 0xFF	; 255
    20e8:	7f 4f       	sbci	r23, 0xFF	; 255
    20ea:	8f 4f       	sbci	r24, 0xFF	; 255
    20ec:	9f 4f       	sbci	r25, 0xFF	; 255
    20ee:	08 95       	ret

000020f0 <__fp_split3>:
    20f0:	57 fd       	sbrc	r21, 7
    20f2:	90 58       	subi	r25, 0x80	; 128
    20f4:	44 0f       	add	r20, r20
    20f6:	55 1f       	adc	r21, r21
    20f8:	59 f0       	breq	.+22     	; 0x2110 <__fp_splitA+0x10>
    20fa:	5f 3f       	cpi	r21, 0xFF	; 255
    20fc:	71 f0       	breq	.+28     	; 0x211a <__fp_splitA+0x1a>
    20fe:	47 95       	ror	r20

00002100 <__fp_splitA>:
    2100:	88 0f       	add	r24, r24
    2102:	97 fb       	bst	r25, 7
    2104:	99 1f       	adc	r25, r25
    2106:	61 f0       	breq	.+24     	; 0x2120 <__fp_splitA+0x20>
    2108:	9f 3f       	cpi	r25, 0xFF	; 255
    210a:	79 f0       	breq	.+30     	; 0x212a <__fp_splitA+0x2a>
    210c:	87 95       	ror	r24
    210e:	08 95       	ret
    2110:	12 16       	cp	r1, r18
    2112:	13 06       	cpc	r1, r19
    2114:	14 06       	cpc	r1, r20
    2116:	55 1f       	adc	r21, r21
    2118:	f2 cf       	rjmp	.-28     	; 0x20fe <__fp_split3+0xe>
    211a:	46 95       	lsr	r20
    211c:	f1 df       	rcall	.-30     	; 0x2100 <__fp_splitA>
    211e:	08 c0       	rjmp	.+16     	; 0x2130 <__fp_splitA+0x30>
    2120:	16 16       	cp	r1, r22
    2122:	17 06       	cpc	r1, r23
    2124:	18 06       	cpc	r1, r24
    2126:	99 1f       	adc	r25, r25
    2128:	f1 cf       	rjmp	.-30     	; 0x210c <__fp_splitA+0xc>
    212a:	86 95       	lsr	r24
    212c:	71 05       	cpc	r23, r1
    212e:	61 05       	cpc	r22, r1
    2130:	08 94       	sec
    2132:	08 95       	ret

00002134 <__fp_zero>:
    2134:	e8 94       	clt

00002136 <__fp_szero>:
    2136:	bb 27       	eor	r27, r27
    2138:	66 27       	eor	r22, r22
    213a:	77 27       	eor	r23, r23
    213c:	cb 01       	movw	r24, r22
    213e:	97 f9       	bld	r25, 7
    2140:	08 95       	ret

00002142 <inverse>:
    2142:	9b 01       	movw	r18, r22
    2144:	ac 01       	movw	r20, r24
    2146:	60 e0       	ldi	r22, 0x00	; 0
    2148:	70 e0       	ldi	r23, 0x00	; 0
    214a:	80 e8       	ldi	r24, 0x80	; 128
    214c:	9f e3       	ldi	r25, 0x3F	; 63
    214e:	74 ce       	rjmp	.-792    	; 0x1e38 <__divsf3>

00002150 <__mulsf3>:
    2150:	0b d0       	rcall	.+22     	; 0x2168 <__mulsf3x>
    2152:	bd cf       	rjmp	.-134    	; 0x20ce <__fp_round>
    2154:	ae df       	rcall	.-164    	; 0x20b2 <__fp_pscA>
    2156:	28 f0       	brcs	.+10     	; 0x2162 <__mulsf3+0x12>
    2158:	b3 df       	rcall	.-154    	; 0x20c0 <__fp_pscB>
    215a:	18 f0       	brcs	.+6      	; 0x2162 <__mulsf3+0x12>
    215c:	95 23       	and	r25, r21
    215e:	09 f0       	breq	.+2      	; 0x2162 <__mulsf3+0x12>
    2160:	7a cf       	rjmp	.-268    	; 0x2056 <__fp_inf>
    2162:	7f cf       	rjmp	.-258    	; 0x2062 <__fp_nan>
    2164:	11 24       	eor	r1, r1
    2166:	e7 cf       	rjmp	.-50     	; 0x2136 <__fp_szero>

00002168 <__mulsf3x>:
    2168:	c3 df       	rcall	.-122    	; 0x20f0 <__fp_split3>
    216a:	a0 f3       	brcs	.-24     	; 0x2154 <__mulsf3+0x4>

0000216c <__mulsf3_pse>:
    216c:	95 9f       	mul	r25, r21
    216e:	d1 f3       	breq	.-12     	; 0x2164 <__mulsf3+0x14>
    2170:	95 0f       	add	r25, r21
    2172:	50 e0       	ldi	r21, 0x00	; 0
    2174:	55 1f       	adc	r21, r21
    2176:	62 9f       	mul	r22, r18
    2178:	f0 01       	movw	r30, r0
    217a:	72 9f       	mul	r23, r18
    217c:	bb 27       	eor	r27, r27
    217e:	f0 0d       	add	r31, r0
    2180:	b1 1d       	adc	r27, r1
    2182:	63 9f       	mul	r22, r19
    2184:	aa 27       	eor	r26, r26
    2186:	f0 0d       	add	r31, r0
    2188:	b1 1d       	adc	r27, r1
    218a:	aa 1f       	adc	r26, r26
    218c:	64 9f       	mul	r22, r20
    218e:	66 27       	eor	r22, r22
    2190:	b0 0d       	add	r27, r0
    2192:	a1 1d       	adc	r26, r1
    2194:	66 1f       	adc	r22, r22
    2196:	82 9f       	mul	r24, r18
    2198:	22 27       	eor	r18, r18
    219a:	b0 0d       	add	r27, r0
    219c:	a1 1d       	adc	r26, r1
    219e:	62 1f       	adc	r22, r18
    21a0:	73 9f       	mul	r23, r19
    21a2:	b0 0d       	add	r27, r0
    21a4:	a1 1d       	adc	r26, r1
    21a6:	62 1f       	adc	r22, r18
    21a8:	83 9f       	mul	r24, r19
    21aa:	a0 0d       	add	r26, r0
    21ac:	61 1d       	adc	r22, r1
    21ae:	22 1f       	adc	r18, r18
    21b0:	74 9f       	mul	r23, r20
    21b2:	33 27       	eor	r19, r19
    21b4:	a0 0d       	add	r26, r0
    21b6:	61 1d       	adc	r22, r1
    21b8:	23 1f       	adc	r18, r19
    21ba:	84 9f       	mul	r24, r20
    21bc:	60 0d       	add	r22, r0
    21be:	21 1d       	adc	r18, r1
    21c0:	82 2f       	mov	r24, r18
    21c2:	76 2f       	mov	r23, r22
    21c4:	6a 2f       	mov	r22, r26
    21c6:	11 24       	eor	r1, r1
    21c8:	9f 57       	subi	r25, 0x7F	; 127
    21ca:	50 40       	sbci	r21, 0x00	; 0
    21cc:	8a f0       	brmi	.+34     	; 0x21f0 <__mulsf3_pse+0x84>
    21ce:	e1 f0       	breq	.+56     	; 0x2208 <__stack+0x9>
    21d0:	88 23       	and	r24, r24
    21d2:	4a f0       	brmi	.+18     	; 0x21e6 <__mulsf3_pse+0x7a>
    21d4:	ee 0f       	add	r30, r30
    21d6:	ff 1f       	adc	r31, r31
    21d8:	bb 1f       	adc	r27, r27
    21da:	66 1f       	adc	r22, r22
    21dc:	77 1f       	adc	r23, r23
    21de:	88 1f       	adc	r24, r24
    21e0:	91 50       	subi	r25, 0x01	; 1
    21e2:	50 40       	sbci	r21, 0x00	; 0
    21e4:	a9 f7       	brne	.-22     	; 0x21d0 <__mulsf3_pse+0x64>
    21e6:	9e 3f       	cpi	r25, 0xFE	; 254
    21e8:	51 05       	cpc	r21, r1
    21ea:	70 f0       	brcs	.+28     	; 0x2208 <__stack+0x9>
    21ec:	34 cf       	rjmp	.-408    	; 0x2056 <__fp_inf>
    21ee:	a3 cf       	rjmp	.-186    	; 0x2136 <__fp_szero>
    21f0:	5f 3f       	cpi	r21, 0xFF	; 255
    21f2:	ec f3       	brlt	.-6      	; 0x21ee <__mulsf3_pse+0x82>
    21f4:	98 3e       	cpi	r25, 0xE8	; 232
    21f6:	dc f3       	brlt	.-10     	; 0x21ee <__mulsf3_pse+0x82>
    21f8:	86 95       	lsr	r24
    21fa:	77 95       	ror	r23
    21fc:	67 95       	ror	r22
    21fe:	b7 95       	ror	r27
    2200:	f7 95       	ror	r31
    2202:	e7 95       	ror	r30
    2204:	9f 5f       	subi	r25, 0xFF	; 255
    2206:	c1 f7       	brne	.-16     	; 0x21f8 <__mulsf3_pse+0x8c>
    2208:	fe 2b       	or	r31, r30
    220a:	88 0f       	add	r24, r24
    220c:	91 1d       	adc	r25, r1
    220e:	96 95       	lsr	r25
    2210:	87 95       	ror	r24
    2212:	97 f9       	bld	r25, 7
    2214:	08 95       	ret

00002216 <square>:
    2216:	9b 01       	movw	r18, r22
    2218:	ac 01       	movw	r20, r24
    221a:	9a cf       	rjmp	.-204    	; 0x2150 <__mulsf3>

0000221c <__udivmodhi4>:
    221c:	aa 1b       	sub	r26, r26
    221e:	bb 1b       	sub	r27, r27
    2220:	51 e1       	ldi	r21, 0x11	; 17
    2222:	07 c0       	rjmp	.+14     	; 0x2232 <__udivmodhi4_ep>

00002224 <__udivmodhi4_loop>:
    2224:	aa 1f       	adc	r26, r26
    2226:	bb 1f       	adc	r27, r27
    2228:	a6 17       	cp	r26, r22
    222a:	b7 07       	cpc	r27, r23
    222c:	10 f0       	brcs	.+4      	; 0x2232 <__udivmodhi4_ep>
    222e:	a6 1b       	sub	r26, r22
    2230:	b7 0b       	sbc	r27, r23

00002232 <__udivmodhi4_ep>:
    2232:	88 1f       	adc	r24, r24
    2234:	99 1f       	adc	r25, r25
    2236:	5a 95       	dec	r21
    2238:	a9 f7       	brne	.-22     	; 0x2224 <__udivmodhi4_loop>
    223a:	80 95       	com	r24
    223c:	90 95       	com	r25
    223e:	bc 01       	movw	r22, r24
    2240:	cd 01       	movw	r24, r26
    2242:	08 95       	ret

00002244 <snprintf>:
    2244:	0f 93       	push	r16
    2246:	1f 93       	push	r17
    2248:	cf 93       	push	r28
    224a:	df 93       	push	r29
    224c:	cd b7       	in	r28, 0x3d	; 61
    224e:	de b7       	in	r29, 0x3e	; 62
    2250:	2e 97       	sbiw	r28, 0x0e	; 14
    2252:	0f b6       	in	r0, 0x3f	; 63
    2254:	f8 94       	cli
    2256:	de bf       	out	0x3e, r29	; 62
    2258:	0f be       	out	0x3f, r0	; 63
    225a:	cd bf       	out	0x3d, r28	; 61
    225c:	0e 89       	ldd	r16, Y+22	; 0x16
    225e:	1f 89       	ldd	r17, Y+23	; 0x17
    2260:	88 8d       	ldd	r24, Y+24	; 0x18
    2262:	99 8d       	ldd	r25, Y+25	; 0x19
    2264:	26 e0       	ldi	r18, 0x06	; 6
    2266:	2c 83       	std	Y+4, r18	; 0x04
    2268:	1a 83       	std	Y+2, r17	; 0x02
    226a:	09 83       	std	Y+1, r16	; 0x01
    226c:	97 ff       	sbrs	r25, 7
    226e:	02 c0       	rjmp	.+4      	; 0x2274 <snprintf+0x30>
    2270:	80 e0       	ldi	r24, 0x00	; 0
    2272:	90 e8       	ldi	r25, 0x80	; 128
    2274:	01 97       	sbiw	r24, 0x01	; 1
    2276:	9e 83       	std	Y+6, r25	; 0x06
    2278:	8d 83       	std	Y+5, r24	; 0x05
    227a:	ae 01       	movw	r20, r28
    227c:	44 5e       	subi	r20, 0xE4	; 228
    227e:	5f 4f       	sbci	r21, 0xFF	; 255
    2280:	ce 01       	movw	r24, r28
    2282:	01 96       	adiw	r24, 0x01	; 1
    2284:	6a 8d       	ldd	r22, Y+26	; 0x1a
    2286:	7b 8d       	ldd	r23, Y+27	; 0x1b
    2288:	0e 94 5f 11 	call	0x22be	; 0x22be <vfprintf>
    228c:	4d 81       	ldd	r20, Y+5	; 0x05
    228e:	5e 81       	ldd	r21, Y+6	; 0x06
    2290:	57 fd       	sbrc	r21, 7
    2292:	0a c0       	rjmp	.+20     	; 0x22a8 <snprintf+0x64>
    2294:	2f 81       	ldd	r18, Y+7	; 0x07
    2296:	38 85       	ldd	r19, Y+8	; 0x08
    2298:	42 17       	cp	r20, r18
    229a:	53 07       	cpc	r21, r19
    229c:	0c f4       	brge	.+2      	; 0x22a0 <snprintf+0x5c>
    229e:	9a 01       	movw	r18, r20
    22a0:	02 0f       	add	r16, r18
    22a2:	13 1f       	adc	r17, r19
    22a4:	f8 01       	movw	r30, r16
    22a6:	10 82       	st	Z, r1
    22a8:	2e 96       	adiw	r28, 0x0e	; 14
    22aa:	0f b6       	in	r0, 0x3f	; 63
    22ac:	f8 94       	cli
    22ae:	de bf       	out	0x3e, r29	; 62
    22b0:	0f be       	out	0x3f, r0	; 63
    22b2:	cd bf       	out	0x3d, r28	; 61
    22b4:	df 91       	pop	r29
    22b6:	cf 91       	pop	r28
    22b8:	1f 91       	pop	r17
    22ba:	0f 91       	pop	r16
    22bc:	08 95       	ret

000022be <vfprintf>:
    22be:	2f 92       	push	r2
    22c0:	3f 92       	push	r3
    22c2:	4f 92       	push	r4
    22c4:	5f 92       	push	r5
    22c6:	6f 92       	push	r6
    22c8:	7f 92       	push	r7
    22ca:	8f 92       	push	r8
    22cc:	9f 92       	push	r9
    22ce:	af 92       	push	r10
    22d0:	bf 92       	push	r11
    22d2:	cf 92       	push	r12
    22d4:	df 92       	push	r13
    22d6:	ef 92       	push	r14
    22d8:	ff 92       	push	r15
    22da:	0f 93       	push	r16
    22dc:	1f 93       	push	r17
    22de:	cf 93       	push	r28
    22e0:	df 93       	push	r29
    22e2:	cd b7       	in	r28, 0x3d	; 61
    22e4:	de b7       	in	r29, 0x3e	; 62
    22e6:	2d 97       	sbiw	r28, 0x0d	; 13
    22e8:	0f b6       	in	r0, 0x3f	; 63
    22ea:	f8 94       	cli
    22ec:	de bf       	out	0x3e, r29	; 62
    22ee:	0f be       	out	0x3f, r0	; 63
    22f0:	cd bf       	out	0x3d, r28	; 61
    22f2:	3c 01       	movw	r6, r24
    22f4:	7d 87       	std	Y+13, r23	; 0x0d
    22f6:	6c 87       	std	Y+12, r22	; 0x0c
    22f8:	5a 01       	movw	r10, r20
    22fa:	fc 01       	movw	r30, r24
    22fc:	17 82       	std	Z+7, r1	; 0x07
    22fe:	16 82       	std	Z+6, r1	; 0x06
    2300:	83 81       	ldd	r24, Z+3	; 0x03
    2302:	81 ff       	sbrs	r24, 1
    2304:	c8 c1       	rjmp	.+912    	; 0x2696 <vfprintf+0x3d8>
    2306:	2e 01       	movw	r4, r28
    2308:	08 94       	sec
    230a:	41 1c       	adc	r4, r1
    230c:	51 1c       	adc	r5, r1
    230e:	f3 01       	movw	r30, r6
    2310:	93 81       	ldd	r25, Z+3	; 0x03
    2312:	ec 85       	ldd	r30, Y+12	; 0x0c
    2314:	fd 85       	ldd	r31, Y+13	; 0x0d
    2316:	93 fd       	sbrc	r25, 3
    2318:	85 91       	lpm	r24, Z+
    231a:	93 ff       	sbrs	r25, 3
    231c:	81 91       	ld	r24, Z+
    231e:	fd 87       	std	Y+13, r31	; 0x0d
    2320:	ec 87       	std	Y+12, r30	; 0x0c
    2322:	88 23       	and	r24, r24
    2324:	09 f4       	brne	.+2      	; 0x2328 <vfprintf+0x6a>
    2326:	b3 c1       	rjmp	.+870    	; 0x268e <vfprintf+0x3d0>
    2328:	85 32       	cpi	r24, 0x25	; 37
    232a:	41 f4       	brne	.+16     	; 0x233c <vfprintf+0x7e>
    232c:	93 fd       	sbrc	r25, 3
    232e:	85 91       	lpm	r24, Z+
    2330:	93 ff       	sbrs	r25, 3
    2332:	81 91       	ld	r24, Z+
    2334:	fd 87       	std	Y+13, r31	; 0x0d
    2336:	ec 87       	std	Y+12, r30	; 0x0c
    2338:	85 32       	cpi	r24, 0x25	; 37
    233a:	29 f4       	brne	.+10     	; 0x2346 <vfprintf+0x88>
    233c:	90 e0       	ldi	r25, 0x00	; 0
    233e:	b3 01       	movw	r22, r6
    2340:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <fputc>
    2344:	e4 cf       	rjmp	.-56     	; 0x230e <vfprintf+0x50>
    2346:	ff 24       	eor	r15, r15
    2348:	ee 24       	eor	r14, r14
    234a:	10 e0       	ldi	r17, 0x00	; 0
    234c:	10 32       	cpi	r17, 0x20	; 32
    234e:	b0 f4       	brcc	.+44     	; 0x237c <vfprintf+0xbe>
    2350:	8b 32       	cpi	r24, 0x2B	; 43
    2352:	69 f0       	breq	.+26     	; 0x236e <vfprintf+0xb0>
    2354:	8c 32       	cpi	r24, 0x2C	; 44
    2356:	28 f4       	brcc	.+10     	; 0x2362 <vfprintf+0xa4>
    2358:	80 32       	cpi	r24, 0x20	; 32
    235a:	51 f0       	breq	.+20     	; 0x2370 <vfprintf+0xb2>
    235c:	83 32       	cpi	r24, 0x23	; 35
    235e:	71 f4       	brne	.+28     	; 0x237c <vfprintf+0xbe>
    2360:	0b c0       	rjmp	.+22     	; 0x2378 <vfprintf+0xba>
    2362:	8d 32       	cpi	r24, 0x2D	; 45
    2364:	39 f0       	breq	.+14     	; 0x2374 <vfprintf+0xb6>
    2366:	80 33       	cpi	r24, 0x30	; 48
    2368:	49 f4       	brne	.+18     	; 0x237c <vfprintf+0xbe>
    236a:	11 60       	ori	r17, 0x01	; 1
    236c:	2c c0       	rjmp	.+88     	; 0x23c6 <vfprintf+0x108>
    236e:	12 60       	ori	r17, 0x02	; 2
    2370:	14 60       	ori	r17, 0x04	; 4
    2372:	29 c0       	rjmp	.+82     	; 0x23c6 <vfprintf+0x108>
    2374:	18 60       	ori	r17, 0x08	; 8
    2376:	27 c0       	rjmp	.+78     	; 0x23c6 <vfprintf+0x108>
    2378:	10 61       	ori	r17, 0x10	; 16
    237a:	25 c0       	rjmp	.+74     	; 0x23c6 <vfprintf+0x108>
    237c:	17 fd       	sbrc	r17, 7
    237e:	2e c0       	rjmp	.+92     	; 0x23dc <vfprintf+0x11e>
    2380:	28 2f       	mov	r18, r24
    2382:	20 53       	subi	r18, 0x30	; 48
    2384:	2a 30       	cpi	r18, 0x0A	; 10
    2386:	98 f4       	brcc	.+38     	; 0x23ae <vfprintf+0xf0>
    2388:	16 ff       	sbrs	r17, 6
    238a:	08 c0       	rjmp	.+16     	; 0x239c <vfprintf+0xde>
    238c:	8f 2d       	mov	r24, r15
    238e:	88 0f       	add	r24, r24
    2390:	f8 2e       	mov	r15, r24
    2392:	ff 0c       	add	r15, r15
    2394:	ff 0c       	add	r15, r15
    2396:	f8 0e       	add	r15, r24
    2398:	f2 0e       	add	r15, r18
    239a:	15 c0       	rjmp	.+42     	; 0x23c6 <vfprintf+0x108>
    239c:	8e 2d       	mov	r24, r14
    239e:	88 0f       	add	r24, r24
    23a0:	e8 2e       	mov	r14, r24
    23a2:	ee 0c       	add	r14, r14
    23a4:	ee 0c       	add	r14, r14
    23a6:	e8 0e       	add	r14, r24
    23a8:	e2 0e       	add	r14, r18
    23aa:	10 62       	ori	r17, 0x20	; 32
    23ac:	0c c0       	rjmp	.+24     	; 0x23c6 <vfprintf+0x108>
    23ae:	8e 32       	cpi	r24, 0x2E	; 46
    23b0:	21 f4       	brne	.+8      	; 0x23ba <vfprintf+0xfc>
    23b2:	16 fd       	sbrc	r17, 6
    23b4:	6c c1       	rjmp	.+728    	; 0x268e <vfprintf+0x3d0>
    23b6:	10 64       	ori	r17, 0x40	; 64
    23b8:	06 c0       	rjmp	.+12     	; 0x23c6 <vfprintf+0x108>
    23ba:	8c 36       	cpi	r24, 0x6C	; 108
    23bc:	11 f4       	brne	.+4      	; 0x23c2 <vfprintf+0x104>
    23be:	10 68       	ori	r17, 0x80	; 128
    23c0:	02 c0       	rjmp	.+4      	; 0x23c6 <vfprintf+0x108>
    23c2:	88 36       	cpi	r24, 0x68	; 104
    23c4:	59 f4       	brne	.+22     	; 0x23dc <vfprintf+0x11e>
    23c6:	ec 85       	ldd	r30, Y+12	; 0x0c
    23c8:	fd 85       	ldd	r31, Y+13	; 0x0d
    23ca:	93 fd       	sbrc	r25, 3
    23cc:	85 91       	lpm	r24, Z+
    23ce:	93 ff       	sbrs	r25, 3
    23d0:	81 91       	ld	r24, Z+
    23d2:	fd 87       	std	Y+13, r31	; 0x0d
    23d4:	ec 87       	std	Y+12, r30	; 0x0c
    23d6:	88 23       	and	r24, r24
    23d8:	09 f0       	breq	.+2      	; 0x23dc <vfprintf+0x11e>
    23da:	b8 cf       	rjmp	.-144    	; 0x234c <vfprintf+0x8e>
    23dc:	98 2f       	mov	r25, r24
    23de:	95 54       	subi	r25, 0x45	; 69
    23e0:	93 30       	cpi	r25, 0x03	; 3
    23e2:	18 f0       	brcs	.+6      	; 0x23ea <vfprintf+0x12c>
    23e4:	90 52       	subi	r25, 0x20	; 32
    23e6:	93 30       	cpi	r25, 0x03	; 3
    23e8:	38 f4       	brcc	.+14     	; 0x23f8 <vfprintf+0x13a>
    23ea:	24 e0       	ldi	r18, 0x04	; 4
    23ec:	30 e0       	ldi	r19, 0x00	; 0
    23ee:	a2 0e       	add	r10, r18
    23f0:	b3 1e       	adc	r11, r19
    23f2:	3f e3       	ldi	r19, 0x3F	; 63
    23f4:	39 83       	std	Y+1, r19	; 0x01
    23f6:	0f c0       	rjmp	.+30     	; 0x2416 <vfprintf+0x158>
    23f8:	83 36       	cpi	r24, 0x63	; 99
    23fa:	31 f0       	breq	.+12     	; 0x2408 <vfprintf+0x14a>
    23fc:	83 37       	cpi	r24, 0x73	; 115
    23fe:	81 f0       	breq	.+32     	; 0x2420 <vfprintf+0x162>
    2400:	83 35       	cpi	r24, 0x53	; 83
    2402:	09 f0       	breq	.+2      	; 0x2406 <vfprintf+0x148>
    2404:	5a c0       	rjmp	.+180    	; 0x24ba <vfprintf+0x1fc>
    2406:	22 c0       	rjmp	.+68     	; 0x244c <vfprintf+0x18e>
    2408:	f5 01       	movw	r30, r10
    240a:	80 81       	ld	r24, Z
    240c:	89 83       	std	Y+1, r24	; 0x01
    240e:	22 e0       	ldi	r18, 0x02	; 2
    2410:	30 e0       	ldi	r19, 0x00	; 0
    2412:	a2 0e       	add	r10, r18
    2414:	b3 1e       	adc	r11, r19
    2416:	21 e0       	ldi	r18, 0x01	; 1
    2418:	c2 2e       	mov	r12, r18
    241a:	d1 2c       	mov	r13, r1
    241c:	42 01       	movw	r8, r4
    241e:	14 c0       	rjmp	.+40     	; 0x2448 <vfprintf+0x18a>
    2420:	92 e0       	ldi	r25, 0x02	; 2
    2422:	29 2e       	mov	r2, r25
    2424:	31 2c       	mov	r3, r1
    2426:	2a 0c       	add	r2, r10
    2428:	3b 1c       	adc	r3, r11
    242a:	f5 01       	movw	r30, r10
    242c:	80 80       	ld	r8, Z
    242e:	91 80       	ldd	r9, Z+1	; 0x01
    2430:	16 ff       	sbrs	r17, 6
    2432:	03 c0       	rjmp	.+6      	; 0x243a <vfprintf+0x17c>
    2434:	6f 2d       	mov	r22, r15
    2436:	70 e0       	ldi	r23, 0x00	; 0
    2438:	02 c0       	rjmp	.+4      	; 0x243e <vfprintf+0x180>
    243a:	6f ef       	ldi	r22, 0xFF	; 255
    243c:	7f ef       	ldi	r23, 0xFF	; 255
    243e:	c4 01       	movw	r24, r8
    2440:	0e 94 71 13 	call	0x26e2	; 0x26e2 <strnlen>
    2444:	6c 01       	movw	r12, r24
    2446:	51 01       	movw	r10, r2
    2448:	1f 77       	andi	r17, 0x7F	; 127
    244a:	15 c0       	rjmp	.+42     	; 0x2476 <vfprintf+0x1b8>
    244c:	82 e0       	ldi	r24, 0x02	; 2
    244e:	28 2e       	mov	r2, r24
    2450:	31 2c       	mov	r3, r1
    2452:	2a 0c       	add	r2, r10
    2454:	3b 1c       	adc	r3, r11
    2456:	f5 01       	movw	r30, r10
    2458:	80 80       	ld	r8, Z
    245a:	91 80       	ldd	r9, Z+1	; 0x01
    245c:	16 ff       	sbrs	r17, 6
    245e:	03 c0       	rjmp	.+6      	; 0x2466 <vfprintf+0x1a8>
    2460:	6f 2d       	mov	r22, r15
    2462:	70 e0       	ldi	r23, 0x00	; 0
    2464:	02 c0       	rjmp	.+4      	; 0x246a <vfprintf+0x1ac>
    2466:	6f ef       	ldi	r22, 0xFF	; 255
    2468:	7f ef       	ldi	r23, 0xFF	; 255
    246a:	c4 01       	movw	r24, r8
    246c:	0e 94 66 13 	call	0x26cc	; 0x26cc <strnlen_P>
    2470:	6c 01       	movw	r12, r24
    2472:	10 68       	ori	r17, 0x80	; 128
    2474:	51 01       	movw	r10, r2
    2476:	13 fd       	sbrc	r17, 3
    2478:	1c c0       	rjmp	.+56     	; 0x24b2 <vfprintf+0x1f4>
    247a:	06 c0       	rjmp	.+12     	; 0x2488 <vfprintf+0x1ca>
    247c:	80 e2       	ldi	r24, 0x20	; 32
    247e:	90 e0       	ldi	r25, 0x00	; 0
    2480:	b3 01       	movw	r22, r6
    2482:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <fputc>
    2486:	ea 94       	dec	r14
    2488:	8e 2d       	mov	r24, r14
    248a:	90 e0       	ldi	r25, 0x00	; 0
    248c:	c8 16       	cp	r12, r24
    248e:	d9 06       	cpc	r13, r25
    2490:	a8 f3       	brcs	.-22     	; 0x247c <vfprintf+0x1be>
    2492:	0f c0       	rjmp	.+30     	; 0x24b2 <vfprintf+0x1f4>
    2494:	f4 01       	movw	r30, r8
    2496:	17 fd       	sbrc	r17, 7
    2498:	85 91       	lpm	r24, Z+
    249a:	17 ff       	sbrs	r17, 7
    249c:	81 91       	ld	r24, Z+
    249e:	4f 01       	movw	r8, r30
    24a0:	90 e0       	ldi	r25, 0x00	; 0
    24a2:	b3 01       	movw	r22, r6
    24a4:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <fputc>
    24a8:	e1 10       	cpse	r14, r1
    24aa:	ea 94       	dec	r14
    24ac:	08 94       	sec
    24ae:	c1 08       	sbc	r12, r1
    24b0:	d1 08       	sbc	r13, r1
    24b2:	c1 14       	cp	r12, r1
    24b4:	d1 04       	cpc	r13, r1
    24b6:	71 f7       	brne	.-36     	; 0x2494 <vfprintf+0x1d6>
    24b8:	e7 c0       	rjmp	.+462    	; 0x2688 <vfprintf+0x3ca>
    24ba:	84 36       	cpi	r24, 0x64	; 100
    24bc:	11 f0       	breq	.+4      	; 0x24c2 <vfprintf+0x204>
    24be:	89 36       	cpi	r24, 0x69	; 105
    24c0:	51 f5       	brne	.+84     	; 0x2516 <vfprintf+0x258>
    24c2:	f5 01       	movw	r30, r10
    24c4:	17 ff       	sbrs	r17, 7
    24c6:	07 c0       	rjmp	.+14     	; 0x24d6 <vfprintf+0x218>
    24c8:	80 81       	ld	r24, Z
    24ca:	91 81       	ldd	r25, Z+1	; 0x01
    24cc:	a2 81       	ldd	r26, Z+2	; 0x02
    24ce:	b3 81       	ldd	r27, Z+3	; 0x03
    24d0:	24 e0       	ldi	r18, 0x04	; 4
    24d2:	30 e0       	ldi	r19, 0x00	; 0
    24d4:	08 c0       	rjmp	.+16     	; 0x24e6 <vfprintf+0x228>
    24d6:	80 81       	ld	r24, Z
    24d8:	91 81       	ldd	r25, Z+1	; 0x01
    24da:	aa 27       	eor	r26, r26
    24dc:	97 fd       	sbrc	r25, 7
    24de:	a0 95       	com	r26
    24e0:	ba 2f       	mov	r27, r26
    24e2:	22 e0       	ldi	r18, 0x02	; 2
    24e4:	30 e0       	ldi	r19, 0x00	; 0
    24e6:	a2 0e       	add	r10, r18
    24e8:	b3 1e       	adc	r11, r19
    24ea:	01 2f       	mov	r16, r17
    24ec:	0f 76       	andi	r16, 0x6F	; 111
    24ee:	b7 ff       	sbrs	r27, 7
    24f0:	08 c0       	rjmp	.+16     	; 0x2502 <vfprintf+0x244>
    24f2:	b0 95       	com	r27
    24f4:	a0 95       	com	r26
    24f6:	90 95       	com	r25
    24f8:	81 95       	neg	r24
    24fa:	9f 4f       	sbci	r25, 0xFF	; 255
    24fc:	af 4f       	sbci	r26, 0xFF	; 255
    24fe:	bf 4f       	sbci	r27, 0xFF	; 255
    2500:	00 68       	ori	r16, 0x80	; 128
    2502:	bc 01       	movw	r22, r24
    2504:	cd 01       	movw	r24, r26
    2506:	a2 01       	movw	r20, r4
    2508:	2a e0       	ldi	r18, 0x0A	; 10
    250a:	30 e0       	ldi	r19, 0x00	; 0
    250c:	0e 94 a8 13 	call	0x2750	; 0x2750 <__ultoa_invert>
    2510:	d8 2e       	mov	r13, r24
    2512:	d4 18       	sub	r13, r4
    2514:	3f c0       	rjmp	.+126    	; 0x2594 <vfprintf+0x2d6>
    2516:	85 37       	cpi	r24, 0x75	; 117
    2518:	21 f4       	brne	.+8      	; 0x2522 <vfprintf+0x264>
    251a:	1f 7e       	andi	r17, 0xEF	; 239
    251c:	2a e0       	ldi	r18, 0x0A	; 10
    251e:	30 e0       	ldi	r19, 0x00	; 0
    2520:	20 c0       	rjmp	.+64     	; 0x2562 <vfprintf+0x2a4>
    2522:	19 7f       	andi	r17, 0xF9	; 249
    2524:	8f 36       	cpi	r24, 0x6F	; 111
    2526:	a9 f0       	breq	.+42     	; 0x2552 <vfprintf+0x294>
    2528:	80 37       	cpi	r24, 0x70	; 112
    252a:	20 f4       	brcc	.+8      	; 0x2534 <vfprintf+0x276>
    252c:	88 35       	cpi	r24, 0x58	; 88
    252e:	09 f0       	breq	.+2      	; 0x2532 <vfprintf+0x274>
    2530:	ae c0       	rjmp	.+348    	; 0x268e <vfprintf+0x3d0>
    2532:	0b c0       	rjmp	.+22     	; 0x254a <vfprintf+0x28c>
    2534:	80 37       	cpi	r24, 0x70	; 112
    2536:	21 f0       	breq	.+8      	; 0x2540 <vfprintf+0x282>
    2538:	88 37       	cpi	r24, 0x78	; 120
    253a:	09 f0       	breq	.+2      	; 0x253e <vfprintf+0x280>
    253c:	a8 c0       	rjmp	.+336    	; 0x268e <vfprintf+0x3d0>
    253e:	01 c0       	rjmp	.+2      	; 0x2542 <vfprintf+0x284>
    2540:	10 61       	ori	r17, 0x10	; 16
    2542:	14 ff       	sbrs	r17, 4
    2544:	09 c0       	rjmp	.+18     	; 0x2558 <vfprintf+0x29a>
    2546:	14 60       	ori	r17, 0x04	; 4
    2548:	07 c0       	rjmp	.+14     	; 0x2558 <vfprintf+0x29a>
    254a:	14 ff       	sbrs	r17, 4
    254c:	08 c0       	rjmp	.+16     	; 0x255e <vfprintf+0x2a0>
    254e:	16 60       	ori	r17, 0x06	; 6
    2550:	06 c0       	rjmp	.+12     	; 0x255e <vfprintf+0x2a0>
    2552:	28 e0       	ldi	r18, 0x08	; 8
    2554:	30 e0       	ldi	r19, 0x00	; 0
    2556:	05 c0       	rjmp	.+10     	; 0x2562 <vfprintf+0x2a4>
    2558:	20 e1       	ldi	r18, 0x10	; 16
    255a:	30 e0       	ldi	r19, 0x00	; 0
    255c:	02 c0       	rjmp	.+4      	; 0x2562 <vfprintf+0x2a4>
    255e:	20 e1       	ldi	r18, 0x10	; 16
    2560:	32 e0       	ldi	r19, 0x02	; 2
    2562:	f5 01       	movw	r30, r10
    2564:	17 ff       	sbrs	r17, 7
    2566:	07 c0       	rjmp	.+14     	; 0x2576 <vfprintf+0x2b8>
    2568:	60 81       	ld	r22, Z
    256a:	71 81       	ldd	r23, Z+1	; 0x01
    256c:	82 81       	ldd	r24, Z+2	; 0x02
    256e:	93 81       	ldd	r25, Z+3	; 0x03
    2570:	44 e0       	ldi	r20, 0x04	; 4
    2572:	50 e0       	ldi	r21, 0x00	; 0
    2574:	06 c0       	rjmp	.+12     	; 0x2582 <vfprintf+0x2c4>
    2576:	60 81       	ld	r22, Z
    2578:	71 81       	ldd	r23, Z+1	; 0x01
    257a:	80 e0       	ldi	r24, 0x00	; 0
    257c:	90 e0       	ldi	r25, 0x00	; 0
    257e:	42 e0       	ldi	r20, 0x02	; 2
    2580:	50 e0       	ldi	r21, 0x00	; 0
    2582:	a4 0e       	add	r10, r20
    2584:	b5 1e       	adc	r11, r21
    2586:	a2 01       	movw	r20, r4
    2588:	0e 94 a8 13 	call	0x2750	; 0x2750 <__ultoa_invert>
    258c:	d8 2e       	mov	r13, r24
    258e:	d4 18       	sub	r13, r4
    2590:	01 2f       	mov	r16, r17
    2592:	0f 77       	andi	r16, 0x7F	; 127
    2594:	06 ff       	sbrs	r16, 6
    2596:	09 c0       	rjmp	.+18     	; 0x25aa <vfprintf+0x2ec>
    2598:	0e 7f       	andi	r16, 0xFE	; 254
    259a:	df 14       	cp	r13, r15
    259c:	30 f4       	brcc	.+12     	; 0x25aa <vfprintf+0x2ec>
    259e:	04 ff       	sbrs	r16, 4
    25a0:	06 c0       	rjmp	.+12     	; 0x25ae <vfprintf+0x2f0>
    25a2:	02 fd       	sbrc	r16, 2
    25a4:	04 c0       	rjmp	.+8      	; 0x25ae <vfprintf+0x2f0>
    25a6:	0f 7e       	andi	r16, 0xEF	; 239
    25a8:	02 c0       	rjmp	.+4      	; 0x25ae <vfprintf+0x2f0>
    25aa:	1d 2d       	mov	r17, r13
    25ac:	01 c0       	rjmp	.+2      	; 0x25b0 <vfprintf+0x2f2>
    25ae:	1f 2d       	mov	r17, r15
    25b0:	80 2f       	mov	r24, r16
    25b2:	90 e0       	ldi	r25, 0x00	; 0
    25b4:	04 ff       	sbrs	r16, 4
    25b6:	0c c0       	rjmp	.+24     	; 0x25d0 <vfprintf+0x312>
    25b8:	fe 01       	movw	r30, r28
    25ba:	ed 0d       	add	r30, r13
    25bc:	f1 1d       	adc	r31, r1
    25be:	20 81       	ld	r18, Z
    25c0:	20 33       	cpi	r18, 0x30	; 48
    25c2:	11 f4       	brne	.+4      	; 0x25c8 <vfprintf+0x30a>
    25c4:	09 7e       	andi	r16, 0xE9	; 233
    25c6:	09 c0       	rjmp	.+18     	; 0x25da <vfprintf+0x31c>
    25c8:	02 ff       	sbrs	r16, 2
    25ca:	06 c0       	rjmp	.+12     	; 0x25d8 <vfprintf+0x31a>
    25cc:	1e 5f       	subi	r17, 0xFE	; 254
    25ce:	05 c0       	rjmp	.+10     	; 0x25da <vfprintf+0x31c>
    25d0:	86 78       	andi	r24, 0x86	; 134
    25d2:	90 70       	andi	r25, 0x00	; 0
    25d4:	00 97       	sbiw	r24, 0x00	; 0
    25d6:	09 f0       	breq	.+2      	; 0x25da <vfprintf+0x31c>
    25d8:	1f 5f       	subi	r17, 0xFF	; 255
    25da:	80 2e       	mov	r8, r16
    25dc:	99 24       	eor	r9, r9
    25de:	03 fd       	sbrc	r16, 3
    25e0:	12 c0       	rjmp	.+36     	; 0x2606 <vfprintf+0x348>
    25e2:	00 ff       	sbrs	r16, 0
    25e4:	0d c0       	rjmp	.+26     	; 0x2600 <vfprintf+0x342>
    25e6:	fd 2c       	mov	r15, r13
    25e8:	1e 15       	cp	r17, r14
    25ea:	50 f4       	brcc	.+20     	; 0x2600 <vfprintf+0x342>
    25ec:	fe 0c       	add	r15, r14
    25ee:	f1 1a       	sub	r15, r17
    25f0:	1e 2d       	mov	r17, r14
    25f2:	06 c0       	rjmp	.+12     	; 0x2600 <vfprintf+0x342>
    25f4:	80 e2       	ldi	r24, 0x20	; 32
    25f6:	90 e0       	ldi	r25, 0x00	; 0
    25f8:	b3 01       	movw	r22, r6
    25fa:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <fputc>
    25fe:	1f 5f       	subi	r17, 0xFF	; 255
    2600:	1e 15       	cp	r17, r14
    2602:	c0 f3       	brcs	.-16     	; 0x25f4 <vfprintf+0x336>
    2604:	04 c0       	rjmp	.+8      	; 0x260e <vfprintf+0x350>
    2606:	1e 15       	cp	r17, r14
    2608:	10 f4       	brcc	.+4      	; 0x260e <vfprintf+0x350>
    260a:	e1 1a       	sub	r14, r17
    260c:	01 c0       	rjmp	.+2      	; 0x2610 <vfprintf+0x352>
    260e:	ee 24       	eor	r14, r14
    2610:	84 fe       	sbrs	r8, 4
    2612:	0f c0       	rjmp	.+30     	; 0x2632 <vfprintf+0x374>
    2614:	80 e3       	ldi	r24, 0x30	; 48
    2616:	90 e0       	ldi	r25, 0x00	; 0
    2618:	b3 01       	movw	r22, r6
    261a:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <fputc>
    261e:	82 fe       	sbrs	r8, 2
    2620:	1f c0       	rjmp	.+62     	; 0x2660 <vfprintf+0x3a2>
    2622:	81 fe       	sbrs	r8, 1
    2624:	03 c0       	rjmp	.+6      	; 0x262c <vfprintf+0x36e>
    2626:	88 e5       	ldi	r24, 0x58	; 88
    2628:	90 e0       	ldi	r25, 0x00	; 0
    262a:	10 c0       	rjmp	.+32     	; 0x264c <vfprintf+0x38e>
    262c:	88 e7       	ldi	r24, 0x78	; 120
    262e:	90 e0       	ldi	r25, 0x00	; 0
    2630:	0d c0       	rjmp	.+26     	; 0x264c <vfprintf+0x38e>
    2632:	c4 01       	movw	r24, r8
    2634:	86 78       	andi	r24, 0x86	; 134
    2636:	90 70       	andi	r25, 0x00	; 0
    2638:	00 97       	sbiw	r24, 0x00	; 0
    263a:	91 f0       	breq	.+36     	; 0x2660 <vfprintf+0x3a2>
    263c:	81 fc       	sbrc	r8, 1
    263e:	02 c0       	rjmp	.+4      	; 0x2644 <vfprintf+0x386>
    2640:	80 e2       	ldi	r24, 0x20	; 32
    2642:	01 c0       	rjmp	.+2      	; 0x2646 <vfprintf+0x388>
    2644:	8b e2       	ldi	r24, 0x2B	; 43
    2646:	07 fd       	sbrc	r16, 7
    2648:	8d e2       	ldi	r24, 0x2D	; 45
    264a:	90 e0       	ldi	r25, 0x00	; 0
    264c:	b3 01       	movw	r22, r6
    264e:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <fputc>
    2652:	06 c0       	rjmp	.+12     	; 0x2660 <vfprintf+0x3a2>
    2654:	80 e3       	ldi	r24, 0x30	; 48
    2656:	90 e0       	ldi	r25, 0x00	; 0
    2658:	b3 01       	movw	r22, r6
    265a:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <fputc>
    265e:	fa 94       	dec	r15
    2660:	df 14       	cp	r13, r15
    2662:	c0 f3       	brcs	.-16     	; 0x2654 <vfprintf+0x396>
    2664:	da 94       	dec	r13
    2666:	f2 01       	movw	r30, r4
    2668:	ed 0d       	add	r30, r13
    266a:	f1 1d       	adc	r31, r1
    266c:	80 81       	ld	r24, Z
    266e:	90 e0       	ldi	r25, 0x00	; 0
    2670:	b3 01       	movw	r22, r6
    2672:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <fputc>
    2676:	dd 20       	and	r13, r13
    2678:	a9 f7       	brne	.-22     	; 0x2664 <vfprintf+0x3a6>
    267a:	06 c0       	rjmp	.+12     	; 0x2688 <vfprintf+0x3ca>
    267c:	80 e2       	ldi	r24, 0x20	; 32
    267e:	90 e0       	ldi	r25, 0x00	; 0
    2680:	b3 01       	movw	r22, r6
    2682:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <fputc>
    2686:	ea 94       	dec	r14
    2688:	ee 20       	and	r14, r14
    268a:	c1 f7       	brne	.-16     	; 0x267c <vfprintf+0x3be>
    268c:	40 ce       	rjmp	.-896    	; 0x230e <vfprintf+0x50>
    268e:	f3 01       	movw	r30, r6
    2690:	86 81       	ldd	r24, Z+6	; 0x06
    2692:	97 81       	ldd	r25, Z+7	; 0x07
    2694:	02 c0       	rjmp	.+4      	; 0x269a <vfprintf+0x3dc>
    2696:	8f ef       	ldi	r24, 0xFF	; 255
    2698:	9f ef       	ldi	r25, 0xFF	; 255
    269a:	2d 96       	adiw	r28, 0x0d	; 13
    269c:	0f b6       	in	r0, 0x3f	; 63
    269e:	f8 94       	cli
    26a0:	de bf       	out	0x3e, r29	; 62
    26a2:	0f be       	out	0x3f, r0	; 63
    26a4:	cd bf       	out	0x3d, r28	; 61
    26a6:	df 91       	pop	r29
    26a8:	cf 91       	pop	r28
    26aa:	1f 91       	pop	r17
    26ac:	0f 91       	pop	r16
    26ae:	ff 90       	pop	r15
    26b0:	ef 90       	pop	r14
    26b2:	df 90       	pop	r13
    26b4:	cf 90       	pop	r12
    26b6:	bf 90       	pop	r11
    26b8:	af 90       	pop	r10
    26ba:	9f 90       	pop	r9
    26bc:	8f 90       	pop	r8
    26be:	7f 90       	pop	r7
    26c0:	6f 90       	pop	r6
    26c2:	5f 90       	pop	r5
    26c4:	4f 90       	pop	r4
    26c6:	3f 90       	pop	r3
    26c8:	2f 90       	pop	r2
    26ca:	08 95       	ret

000026cc <strnlen_P>:
    26cc:	fc 01       	movw	r30, r24
    26ce:	05 90       	lpm	r0, Z+
    26d0:	61 50       	subi	r22, 0x01	; 1
    26d2:	70 40       	sbci	r23, 0x00	; 0
    26d4:	01 10       	cpse	r0, r1
    26d6:	d8 f7       	brcc	.-10     	; 0x26ce <strnlen_P+0x2>
    26d8:	80 95       	com	r24
    26da:	90 95       	com	r25
    26dc:	8e 0f       	add	r24, r30
    26de:	9f 1f       	adc	r25, r31
    26e0:	08 95       	ret

000026e2 <strnlen>:
    26e2:	fc 01       	movw	r30, r24
    26e4:	61 50       	subi	r22, 0x01	; 1
    26e6:	70 40       	sbci	r23, 0x00	; 0
    26e8:	01 90       	ld	r0, Z+
    26ea:	01 10       	cpse	r0, r1
    26ec:	d8 f7       	brcc	.-10     	; 0x26e4 <strnlen+0x2>
    26ee:	80 95       	com	r24
    26f0:	90 95       	com	r25
    26f2:	8e 0f       	add	r24, r30
    26f4:	9f 1f       	adc	r25, r31
    26f6:	08 95       	ret

000026f8 <fputc>:
    26f8:	0f 93       	push	r16
    26fa:	1f 93       	push	r17
    26fc:	cf 93       	push	r28
    26fe:	df 93       	push	r29
    2700:	8c 01       	movw	r16, r24
    2702:	eb 01       	movw	r28, r22
    2704:	8b 81       	ldd	r24, Y+3	; 0x03
    2706:	81 ff       	sbrs	r24, 1
    2708:	1b c0       	rjmp	.+54     	; 0x2740 <fputc+0x48>
    270a:	82 ff       	sbrs	r24, 2
    270c:	0d c0       	rjmp	.+26     	; 0x2728 <fputc+0x30>
    270e:	2e 81       	ldd	r18, Y+6	; 0x06
    2710:	3f 81       	ldd	r19, Y+7	; 0x07
    2712:	8c 81       	ldd	r24, Y+4	; 0x04
    2714:	9d 81       	ldd	r25, Y+5	; 0x05
    2716:	28 17       	cp	r18, r24
    2718:	39 07       	cpc	r19, r25
    271a:	64 f4       	brge	.+24     	; 0x2734 <fputc+0x3c>
    271c:	e8 81       	ld	r30, Y
    271e:	f9 81       	ldd	r31, Y+1	; 0x01
    2720:	01 93       	st	Z+, r16
    2722:	f9 83       	std	Y+1, r31	; 0x01
    2724:	e8 83       	st	Y, r30
    2726:	06 c0       	rjmp	.+12     	; 0x2734 <fputc+0x3c>
    2728:	e8 85       	ldd	r30, Y+8	; 0x08
    272a:	f9 85       	ldd	r31, Y+9	; 0x09
    272c:	80 2f       	mov	r24, r16
    272e:	19 95       	eicall
    2730:	00 97       	sbiw	r24, 0x00	; 0
    2732:	31 f4       	brne	.+12     	; 0x2740 <fputc+0x48>
    2734:	8e 81       	ldd	r24, Y+6	; 0x06
    2736:	9f 81       	ldd	r25, Y+7	; 0x07
    2738:	01 96       	adiw	r24, 0x01	; 1
    273a:	9f 83       	std	Y+7, r25	; 0x07
    273c:	8e 83       	std	Y+6, r24	; 0x06
    273e:	02 c0       	rjmp	.+4      	; 0x2744 <fputc+0x4c>
    2740:	0f ef       	ldi	r16, 0xFF	; 255
    2742:	1f ef       	ldi	r17, 0xFF	; 255
    2744:	c8 01       	movw	r24, r16
    2746:	df 91       	pop	r29
    2748:	cf 91       	pop	r28
    274a:	1f 91       	pop	r17
    274c:	0f 91       	pop	r16
    274e:	08 95       	ret

00002750 <__ultoa_invert>:
    2750:	fa 01       	movw	r30, r20
    2752:	aa 27       	eor	r26, r26
    2754:	28 30       	cpi	r18, 0x08	; 8
    2756:	51 f1       	breq	.+84     	; 0x27ac <__ultoa_invert+0x5c>
    2758:	20 31       	cpi	r18, 0x10	; 16
    275a:	81 f1       	breq	.+96     	; 0x27bc <__ultoa_invert+0x6c>
    275c:	e8 94       	clt
    275e:	6f 93       	push	r22
    2760:	6e 7f       	andi	r22, 0xFE	; 254
    2762:	6e 5f       	subi	r22, 0xFE	; 254
    2764:	7f 4f       	sbci	r23, 0xFF	; 255
    2766:	8f 4f       	sbci	r24, 0xFF	; 255
    2768:	9f 4f       	sbci	r25, 0xFF	; 255
    276a:	af 4f       	sbci	r26, 0xFF	; 255
    276c:	b1 e0       	ldi	r27, 0x01	; 1
    276e:	3e d0       	rcall	.+124    	; 0x27ec <__ultoa_invert+0x9c>
    2770:	b4 e0       	ldi	r27, 0x04	; 4
    2772:	3c d0       	rcall	.+120    	; 0x27ec <__ultoa_invert+0x9c>
    2774:	67 0f       	add	r22, r23
    2776:	78 1f       	adc	r23, r24
    2778:	89 1f       	adc	r24, r25
    277a:	9a 1f       	adc	r25, r26
    277c:	a1 1d       	adc	r26, r1
    277e:	68 0f       	add	r22, r24
    2780:	79 1f       	adc	r23, r25
    2782:	8a 1f       	adc	r24, r26
    2784:	91 1d       	adc	r25, r1
    2786:	a1 1d       	adc	r26, r1
    2788:	6a 0f       	add	r22, r26
    278a:	71 1d       	adc	r23, r1
    278c:	81 1d       	adc	r24, r1
    278e:	91 1d       	adc	r25, r1
    2790:	a1 1d       	adc	r26, r1
    2792:	20 d0       	rcall	.+64     	; 0x27d4 <__ultoa_invert+0x84>
    2794:	09 f4       	brne	.+2      	; 0x2798 <__ultoa_invert+0x48>
    2796:	68 94       	set
    2798:	3f 91       	pop	r19
    279a:	2a e0       	ldi	r18, 0x0A	; 10
    279c:	26 9f       	mul	r18, r22
    279e:	11 24       	eor	r1, r1
    27a0:	30 19       	sub	r19, r0
    27a2:	30 5d       	subi	r19, 0xD0	; 208
    27a4:	31 93       	st	Z+, r19
    27a6:	de f6       	brtc	.-74     	; 0x275e <__ultoa_invert+0xe>
    27a8:	cf 01       	movw	r24, r30
    27aa:	08 95       	ret
    27ac:	46 2f       	mov	r20, r22
    27ae:	47 70       	andi	r20, 0x07	; 7
    27b0:	40 5d       	subi	r20, 0xD0	; 208
    27b2:	41 93       	st	Z+, r20
    27b4:	b3 e0       	ldi	r27, 0x03	; 3
    27b6:	0f d0       	rcall	.+30     	; 0x27d6 <__ultoa_invert+0x86>
    27b8:	c9 f7       	brne	.-14     	; 0x27ac <__ultoa_invert+0x5c>
    27ba:	f6 cf       	rjmp	.-20     	; 0x27a8 <__ultoa_invert+0x58>
    27bc:	46 2f       	mov	r20, r22
    27be:	4f 70       	andi	r20, 0x0F	; 15
    27c0:	40 5d       	subi	r20, 0xD0	; 208
    27c2:	4a 33       	cpi	r20, 0x3A	; 58
    27c4:	18 f0       	brcs	.+6      	; 0x27cc <__ultoa_invert+0x7c>
    27c6:	49 5d       	subi	r20, 0xD9	; 217
    27c8:	31 fd       	sbrc	r19, 1
    27ca:	40 52       	subi	r20, 0x20	; 32
    27cc:	41 93       	st	Z+, r20
    27ce:	02 d0       	rcall	.+4      	; 0x27d4 <__ultoa_invert+0x84>
    27d0:	a9 f7       	brne	.-22     	; 0x27bc <__ultoa_invert+0x6c>
    27d2:	ea cf       	rjmp	.-44     	; 0x27a8 <__ultoa_invert+0x58>
    27d4:	b4 e0       	ldi	r27, 0x04	; 4
    27d6:	a6 95       	lsr	r26
    27d8:	97 95       	ror	r25
    27da:	87 95       	ror	r24
    27dc:	77 95       	ror	r23
    27de:	67 95       	ror	r22
    27e0:	ba 95       	dec	r27
    27e2:	c9 f7       	brne	.-14     	; 0x27d6 <__ultoa_invert+0x86>
    27e4:	00 97       	sbiw	r24, 0x00	; 0
    27e6:	61 05       	cpc	r22, r1
    27e8:	71 05       	cpc	r23, r1
    27ea:	08 95       	ret
    27ec:	9b 01       	movw	r18, r22
    27ee:	ac 01       	movw	r20, r24
    27f0:	0a 2e       	mov	r0, r26
    27f2:	06 94       	lsr	r0
    27f4:	57 95       	ror	r21
    27f6:	47 95       	ror	r20
    27f8:	37 95       	ror	r19
    27fa:	27 95       	ror	r18
    27fc:	ba 95       	dec	r27
    27fe:	c9 f7       	brne	.-14     	; 0x27f2 <__ultoa_invert+0xa2>
    2800:	62 0f       	add	r22, r18
    2802:	73 1f       	adc	r23, r19
    2804:	84 1f       	adc	r24, r20
    2806:	95 1f       	adc	r25, r21
    2808:	a0 1d       	adc	r26, r0
    280a:	08 95       	ret

0000280c <_exit>:
    280c:	f8 94       	cli

0000280e <__stop_program>:
    280e:	ff cf       	rjmp	.-2      	; 0x280e <__stop_program>
